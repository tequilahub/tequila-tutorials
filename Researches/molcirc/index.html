<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jakob Kottmann">
<meta name="dcterms.date" content="2024-09-12">

<title>Tequila Tutorials - Molecular Quantum Circuits</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V7DRP5E70N"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-V7DRP5E70N', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"express",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Tequila Tutorials - Molecular Quantum Circuits">
<meta property="og:description" content="quantum computing, quantum chemistry and tequila">
<meta property="og:image" content="https://tequilahub.github.io/tequila-tutorials/Researches/molcirc/molcirc.png">
<meta property="og:site_name" content="Tequila Tutorials">
<meta property="og:image:height" content="700">
<meta property="og:image:width" content="1000">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../tequila_logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Tequila Tutorials</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../FAQ/FAQ.html"> 
<span class="menu-text">FAQ</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Contribution/Contribution.html"> 
<span class="menu-text">Contribution</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Molecular Quantum Circuits</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">tequila</div>
                <div class="quarto-category">code</div>
                <div class="quarto-category">chemistry</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jakob Kottmann </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 12, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#basic-building-blocks" id="toc-basic-building-blocks" class="nav-link active" data-scroll-target="#basic-building-blocks">Basic Building Blocks</a></li>
  <li><a href="#example" id="toc-example" class="nav-link" data-scroll-target="#example">Example</a></li>
  <li><a href="#further-reading" id="toc-further-reading" class="nav-link" data-scroll-target="#further-reading">Further Reading</a></li>
  <li><a href="#dependencies-and-installation" id="toc-dependencies-and-installation" class="nav-link" data-scroll-target="#dependencies-and-installation">Dependencies and Installation</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/tequilahub/tequila/blob/main/Researches/molcirc/index.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/tequilahub/tequila/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Physical insights into the construction of quantum circuits.</p>
<center>
<img src="molcirc.png" class="img-fluid" width="400">
</center>
<p>Chemical graphs (or Lewis structures/resonance structures) are a powerful abstraction concept, that allows the qualitative prediction of molecular properties or reactions from a remarkably simple structure. Applied to the design of quantum circuits for electronic ground states (the ground states of molecules), chemical graphs allow physical insight into construction, optimization, and interpretation of quantum circuits.</p>
<p>A detailed description of this methodology is given in <a href="https://arxiv.org/abs/2207.12421">arxiv:2207.12421</a>. In this blog entry we will try to approach this circuit design principle through an explicit example.</p>
<section id="basic-building-blocks" class="level2">
<h2 class="anchored" data-anchor-id="basic-building-blocks">Basic Building Blocks</h2>
<p>In conventional methodologies of (unitary) coupled-cluster, the wavefunction is generated by exciting electrons from an initial basis state containing a specific number of electrons. A significant distinction between traditional coupled cluster (both unitary and non-unitary) and recent advancements in quantum circuit design lies in the exclusion of higher-order excitations. Instead, the focus is on utilizing a limited set of unitary operations, which are subsequently iteratively applied in a layer-by-layer manner.</p>
<p>Within conventional coupled-cluster approaches, a particular type of excitation, such as a single-electron excitation between two orbitals, is typically accounted for only once. To enhance accuracy, higher-order excitations are introduced.<br>
However, in the context of quantum circuit designs, like the one being discussed, this specific excitation might occur multiple times in various sections of the circuit, while the inclusion of higher-order excitations is often bypassed or minimized.</p>
<p>A simple choice of two basic building blocks for electronic quantum circuits are:</p>
<ul>
<li>Orbital Rotations (single electron excitations)<br>
</li>
<li>Pair Excitations (restricted double excitations)</li>
</ul>
<p>these operations are for example used in the prominent <a href="https://arxiv.org/abs/1810.02327">k-UpCCGSD</a> approach or the <a href="https://arxiv.org/abs/2105.03836">separable pair approximation</a>.</p>
<p>Take for example two orbitals <span class="math inline">\(\phi_0\)</span> and <span class="math inline">\(\phi_1\)</span> encoded into four qubits (<span class="math inline">\(\phi_0^\uparrow,\phi_0^\downarrow,\phi_1^\uparrow,\phi_1^\downarrow\)</span>) indicating the occupation of the corresponding spin-orbital. The qubit state holding a spin-paired electron pair in orbital <span class="math inline">\(\phi_0\)</span> is then <span class="math display">\[
\lvert 1100 \rangle.
\]</span> If we excite this spin-paired electron into the second spatial orbital we end up with <span class="math display">\[
\lvert 1100 \rangle \rightarrow \lvert 0011 \rangle.
\]</span></p>
<p>We can treat the spin-paired electrons bound to the same orbital as a quasi-particle – so-called Hard-core Bosons. A wavefunction constructed from Hard-core Boson states entirely is not invariant to rotations in the underlying orbital basis, as we are confining the spin-paired electrons to occupy a specific choice of orbitals. Graphically we can depict this as</p>
<center>
<img src="quasiparticle-cartoon.png" class="img-fluid" width="400">
</center>
<p>where we have shown the situation in a hydrogen molecule in a minimal basis – one atomic orbital on each hydrogen atom. In this case, the rotation into a different orbital basis clearly leads to a different wavefunction.<br>
The two bases depicted in the figure above are an atomic basis (native orbitals), which we will denote as <span class="math inline">\(\phi_L\)</span> and <span class="math inline">\(\phi_R\)</span> for left and right, and a molcular basis <span class="math display">\[
\phi_\pm = \frac{1}{\sqrt{2}} \phi_L \pm \phi_R.
\]</span> The state in the molecular basis as depicted above, can now be writte as <span class="math display">\[
\lvert \Psi \rangle = c_0 a^\dagger_{+_{\downarrow}} a^\dagger_{+_{\uparrow}} \lvert \rangle + c_1 a^\dagger_{-_{\downarrow}}a^\dagger_{-_{\uparrow}} \lvert \rangle
\]</span> using second quantized language. This is a Hardcore-Boson state with one quasi-particle in two possible orbitals. Expressed in the atomic basis, this state looks like <span class="math display">\[
\lvert \Psi \rangle = \frac{1}{2} \left(c_0+c_1\right) \left(a^\dagger_{L_{\downarrow}}a^\dagger_{L_{\uparrow}} + a^\dagger_{L_{\downarrow}}a^\dagger_{L_{\uparrow}} \right)\lvert \rangle + \frac{1}{2}\left(c_0-c_1\right) \left(a^\dagger_{L_{\downarrow}}a^\dagger_{R_{\uparrow}} + a^\dagger_{R_{\downarrow}}a^\dagger_{L_{\uparrow}} \right)\lvert \rangle,
\]</span> with an ionic (both electrons either in <span class="math inline">\(L\)</span> or <span class="math inline">\(R\)</span>) and a neutral (one electron in <span class="math inline">\(L\)</span> and one in <span class="math inline">\(R\)</span>) part. Depending on the choice of the coefficients we can isolate both extremes. In the article this is used to demonstrate how a Hard-core Boson model, with electron pairs confined to the same orbital, is still able to describe bond breaking – <em>i.e.</em> by chosing <span class="math inline">\(c_1=-c_0\)</span> in the wavefunction above.</p>
<p>Quasi-particle models like the Hard-core Boson approach are therefore dependent on the chosen orbital basis. We can optimize the basis in order to find the best choice for a given quasi-particle wavefunction. These optimizations are however sensitive to initial guesses. Here, molecular graphs serve as a guiding heuristic to initialize good initial guesses for the orbital optimizer. In the original article, this is illustrated in detail on some examples. In the next section, you will find the code for the linear H<span class="math inline">\(_4\)</span> molecule.</p>
<p>Within quantum circuits, we can rotate the orbital basis with the second building block: the orbital rotations. This allows us to connect several quasi-particle models in sequence by rotating into different bases, correlating the quasi-particles in that basis and finally rotating back to the initial basis.<br>
The molecular graph will take the role as a guiding heuristic helping with placing and initializing the orbital rotation gates as well as the quasi-particle correlators within the quantum circuit.</p>
</section>
<section id="example" class="level2">
<h2 class="anchored" data-anchor-id="example">Example</h2>
<p>In the <a href="https://arxiv.org/abs/2207.12421">article</a> the linear H4 system has been used to illustrate the construction of quantum circuits from chemical graphs. We will use the H4 example from the paper and provide the code that reproduces it. First we initialize the molecule and represent the Hamiltonian in a minimal basis. Note that we are using (orthonormalized) atomic orbitals as our second quantized basis and not canonical Hartree-Fock orbitals.</p>
<div id="643160e9" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tequila <span class="im">as</span> tq</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> pi, eye</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>geometry <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 0.0</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 1.5</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 3.0</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 4.5</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> tq.Molecule(geometry<span class="op">=</span>geometry, basis_set<span class="op">=</span><span class="st">"sto-3g"</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># switch to native orbitals</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># in this case: orthonormalized sto-3g orbitals</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> mol.use_native_orbitals()</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> mol.make_hamiltonian()</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>exact <span class="op">=</span> mol.compute_energy(<span class="st">"fci"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As initial state we can construct an <a href="[separable pair approximation](https://arxiv.org/abs/2105.03836)">SPA</a> circuit using the first graph in the figure above. In this first graph, the H<span class="math inline">\(_4\)</span> molecule is interpreted as two H<span class="math inline">\(_2\)</span> molecules. We initializing the graph, by assigning basis orbitals to the vertices. Here we have 4 basis orbitals (atomic s-type orbitals located on the individual atoms), so the assignment is straightforward.</p>
<div id="d009f816" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># graph is</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># H--H  H--H</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>)]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>USPA <span class="op">=</span> mol.make_ansatz(name<span class="op">=</span><span class="st">"SPA"</span>, edges<span class="op">=</span>graph)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>ESPA <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>USPA)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(ESPA, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/Atomic error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>SPA/Atomic error: +1.09885</code></pre>
</div>
</div>
<p>we see, that the SPA does not perform well – the reason is that we are currently in an atomic orbital basis. In order to rotate the basis, we add orbital rotations to the initial circuit. Here we will use a static angle that will mix the orbitals in a equally weighted fashion (corresponding to Eq.19 in the article, here explicitly represented with unitary circuits). This represents the SPA in a basis that would correspond to the optimized setting in two isolated H2 molecules (<em>i.e.</em> the first graph)</p>
<div id="8362ac2f" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>UR0 <span class="op">=</span> tq.QCircuit()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> edge <span class="kw">in</span> graph:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    UR0 <span class="op">+=</span> mol.UR(edge[<span class="dv">0</span>],edge[<span class="dv">1</span>],angle<span class="op">=</span>pi<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>U0 <span class="op">=</span> USPA <span class="op">+</span> UR0</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>E0 <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U0)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E0, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/Molecular error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>SPA/Molecular error: +0.04009</code></pre>
</div>
</div>
<p>The error is now 40 millihartree. We can bring it further down by allowing the orbitals to relax which can be achieved by adding more orbital rotations with variable angles. We initialize the angles to zero (<em>i.e.</em> we are starting from our previous result as guess). We chose the same pattern as in the <span class="math inline">\(U_\text{RR}\)</span> circuits in the article</p>
<div id="1336bca4" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>URR0 <span class="op">=</span> mol.UR(<span class="dv">0</span>,<span class="dv">1</span>,angle<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>URR0 <span class="op">=</span> mol.UR(<span class="dv">2</span>,<span class="dv">3</span>,angle<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>URR0 <span class="op">=</span> mol.UR(<span class="dv">1</span>,<span class="dv">2</span>,angle<span class="op">=</span><span class="st">"a"</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>U0 <span class="op">=</span> USPA <span class="op">+</span> URR0 <span class="op">+</span> UR0 <span class="op">+</span> URR0 </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>E0 <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U0)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E0, silent<span class="op">=</span><span class="va">True</span>, initial_values<span class="op">=</span>result.variables)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/Relaxed-Molecular error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>SPA/Relaxed-Molecular error: +0.03560</code></pre>
</div>
</div>
<p>Alternatively we can optimize the orbitals with respect to the SPA wavefunction (the strategy from the article) and use this as our orbital basis. As the SPA wavefunction is entirelty within the Hardcode-boson quasiparticle approximation, we can perform the optimization within that approximation reducing our simulation time significantly (see code in the article for the equivalent optimization without HCB approximation)</p>
<div id="73ba3e2d" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>UHCB <span class="op">=</span> mol.make_ansatz(name<span class="op">=</span><span class="st">"HCB-SPA"</span>, edges<span class="op">=</span>graph)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> eye(<span class="dv">4</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>opt <span class="op">=</span> tq.chemistry.optimize_orbitals(circuit<span class="op">=</span>UHCB,molecule<span class="op">=</span>mol, use_hcb<span class="op">=</span><span class="va">True</span>, initial_guess<span class="op">=</span>guess.T, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co"># update our Hamiltonian</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> opt.molecule</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> mol.make_hamiltonian()</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>USPA <span class="op">=</span> UHCB <span class="op">+</span> mol.hcb_to_me()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>USPA)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/opt-orbitals error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>SPA/opt-orbitals error: +0.01626</code></pre>
</div>
</div>
<p>Note, that we can get the same result by providing enough orbital rotations to our circuit.</p>
<p>To improve on the SPA model in the optimal basis we take the second graph and apply the following pattern <span class="math display">\[
U_G = U_R^\dagger U_C U_R
\]</span> that corresponds to 1. rotate into a new orbital basis that resembles the graph structure 2. correlate the quasi particles in this orbital basis 3. rotate back</p>
<p>In the following we will do this for the H4 system using the two graphs indicated in the picture above. The first graph is used for the SPA initalization, and the second graph will add further correlation to the initial SPA state. Note that we included an approximation by neglecting one edge in the second graph which we will not correlated. The code-block is identical as the on in the appendix of the article.</p>
<div id="95856a5c" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># dependencies: tequila &gt;= 1.8.7, pyscf~=1.7, scipy~=1.7</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># suggested quantum backend for optimal performance: qulacs &gt;= 0.3</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tequila <span class="im">as</span> tq</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> eye, pi</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the molecule object</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># use orthonormalized atomic orbitals as basis</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>geometry <span class="op">=</span> <span class="st">"h 0.0 0.0 0.0</span><span class="ch">\n</span><span class="st">h 0.0 0.0 1.5</span><span class="ch">\n</span><span class="st">h 0.0 0.0 3.0</span><span class="ch">\n</span><span class="st">h 0.0 0.0 4.5"</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> tq.Molecule(geometry<span class="op">=</span>geometry, basis_set<span class="op">=</span><span class="st">"sto-3g"</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>energies <span class="op">=</span> {<span class="st">"FCI"</span>:mol.compute_energy(<span class="st">"fci"</span>)}</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co"># switch from canonical HF orbitals to orthonormalized STO-3G orbitals</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co"># to follow notation in the article</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> mol.use_native_orbitals()</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the SPA circuit for</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph: H -- H    H -- H</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co"># edges get tuples of orbital-indices assigned</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>USPA <span class="op">=</span> mol.make_ansatz(name<span class="op">=</span><span class="st">"SPA"</span>, edges<span class="op">=</span>[(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>)])</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="co"># initial guess for the orbitals</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="co"># according to graph in Eq.(17) and orbitals in Eq.(19)</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> eye(<span class="dv">4</span>)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>]</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">1</span>] <span class="op">=</span> [<span class="fl">1.0</span>,<span class="op">-</span><span class="fl">1.</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>]</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">2</span>] <span class="op">=</span> [<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>]</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">3</span>] <span class="op">=</span> [<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="op">-</span><span class="fl">1.</span>]</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a><span class="co"># optimize orbitals and circuit parameter</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="co"># PySCF interface</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>opt <span class="op">=</span> tq.chemistry.optimize_orbitals(mol, circuit<span class="op">=</span>USPA, initial_guess<span class="op">=</span>guess.T)</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optimized Orbital Coefficients"</span>)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(opt.molecule.integral_manager.orbital_coefficients)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>energies[<span class="st">"SPA"</span>] <span class="op">=</span> opt.energy</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="co"># get Hamiltonian with optimized orbitals</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> opt.molecule.make_hamiltonian()</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize rotations to graph in Eq.(21)</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a><span class="co"># H    H -- H    H</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a><span class="co"># as illustrated in Eq.(24)</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a><span class="co"># UR as in Eq.(7) uses spatial orbital indices</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>R0 <span class="op">=</span> tq.Variable(<span class="st">"R0"</span>)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>R1 <span class="op">=</span> tq.Variable(<span class="st">"R1"</span>)</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>UR0 <span class="op">=</span> mol.UR(<span class="dv">0</span>,<span class="dv">1</span>,angle<span class="op">=</span>(R0<span class="op">+</span><span class="fl">0.5</span>)<span class="op">*</span>pi)</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>UR0<span class="op">+=</span> mol.UR(<span class="dv">2</span>,<span class="dv">3</span>,angle<span class="op">=</span>(R0<span class="op">+</span><span class="fl">0.5</span>)<span class="op">*</span>pi)</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>UR1 <span class="op">=</span> mol.UR(<span class="dv">1</span>,<span class="dv">2</span>,angle<span class="op">=</span>(R1<span class="op">+</span><span class="fl">0.5</span>)<span class="op">*</span>pi)</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize correlator according to Eq.(22)</span></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>UC <span class="op">=</span> mol.UC(<span class="dv">1</span>,<span class="dv">2</span>,angle<span class="op">=</span><span class="st">"C"</span>)</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a><span class="co"># construct the circuit for both graphs</span></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> USPA <span class="op">+</span> UR0 <span class="op">+</span> UR1 <span class="op">+</span> UC <span class="op">+</span> UR1.dagger() <span class="op">+</span> UR0.dagger()</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a><span class="co"># optimize the energy</span></span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U)</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>energies[<span class="st">"SPA+"</span>] <span class="op">=</span> result.energy</span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(energies)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="28bc8437" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k,v <span class="kw">in</span> energies.items():</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"fci"</span> <span class="kw">in</span> k.lower(): <span class="cf">continue</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="sc">{:5}</span><span class="st"> error : </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(k,v<span class="op">-</span>exact))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>SPA   error : +0.01626
SPA+  error : +0.00844</code></pre>
</div>
</div>
</section>
<section id="further-reading" class="level2">
<h2 class="anchored" data-anchor-id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://arxiv.org/abs/2207.12421">Original Article</a></li>
<li><a href="https://arxiv.org/abs/2302.10660">Divide and Conquer Approach</a></li>
<li><a href="https://arxiv.org/abs/2105.03836">Separable Pair Approximation</a></li>
</ul>
</section>
<section id="dependencies-and-installation" class="level2">
<h2 class="anchored" data-anchor-id="dependencies-and-installation">Dependencies and Installation</h2>
<p>In order to execute code from this blog entry you need the following dependencies in your environment</p>
<pre class="{bash}"><code>pip install tequila-basic
pip install pyscf
# optional (significantly faster)
pip install qulacs</code></pre>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/tequilahub\.github\.io\/tequila-tutorials\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="tequilahub/tequila-tutorials" issue-term="pathname" theme="preferred-color-scheme" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb14" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Molecular Quantum Circuits"</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Jakob Kottmann"</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2024-09-12"</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [tequila, code, chemistry]</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> "molcirc.png"</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="an">image-width:</span><span class="co"> "1cm"</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="an">image-height:</span><span class="co"> "1cm"</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">    html:</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">        code-fold: false</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">        eval: true</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> blogqa</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>Physical insights into the construction of quantum circuits.  </span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>&lt;center&gt;</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="al">![](molcirc.png)</span>{width=400}</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>&lt;/center&gt;  </span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>Chemical graphs (or Lewis structures/resonance structures) are a powerful abstraction concept, that allows the qualitative prediction of molecular properties or reactions from a remarkably simple structure.</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>Applied to the design of quantum circuits for electronic ground states (the ground states of molecules), chemical graphs allow physical insight into construction, optimization, and</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>interpretation of quantum circuits.  </span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>A detailed description of this methodology is given in <span class="co">[</span><span class="ot">arxiv:2207.12421</span><span class="co">](https://arxiv.org/abs/2207.12421)</span>. In this blog entry we will try to approach this circuit design principle through an explicit example.</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a><span class="fu">## Basic Building Blocks</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>In conventional methodologies of (unitary) coupled-cluster, the wavefunction is generated by exciting electrons from an initial basis state containing a specific number of electrons. A significant distinction between traditional coupled cluster (both unitary and non-unitary) and recent advancements in quantum circuit design lies in the exclusion of higher-order excitations. Instead, the focus is on utilizing a limited set of unitary operations, which are subsequently iteratively applied in a layer-by-layer manner.   </span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>Within conventional coupled-cluster approaches, a particular type of excitation, such as a single-electron excitation between two orbitals, is typically accounted for only once. To enhance accuracy, higher-order excitations are introduced.  </span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>However, in the context of quantum circuit designs, like the one being discussed, this specific excitation might occur multiple times in various sections of the circuit, while the inclusion of higher-order excitations is often bypassed or minimized. </span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>A simple choice of two basic building blocks for electronic quantum circuits are: </span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Orbital Rotations (single electron excitations)  </span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Pair Excitations (restricted double excitations)  </span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>these operations are for example used in the prominent <span class="co">[</span><span class="ot">k-UpCCGSD</span><span class="co">](https://arxiv.org/abs/1810.02327)</span> approach or the <span class="co">[</span><span class="ot">separable pair approximation</span><span class="co">](https://arxiv.org/abs/2105.03836)</span>. </span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>Take for example two orbitals $\phi_0$ and $\phi_1$ encoded into four qubits ($\phi_0^\uparrow,\phi_0^\downarrow,\phi_1^\uparrow,\phi_1^\downarrow$) indicating the occupation of the corresponding spin-orbital. The qubit state holding a spin-paired electron pair in orbital $\phi_0$ is then</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>\lvert 1100 \rangle.</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>If we excite this spin-paired electron into the second spatial orbital we end up with</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>\lvert 1100 \rangle \rightarrow \lvert 0011 \rangle.</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>We can treat the spin-paired electrons bound to the same orbital as a quasi-particle -- so-called Hard-core Bosons. </span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>A wavefunction constructed from Hard-core Boson states entirely is not invariant to rotations in the underlying orbital basis, as we are confining the spin-paired electrons to occupy a specific choice of orbitals. Graphically we can depict this as  </span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>&lt;center&gt;</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a><span class="al">![](quasiparticle-cartoon.png)</span>{width=400}</span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>&lt;/center&gt;</span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a>where we have shown the situation in a hydrogen molecule in a minimal basis -- one atomic orbital on each hydrogen atom. In this case, the rotation into a different orbital basis clearly leads to a different wavefunction.  </span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a>The two bases depicted in the figure above are an atomic basis (native orbitals), which we will denote as $\phi_L$ and $\phi_R$ for left and right, and a molcular basis</span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a>\phi_\pm = \frac{1}{\sqrt{2}} \phi_L \pm \phi_R.</span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a>The state in the molecular basis as depicted above, can now be writte as</span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a>\lvert \Psi \rangle = c_0 a^\dagger_{+_{\downarrow}} a^\dagger_{+_{\uparrow}} \lvert \rangle + c_1 a^\dagger_{-_{\downarrow}}a^\dagger_{-_{\uparrow}} \lvert \rangle </span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a>using second quantized language. </span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a>This is a Hardcore-Boson state with one quasi-particle in two possible orbitals. </span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a>Expressed in the atomic basis, this state looks like</span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true" tabindex="-1"></a>\lvert \Psi \rangle = \frac{1}{2} \left(c_0+c_1\right) \left(a^\dagger_{L_{\downarrow}}a^\dagger_{L_{\uparrow}} + a^\dagger_{L_{\downarrow}}a^\dagger_{L_{\uparrow}} \right)\lvert \rangle + \frac{1}{2}\left(c_0-c_1\right) \left(a^\dagger_{L_{\downarrow}}a^\dagger_{R_{\uparrow}} + a^\dagger_{R_{\downarrow}}a^\dagger_{L_{\uparrow}} \right)\lvert \rangle,</span>
<span id="cb14-76"><a href="#cb14-76" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-77"><a href="#cb14-77" aria-hidden="true" tabindex="-1"></a>with an ionic (both electrons either in $L$ or $R$) and a neutral (one electron in $L$ and one in $R$) part. Depending on the choice of the coefficients we can isolate both extremes. In the article this is used to demonstrate how a Hard-core Boson model, with electron pairs confined to the same orbital, is still able to describe bond breaking -- *i.e.* by chosing $c_1=-c_0$ in the wavefunction above.   </span>
<span id="cb14-78"><a href="#cb14-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-79"><a href="#cb14-79" aria-hidden="true" tabindex="-1"></a>Quasi-particle models like the Hard-core Boson approach are therefore dependent on the chosen orbital basis. </span>
<span id="cb14-80"><a href="#cb14-80" aria-hidden="true" tabindex="-1"></a>We can optimize the basis in order to find the best choice for a given quasi-particle wavefunction. These optimizations are however sensitive to initial guesses. Here, molecular graphs serve as a guiding heuristic to initialize good initial guesses for the orbital optimizer. In the original article, this is illustrated in detail on some examples. In the next section, you will find the code for the linear H$_4$ molecule.  </span>
<span id="cb14-81"><a href="#cb14-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-82"><a href="#cb14-82" aria-hidden="true" tabindex="-1"></a>Within quantum circuits, we can rotate the orbital basis with the second building block: the orbital rotations. This allows us to connect several quasi-particle models in sequence by rotating into different bases, correlating the quasi-particles in that basis and finally rotating back to the initial basis.  </span>
<span id="cb14-83"><a href="#cb14-83" aria-hidden="true" tabindex="-1"></a>The molecular graph will take the role as a guiding heuristic helping with placing and initializing the orbital rotation gates as well as the quasi-particle correlators within the quantum circuit.</span>
<span id="cb14-84"><a href="#cb14-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-85"><a href="#cb14-85" aria-hidden="true" tabindex="-1"></a><span class="fu">## Example </span></span>
<span id="cb14-86"><a href="#cb14-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-87"><a href="#cb14-87" aria-hidden="true" tabindex="-1"></a>In the <span class="co">[</span><span class="ot">article</span><span class="co">](https://arxiv.org/abs/2207.12421)</span> the linear H4 system has been used to illustrate the construction of quantum circuits from chemical graphs. We will use the H4 example from the paper and provide the code that reproduces it. First we initialize the molecule and represent the Hamiltonian in a minimal basis. Note that we are using (orthonormalized) atomic orbitals as our second quantized basis and not canonical Hartree-Fock orbitals.</span>
<span id="cb14-88"><a href="#cb14-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-91"><a href="#cb14-91" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb14-92"><a href="#cb14-92" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: false</span></span>
<span id="cb14-93"><a href="#cb14-93" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb14-94"><a href="#cb14-94" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tequila <span class="im">as</span> tq</span>
<span id="cb14-95"><a href="#cb14-95" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> pi, eye</span>
<span id="cb14-96"><a href="#cb14-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-97"><a href="#cb14-97" aria-hidden="true" tabindex="-1"></a>geometry <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb14-98"><a href="#cb14-98" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 0.0</span></span>
<span id="cb14-99"><a href="#cb14-99" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 1.5</span></span>
<span id="cb14-100"><a href="#cb14-100" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 3.0</span></span>
<span id="cb14-101"><a href="#cb14-101" aria-hidden="true" tabindex="-1"></a><span class="st">H 0.0 0.0 4.5</span></span>
<span id="cb14-102"><a href="#cb14-102" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb14-103"><a href="#cb14-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-104"><a href="#cb14-104" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> tq.Molecule(geometry<span class="op">=</span>geometry, basis_set<span class="op">=</span><span class="st">"sto-3g"</span>)</span>
<span id="cb14-105"><a href="#cb14-105" aria-hidden="true" tabindex="-1"></a><span class="co"># switch to native orbitals</span></span>
<span id="cb14-106"><a href="#cb14-106" aria-hidden="true" tabindex="-1"></a><span class="co"># in this case: orthonormalized sto-3g orbitals</span></span>
<span id="cb14-107"><a href="#cb14-107" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> mol.use_native_orbitals()</span>
<span id="cb14-108"><a href="#cb14-108" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> mol.make_hamiltonian()</span>
<span id="cb14-109"><a href="#cb14-109" aria-hidden="true" tabindex="-1"></a>exact <span class="op">=</span> mol.compute_energy(<span class="st">"fci"</span>)</span>
<span id="cb14-110"><a href="#cb14-110" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-111"><a href="#cb14-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-112"><a href="#cb14-112" aria-hidden="true" tabindex="-1"></a>As initial state we can construct an <span class="co">[</span><span class="ot">SPA</span><span class="co">]</span>(<span class="co">[</span><span class="ot">separable pair approximation</span><span class="co">](https://arxiv.org/abs/2105.03836)</span>) circuit using the first graph in the figure above. In this first graph, the H$_4$ molecule is interpreted as two H$_2$ molecules. We initializing the graph, by assigning basis orbitals to the vertices. Here we have 4 basis orbitals (atomic s-type orbitals located on the individual atoms), so the assignment is straightforward.</span>
<span id="cb14-115"><a href="#cb14-115" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb14-116"><a href="#cb14-116" aria-hidden="true" tabindex="-1"></a><span class="co"># graph is</span></span>
<span id="cb14-117"><a href="#cb14-117" aria-hidden="true" tabindex="-1"></a><span class="co"># H--H  H--H</span></span>
<span id="cb14-118"><a href="#cb14-118" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>)]</span>
<span id="cb14-119"><a href="#cb14-119" aria-hidden="true" tabindex="-1"></a>USPA <span class="op">=</span> mol.make_ansatz(name<span class="op">=</span><span class="st">"SPA"</span>, edges<span class="op">=</span>graph)</span>
<span id="cb14-120"><a href="#cb14-120" aria-hidden="true" tabindex="-1"></a>ESPA <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>USPA)</span>
<span id="cb14-121"><a href="#cb14-121" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(ESPA, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-122"><a href="#cb14-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-123"><a href="#cb14-123" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/Atomic error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span>
<span id="cb14-124"><a href="#cb14-124" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-125"><a href="#cb14-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-126"><a href="#cb14-126" aria-hidden="true" tabindex="-1"></a>we see, that the SPA does not perform well -- the reason is that we are currently in an atomic orbital basis. In order to rotate the basis, we add orbital rotations to the initial circuit. Here we will use a static angle that will mix the orbitals in a equally weighted fashion (corresponding to Eq.19 in the article, here explicitly represented with unitary circuits). This represents the SPA in a basis that would correspond to the optimized setting in two isolated H2 molecules (*i.e.* the first graph) </span>
<span id="cb14-127"><a href="#cb14-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-130"><a href="#cb14-130" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb14-131"><a href="#cb14-131" aria-hidden="true" tabindex="-1"></a>UR0 <span class="op">=</span> tq.QCircuit()</span>
<span id="cb14-132"><a href="#cb14-132" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> edge <span class="kw">in</span> graph:</span>
<span id="cb14-133"><a href="#cb14-133" aria-hidden="true" tabindex="-1"></a>    UR0 <span class="op">+=</span> mol.UR(edge[<span class="dv">0</span>],edge[<span class="dv">1</span>],angle<span class="op">=</span>pi<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb14-134"><a href="#cb14-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-135"><a href="#cb14-135" aria-hidden="true" tabindex="-1"></a>U0 <span class="op">=</span> USPA <span class="op">+</span> UR0</span>
<span id="cb14-136"><a href="#cb14-136" aria-hidden="true" tabindex="-1"></a>E0 <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U0)</span>
<span id="cb14-137"><a href="#cb14-137" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E0, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-138"><a href="#cb14-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-139"><a href="#cb14-139" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/Molecular error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span>
<span id="cb14-140"><a href="#cb14-140" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-141"><a href="#cb14-141" aria-hidden="true" tabindex="-1"></a>The error is now 40 millihartree. We can bring it further down by allowing the orbitals to relax which can be achieved by adding more orbital rotations with variable angles. We initialize the angles to zero (*i.e.* we are starting from our previous result as guess). We chose the same pattern as in the $U_\text{RR}$ circuits in the article</span>
<span id="cb14-142"><a href="#cb14-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-145"><a href="#cb14-145" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb14-146"><a href="#cb14-146" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb14-147"><a href="#cb14-147" aria-hidden="true" tabindex="-1"></a>URR0 <span class="op">=</span> mol.UR(<span class="dv">0</span>,<span class="dv">1</span>,angle<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb14-148"><a href="#cb14-148" aria-hidden="true" tabindex="-1"></a>URR0 <span class="op">=</span> mol.UR(<span class="dv">2</span>,<span class="dv">3</span>,angle<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb14-149"><a href="#cb14-149" aria-hidden="true" tabindex="-1"></a>URR0 <span class="op">=</span> mol.UR(<span class="dv">1</span>,<span class="dv">2</span>,angle<span class="op">=</span><span class="st">"a"</span>)</span>
<span id="cb14-150"><a href="#cb14-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-151"><a href="#cb14-151" aria-hidden="true" tabindex="-1"></a>U0 <span class="op">=</span> USPA <span class="op">+</span> URR0 <span class="op">+</span> UR0 <span class="op">+</span> URR0 </span>
<span id="cb14-152"><a href="#cb14-152" aria-hidden="true" tabindex="-1"></a>E0 <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U0)</span>
<span id="cb14-153"><a href="#cb14-153" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E0, silent<span class="op">=</span><span class="va">True</span>, initial_values<span class="op">=</span>result.variables)</span>
<span id="cb14-154"><a href="#cb14-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-155"><a href="#cb14-155" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/Relaxed-Molecular error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span>
<span id="cb14-156"><a href="#cb14-156" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-157"><a href="#cb14-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-158"><a href="#cb14-158" aria-hidden="true" tabindex="-1"></a>Alternatively we can optimize the orbitals with respect to the SPA wavefunction (the strategy from the article) and use this as our orbital basis. As the SPA wavefunction is entirelty within the Hardcode-boson quasiparticle approximation, we can perform the optimization within that approximation reducing our simulation time significantly (see code in the article for the equivalent optimization without HCB approximation)</span>
<span id="cb14-161"><a href="#cb14-161" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb14-162"><a href="#cb14-162" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb14-163"><a href="#cb14-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-164"><a href="#cb14-164" aria-hidden="true" tabindex="-1"></a>UHCB <span class="op">=</span> mol.make_ansatz(name<span class="op">=</span><span class="st">"HCB-SPA"</span>, edges<span class="op">=</span>graph)</span>
<span id="cb14-165"><a href="#cb14-165" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> eye(<span class="dv">4</span>)</span>
<span id="cb14-166"><a href="#cb14-166" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb14-167"><a href="#cb14-167" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb14-168"><a href="#cb14-168" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb14-169"><a href="#cb14-169" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>,<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-170"><a href="#cb14-170" aria-hidden="true" tabindex="-1"></a>opt <span class="op">=</span> tq.chemistry.optimize_orbitals(circuit<span class="op">=</span>UHCB,molecule<span class="op">=</span>mol, use_hcb<span class="op">=</span><span class="va">True</span>, initial_guess<span class="op">=</span>guess.T, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-171"><a href="#cb14-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-172"><a href="#cb14-172" aria-hidden="true" tabindex="-1"></a><span class="co"># update our Hamiltonian</span></span>
<span id="cb14-173"><a href="#cb14-173" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> opt.molecule</span>
<span id="cb14-174"><a href="#cb14-174" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> mol.make_hamiltonian()</span>
<span id="cb14-175"><a href="#cb14-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-176"><a href="#cb14-176" aria-hidden="true" tabindex="-1"></a>USPA <span class="op">=</span> UHCB <span class="op">+</span> mol.hcb_to_me()</span>
<span id="cb14-177"><a href="#cb14-177" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>USPA)</span>
<span id="cb14-178"><a href="#cb14-178" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-179"><a href="#cb14-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-180"><a href="#cb14-180" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"SPA/opt-orbitals error: </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(result.energy<span class="op">-</span>exact))</span>
<span id="cb14-181"><a href="#cb14-181" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-182"><a href="#cb14-182" aria-hidden="true" tabindex="-1"></a>Note, that we can get the same result by providing enough orbital rotations to our circuit.  </span>
<span id="cb14-183"><a href="#cb14-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-184"><a href="#cb14-184" aria-hidden="true" tabindex="-1"></a>To improve on the SPA model in the optimal basis we take the second graph and apply the following pattern</span>
<span id="cb14-185"><a href="#cb14-185" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-186"><a href="#cb14-186" aria-hidden="true" tabindex="-1"></a>U_G = U_R^\dagger U_C U_R</span>
<span id="cb14-187"><a href="#cb14-187" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb14-188"><a href="#cb14-188" aria-hidden="true" tabindex="-1"></a>that corresponds to</span>
<span id="cb14-189"><a href="#cb14-189" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>rotate into a new orbital basis that resembles the graph structure</span>
<span id="cb14-190"><a href="#cb14-190" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>correlate the quasi particles in this orbital basis</span>
<span id="cb14-191"><a href="#cb14-191" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>rotate back</span>
<span id="cb14-192"><a href="#cb14-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-193"><a href="#cb14-193" aria-hidden="true" tabindex="-1"></a>In the following we will do this for the H4 system using the two graphs indicated in the picture above. The first graph is used for the SPA initalization, and the second graph will add further correlation to the initial SPA state. </span>
<span id="cb14-194"><a href="#cb14-194" aria-hidden="true" tabindex="-1"></a>Note that we included an approximation by neglecting one edge in the second graph which we will not correlated. The code-block is identical as the on in the appendix of the article.</span>
<span id="cb14-195"><a href="#cb14-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-198"><a href="#cb14-198" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb14-199"><a href="#cb14-199" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb14-200"><a href="#cb14-200" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb14-201"><a href="#cb14-201" aria-hidden="true" tabindex="-1"></a><span class="co"># dependencies: tequila &gt;= 1.8.7, pyscf~=1.7, scipy~=1.7</span></span>
<span id="cb14-202"><a href="#cb14-202" aria-hidden="true" tabindex="-1"></a><span class="co"># suggested quantum backend for optimal performance: qulacs &gt;= 0.3</span></span>
<span id="cb14-203"><a href="#cb14-203" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tequila <span class="im">as</span> tq</span>
<span id="cb14-204"><a href="#cb14-204" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> eye, pi</span>
<span id="cb14-205"><a href="#cb14-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-206"><a href="#cb14-206" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the molecule object</span></span>
<span id="cb14-207"><a href="#cb14-207" aria-hidden="true" tabindex="-1"></a><span class="co"># use orthonormalized atomic orbitals as basis</span></span>
<span id="cb14-208"><a href="#cb14-208" aria-hidden="true" tabindex="-1"></a>geometry <span class="op">=</span> <span class="st">"h 0.0 0.0 0.0</span><span class="ch">\n</span><span class="st">h 0.0 0.0 1.5</span><span class="ch">\n</span><span class="st">h 0.0 0.0 3.0</span><span class="ch">\n</span><span class="st">h 0.0 0.0 4.5"</span></span>
<span id="cb14-209"><a href="#cb14-209" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> tq.Molecule(geometry<span class="op">=</span>geometry, basis_set<span class="op">=</span><span class="st">"sto-3g"</span>)</span>
<span id="cb14-210"><a href="#cb14-210" aria-hidden="true" tabindex="-1"></a>energies <span class="op">=</span> {<span class="st">"FCI"</span>:mol.compute_energy(<span class="st">"fci"</span>)}</span>
<span id="cb14-211"><a href="#cb14-211" aria-hidden="true" tabindex="-1"></a><span class="co"># switch from canonical HF orbitals to orthonormalized STO-3G orbitals</span></span>
<span id="cb14-212"><a href="#cb14-212" aria-hidden="true" tabindex="-1"></a><span class="co"># to follow notation in the article</span></span>
<span id="cb14-213"><a href="#cb14-213" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> mol.use_native_orbitals()</span>
<span id="cb14-214"><a href="#cb14-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-215"><a href="#cb14-215" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the SPA circuit for</span></span>
<span id="cb14-216"><a href="#cb14-216" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph: H -- H    H -- H</span></span>
<span id="cb14-217"><a href="#cb14-217" aria-hidden="true" tabindex="-1"></a><span class="co"># edges get tuples of orbital-indices assigned</span></span>
<span id="cb14-218"><a href="#cb14-218" aria-hidden="true" tabindex="-1"></a>USPA <span class="op">=</span> mol.make_ansatz(name<span class="op">=</span><span class="st">"SPA"</span>, edges<span class="op">=</span>[(<span class="dv">0</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">3</span>)])</span>
<span id="cb14-219"><a href="#cb14-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-220"><a href="#cb14-220" aria-hidden="true" tabindex="-1"></a><span class="co"># initial guess for the orbitals</span></span>
<span id="cb14-221"><a href="#cb14-221" aria-hidden="true" tabindex="-1"></a><span class="co"># according to graph in Eq.(17) and orbitals in Eq.(19)</span></span>
<span id="cb14-222"><a href="#cb14-222" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> eye(<span class="dv">4</span>)</span>
<span id="cb14-223"><a href="#cb14-223" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">0</span>] <span class="op">=</span> [<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>]</span>
<span id="cb14-224"><a href="#cb14-224" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">1</span>] <span class="op">=</span> [<span class="fl">1.0</span>,<span class="op">-</span><span class="fl">1.</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>]</span>
<span id="cb14-225"><a href="#cb14-225" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">2</span>] <span class="op">=</span> [<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="fl">1.0</span>]</span>
<span id="cb14-226"><a href="#cb14-226" aria-hidden="true" tabindex="-1"></a>guess[<span class="dv">3</span>] <span class="op">=</span> [<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="op">-</span><span class="fl">1.</span>]</span>
<span id="cb14-227"><a href="#cb14-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-228"><a href="#cb14-228" aria-hidden="true" tabindex="-1"></a><span class="co"># optimize orbitals and circuit parameter</span></span>
<span id="cb14-229"><a href="#cb14-229" aria-hidden="true" tabindex="-1"></a><span class="co"># PySCF interface</span></span>
<span id="cb14-230"><a href="#cb14-230" aria-hidden="true" tabindex="-1"></a>opt <span class="op">=</span> tq.chemistry.optimize_orbitals(mol, circuit<span class="op">=</span>USPA, initial_guess<span class="op">=</span>guess.T)</span>
<span id="cb14-231"><a href="#cb14-231" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Optimized Orbital Coefficients"</span>)</span>
<span id="cb14-232"><a href="#cb14-232" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(opt.molecule.integral_manager.orbital_coefficients)</span>
<span id="cb14-233"><a href="#cb14-233" aria-hidden="true" tabindex="-1"></a>energies[<span class="st">"SPA"</span>] <span class="op">=</span> opt.energy</span>
<span id="cb14-234"><a href="#cb14-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-235"><a href="#cb14-235" aria-hidden="true" tabindex="-1"></a><span class="co"># get Hamiltonian with optimized orbitals</span></span>
<span id="cb14-236"><a href="#cb14-236" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> opt.molecule.make_hamiltonian()</span>
<span id="cb14-237"><a href="#cb14-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-238"><a href="#cb14-238" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize rotations to graph in Eq.(21)</span></span>
<span id="cb14-239"><a href="#cb14-239" aria-hidden="true" tabindex="-1"></a><span class="co"># H    H -- H    H</span></span>
<span id="cb14-240"><a href="#cb14-240" aria-hidden="true" tabindex="-1"></a><span class="co"># as illustrated in Eq.(24)</span></span>
<span id="cb14-241"><a href="#cb14-241" aria-hidden="true" tabindex="-1"></a><span class="co"># UR as in Eq.(7) uses spatial orbital indices</span></span>
<span id="cb14-242"><a href="#cb14-242" aria-hidden="true" tabindex="-1"></a>R0 <span class="op">=</span> tq.Variable(<span class="st">"R0"</span>)</span>
<span id="cb14-243"><a href="#cb14-243" aria-hidden="true" tabindex="-1"></a>R1 <span class="op">=</span> tq.Variable(<span class="st">"R1"</span>)</span>
<span id="cb14-244"><a href="#cb14-244" aria-hidden="true" tabindex="-1"></a>UR0 <span class="op">=</span> mol.UR(<span class="dv">0</span>,<span class="dv">1</span>,angle<span class="op">=</span>(R0<span class="op">+</span><span class="fl">0.5</span>)<span class="op">*</span>pi)</span>
<span id="cb14-245"><a href="#cb14-245" aria-hidden="true" tabindex="-1"></a>UR0<span class="op">+=</span> mol.UR(<span class="dv">2</span>,<span class="dv">3</span>,angle<span class="op">=</span>(R0<span class="op">+</span><span class="fl">0.5</span>)<span class="op">*</span>pi)</span>
<span id="cb14-246"><a href="#cb14-246" aria-hidden="true" tabindex="-1"></a>UR1 <span class="op">=</span> mol.UR(<span class="dv">1</span>,<span class="dv">2</span>,angle<span class="op">=</span>(R1<span class="op">+</span><span class="fl">0.5</span>)<span class="op">*</span>pi)</span>
<span id="cb14-247"><a href="#cb14-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-248"><a href="#cb14-248" aria-hidden="true" tabindex="-1"></a><span class="co"># initialize correlator according to Eq.(22)</span></span>
<span id="cb14-249"><a href="#cb14-249" aria-hidden="true" tabindex="-1"></a>UC <span class="op">=</span> mol.UC(<span class="dv">1</span>,<span class="dv">2</span>,angle<span class="op">=</span><span class="st">"C"</span>)</span>
<span id="cb14-250"><a href="#cb14-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-251"><a href="#cb14-251" aria-hidden="true" tabindex="-1"></a><span class="co"># construct the circuit for both graphs</span></span>
<span id="cb14-252"><a href="#cb14-252" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> USPA <span class="op">+</span> UR0 <span class="op">+</span> UR1 <span class="op">+</span> UC <span class="op">+</span> UR1.dagger() <span class="op">+</span> UR0.dagger()</span>
<span id="cb14-253"><a href="#cb14-253" aria-hidden="true" tabindex="-1"></a><span class="co"># optimize the energy</span></span>
<span id="cb14-254"><a href="#cb14-254" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U)</span>
<span id="cb14-255"><a href="#cb14-255" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> tq.minimize(E, silent<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-256"><a href="#cb14-256" aria-hidden="true" tabindex="-1"></a>energies[<span class="st">"SPA+"</span>] <span class="op">=</span> result.energy</span>
<span id="cb14-257"><a href="#cb14-257" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(energies)</span>
<span id="cb14-258"><a href="#cb14-258" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-259"><a href="#cb14-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-262"><a href="#cb14-262" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb14-263"><a href="#cb14-263" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb14-264"><a href="#cb14-264" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k,v <span class="kw">in</span> energies.items():</span>
<span id="cb14-265"><a href="#cb14-265" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"fci"</span> <span class="kw">in</span> k.lower(): <span class="cf">continue</span></span>
<span id="cb14-266"><a href="#cb14-266" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="sc">{:5}</span><span class="st"> error : </span><span class="sc">{:+2.5f}</span><span class="st">"</span>.<span class="bu">format</span>(k,v<span class="op">-</span>exact))</span>
<span id="cb14-267"><a href="#cb14-267" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-268"><a href="#cb14-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-269"><a href="#cb14-269" aria-hidden="true" tabindex="-1"></a><span class="fu">## Further Reading</span></span>
<span id="cb14-270"><a href="#cb14-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-271"><a href="#cb14-271" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Original Article</span><span class="co">](https://arxiv.org/abs/2207.12421)</span></span>
<span id="cb14-272"><a href="#cb14-272" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Divide and Conquer Approach</span><span class="co">](https://arxiv.org/abs/2302.10660)</span></span>
<span id="cb14-273"><a href="#cb14-273" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Separable Pair Approximation</span><span class="co">](https://arxiv.org/abs/2105.03836)</span></span>
<span id="cb14-274"><a href="#cb14-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-275"><a href="#cb14-275" aria-hidden="true" tabindex="-1"></a><span class="fu">## Dependencies and Installation</span></span>
<span id="cb14-276"><a href="#cb14-276" aria-hidden="true" tabindex="-1"></a>In order to execute code from this blog entry you need the following dependencies in your environment</span>
<span id="cb14-279"><a href="#cb14-279" aria-hidden="true" tabindex="-1"></a><span class="in">```{bash}</span></span>
<span id="cb14-280"><a href="#cb14-280" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install tequila-basic</span>
<span id="cb14-281"><a href="#cb14-281" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pyscf</span>
<span id="cb14-282"><a href="#cb14-282" aria-hidden="true" tabindex="-1"></a><span class="co"># optional (significantly faster)</span></span>
<span id="cb14-283"><a href="#cb14-283" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install qulacs</span>
<span id="cb14-284"><a href="#cb14-284" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">

<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/tequilahub/tequila/blob/main/Researches/molcirc/index.qmd" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/tequilahub/tequila/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div><div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>