

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tequila_code.quantumchemistry.qc_base &mdash; Tequila Documentation 13.9.2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=7dcc51c3"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Tequila Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">Tequila Library Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Tequila Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../quantumchemistry.html">tequila_code.quantumchemistry</a></li>
      <li class="breadcrumb-item active">tequila_code.quantumchemistry.qc_base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tequila_code.quantumchemistry.qc_base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tequila</span><span class="w"> </span><span class="kn">import</span> <span class="n">TequilaException</span><span class="p">,</span> <span class="n">BitString</span><span class="p">,</span> <span class="n">TequilaWarning</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tequila.hamiltonian</span><span class="w"> </span><span class="kn">import</span> <span class="n">QubitHamiltonian</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tequila.hamiltonian.paulis</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sp</span><span class="p">,</span> <span class="n">Sm</span><span class="p">,</span> <span class="n">Zero</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tequila.circuit</span><span class="w"> </span><span class="kn">import</span> <span class="n">QCircuit</span><span class="p">,</span> <span class="n">gates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tequila.objective.objective</span><span class="w"> </span><span class="kn">import</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">Variables</span><span class="p">,</span> <span class="n">ExpectationValue</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tequila.simulators.simulator_api</span><span class="w"> </span><span class="kn">import</span> <span class="n">simulate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tequila.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">to_float</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.chemistry_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">ActiveSpaceData</span><span class="p">,</span> <span class="n">FermionicGateImpl</span><span class="p">,</span> <span class="n">prepare_product_state</span><span class="p">,</span> <span class="n">ClosedShellAmplitudes</span><span class="p">,</span> \
    <span class="n">Amplitudes</span><span class="p">,</span> <span class="n">ParametersQC</span><span class="p">,</span> <span class="n">NBodyTensor</span><span class="p">,</span> <span class="n">IntegralManager</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.encodings</span><span class="w"> </span><span class="kn">import</span> <span class="n">known_encodings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">typing</span><span class="o">,</span><span class="w"> </span><span class="nn">numpy</span><span class="o">,</span><span class="w"> </span><span class="nn">numbers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tequila.grouping.fermionic_functions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ff</span>


<span class="k">try</span><span class="p">:</span>
    <span class="c1"># if you are experiencing import errors you need to update openfermion</span>
    <span class="c1"># required is version &gt;= 1.0</span>
    <span class="c1"># otherwise replace with from openfermion.hamiltonians import MolecularData</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">openfermion</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">openfermion.chem</span><span class="w"> </span><span class="kn">import</span> <span class="n">MolecularData</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">openfermion.hamiltonians</span><span class="w"> </span><span class="kn">import</span> <span class="n">MolecularData</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">E</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="se">\n</span><span class="s2">Issue with Tequila Chemistry: Please update openfermion&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">E</span><span class="p">)))</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="n">OPTIMIZED_ORDERING</span> <span class="o">=</span> <span class="s2">&quot;Optimized&quot;</span>
<div class="viewcode-block" id="QuantumChemistryBase">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QuantumChemistryBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base Class for tequila chemistry functionality</span>
<span class="sd">    This is what is initialized with tq.Molecule(...)</span>
<span class="sd">    We try to define all main methods here and only implemented specializations in the derived classes</span>
<span class="sd">    Derived classes interface specific backends (e.g. Psi4, PySCF and Madness). See PACKAGE_interface.py for more</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">ParametersQC</span><span class="p">,</span>
                 <span class="n">transformation</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">active_orbitals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">frozen_orbitals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">orbital_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">reference_orbitals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">orbitals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters: the quantum chemistry parameters handed over as instance of the ParametersQC class (see there for content)</span>
<span class="sd">        transformation: the fermion to qubit transformation (default is JordanWigner). See encodings.py for supported encodings or to extend</span>
<span class="sd">        active_orbitals: list of active orbitals (others will be frozen, if we have N-electrons then the first N//2 orbitals will be considered occpied when creating the active space)</span>
<span class="sd">        frozen_orbitals: convenience (will be removed from list of active orbitals)</span>
<span class="sd">        reference_orbitals: give list of orbitals that shall be considered occupied when creating a possible active space (default is the first N//2). The indices are expected to be total indices (including possible frozen orbitals in the counting)</span>
<span class="sd">        orbitals: information about the orbitals (should be in OrbitalData format, can be a dictionary)</span>
<span class="sd">        args</span>
<span class="sd">        kwargs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">n_electrons</span>
        <span class="k">if</span> <span class="s2">&quot;n_electrons&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_electrons&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">reference_orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reference_orbitals</span> <span class="o">=</span> <span class="n">reference_orbitals</span>
        
        <span class="k">if</span> <span class="n">orbital_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbital_type</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>

        <span class="c1"># no frozen core with native orbitals (i.e. atomics)</span>
        <span class="n">overriding_freeze_instruction</span> <span class="o">=</span> <span class="n">orbital_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbital_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;native&quot;</span>
        <span class="c1"># determine frozen core automatically if set</span>
        <span class="c1"># only if molecule is computed from scratch and not passed down from above</span>
        <span class="n">overriding_freeze_instruction</span> <span class="o">=</span> <span class="n">overriding_freeze_instruction</span> <span class="ow">or</span> <span class="n">n_electrons</span> <span class="o">!=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">n_electrons</span>
        <span class="n">overriding_freeze_instruction</span> <span class="o">=</span> <span class="n">overriding_freeze_instruction</span> <span class="ow">or</span> <span class="n">frozen_orbitals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overriding_freeze_instruction</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">frozen_core</span><span class="p">:</span>
            <span class="n">n_core_electrons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get_number_of_core_electrons</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">frozen_orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">frozen_orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_core_electrons</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
            

        <span class="c1"># initialize integral manager</span>
        <span class="k">if</span> <span class="s2">&quot;integral_manager&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;integral_manager&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_integral_manager</span><span class="p">(</span><span class="n">active_orbitals</span><span class="o">=</span><span class="n">active_orbitals</span><span class="p">,</span>
                                                                     <span class="n">reference_orbitals</span><span class="o">=</span><span class="n">reference_orbitals</span><span class="p">,</span>
                                                                     <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">frozen_orbitals</span><span class="o">=</span><span class="n">frozen_orbitals</span><span class="p">,</span> <span class="n">orbital_type</span><span class="o">=</span><span class="n">orbital_type</span><span class="p">,</span> <span class="n">basis_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">basis_set</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">orbital_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbital_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;native&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">transform_to_native_orbitals</span><span class="p">()</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_transformation</span><span class="p">(</span><span class="n">transformation</span><span class="o">=</span><span class="n">transformation</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="QuantumChemistryBase.from_tequila">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.from_tequila">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_tequila</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">constant_term</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">one_body_integrals</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">two_body_integrals</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">overlap_integrals</span>
        <span class="k">if</span> <span class="s2">&quot;active_orbitals&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">active_orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">idx_total</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_orbitals</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active_orbitals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;active_orbitals&quot;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;active_orbitals&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">transformation</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">parameters</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nuclear_repulsion</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                   <span class="n">one_body_integrals</span><span class="o">=</span><span class="n">h1</span><span class="p">,</span>
                   <span class="n">two_body_integrals</span><span class="o">=</span><span class="n">h2</span><span class="p">,</span>
                   <span class="n">overlap_integrals</span> <span class="o">=</span> <span class="n">S</span><span class="p">,</span>
                   <span class="n">orbital_coefficients</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">orbital_coefficients</span><span class="p">,</span>
                   <span class="n">active_orbitals</span><span class="o">=</span> <span class="n">active_orbitals</span><span class="p">,</span>
                   <span class="n">transformation</span><span class="o">=</span><span class="n">transformation</span><span class="p">,</span>
                   <span class="n">orbital_type</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">_orbital_type</span><span class="p">,</span>
                   <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
                   <span class="n">reference_orbitals</span><span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_space</span><span class="o">.</span><span class="n">reference_orbitals</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.supports_ucc">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.supports_ucc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">supports_ucc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check if the current molecule supports UCC operations</span>
<span class="sd">        (e.g. mol.make_excitation_gate)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">supports_ucc</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper Function to initialize the Fermion-to-Qubit Transformation</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transformation: name of the transformation (passed down from __init__</span>
<span class="sd">        args</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">transformation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="s2">&quot;JordanWigner&quot;</span>

        <span class="c1"># filter out arguments to the transformation</span>
        <span class="n">trafo_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                      <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;transformation__&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">())}</span>

        <span class="n">trafo_args</span><span class="p">[</span><span class="s2">&quot;n_electrons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span>
        <span class="n">trafo_args</span><span class="p">[</span><span class="s2">&quot;n_orbitals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">):</span>
            <span class="c1"># format to conventions</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">transformation</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">encodings</span> <span class="o">=</span> <span class="n">known_encodings</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">transformation</span> <span class="ow">in</span> <span class="n">encodings</span><span class="p">:</span>
                <span class="n">transformation</span> <span class="o">=</span> <span class="n">encodings</span><span class="p">[</span><span class="n">transformation</span><span class="p">](</span><span class="o">**</span><span class="n">trafo_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                    <span class="s2">&quot;Unkown Fermion-to-Qubit encoding </span><span class="si">{}</span><span class="s2">. Try something like: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transformation</span><span class="p">,</span>
                                                                                         <span class="nb">list</span><span class="p">(</span><span class="n">encodings</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

        <span class="k">return</span> <span class="n">transformation</span>

<div class="viewcode-block" id="QuantumChemistryBase.from_openfermion">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.from_openfermion">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_openfermion</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">MolecularData</span><span class="p">,</span>
                         <span class="n">transformation</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize direclty from openfermion MolecularData object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The openfermion molecule</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The Tequila molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">ParametersQC</span><span class="p">(</span><span class="n">basis_set</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">basis</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                                  <span class="n">description</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">description</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">,</span>
                                  <span class="n">charge</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="n">transformation</span><span class="p">,</span> <span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_excitation_generator">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_excitation_generator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_excitation_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">indices</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
                                  <span class="n">form</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">remove_constant_term</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QubitHamiltonian</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notes</span>
<span class="sd">        ----------</span>
<span class="sd">        Creates the transformed hermitian generator of UCC type unitaries:</span>
<span class="sd">              M(a^\dagger_{a_0} a_{i_0} a^\dagger{a_1}a_{i_1} ... - h.c.)</span>
<span class="sd">              where the qubit map M depends is self.transformation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : typing.Iterable[typing.Tuple[int, int]] :</span>
<span class="sd">            List of tuples [(a_0, i_0), (a_1, i_1), ... ] - recommended format, in spin-orbital notation (alpha odd numbers, beta even numbers)</span>
<span class="sd">            can also be given as one big list: [a_0, i_0, a_1, i_1 ...]</span>
<span class="sd">        form : str : (Default value None):</span>
<span class="sd">            Manipulate the generator to involution or projector</span>
<span class="sd">            set form=&#39;involution&#39; or &#39;projector&#39;</span>
<span class="sd">            the default is no manipulation which gives the standard fermionic excitation operator back</span>
<span class="sd">        remove_constant_term: bool: (Default value True):</span>
<span class="sd">            by default the constant term in the qubit operator is removed since it has no effect on the unitary it generates</span>
<span class="sd">            if the unitary is controlled this might not be true!</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            1j*Transformed qubit excitation operator, depends on self.transformation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_ucc</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Molecule with transformation </span><span class="si">{}</span><span class="s2"> does not support general UCC operations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">))</span>

        <span class="c1"># check indices and convert to list of tuples if necessary</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;make_excitation_operator: no indices given&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;make_excitation_generator: unexpected input format of indices</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;use list of tuples as [(a_0, i_0),(a_1, i_1) ...]</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;or list as [a_0, i_0, a_1, i_1, ... ]</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;you gave: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="p">[(</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="c1"># convert everything to native python int</span>
        <span class="c1"># otherwise openfermion will complain</span>
        <span class="n">converted</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">converted</span><span class="p">]</span>

        <span class="c1"># convert to openfermion input format</span>
        <span class="n">ofi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">converted</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ofi</span> <span class="o">+=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)]</span>  <span class="c1"># openfermion does not take other types of integers like numpy.int64</span>
            <span class="n">dag</span> <span class="o">+=</span> <span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ofi</span><span class="p">),</span> <span class="mf">1.</span><span class="n">j</span><span class="p">)</span>  <span class="c1"># 1j makes it hermitian</span>
        <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">dag</span><span class="p">)),</span> <span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">form</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;fermionic&#39;</span><span class="p">:</span>
            <span class="c1"># indices for all the Na operators</span>
            <span class="n">Na</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">converted</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)]]</span>
            <span class="c1"># indices for all the Ma operators (Ma = 1 - Na)</span>
            <span class="n">Ma</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">converted</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]]</span>
            <span class="c1"># indices for all the Ni operators</span>
            <span class="n">Ni</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">converted</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)]]</span>
            <span class="c1"># indices for all the Mi operators</span>
            <span class="n">Mi</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">converted</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]]</span>

            <span class="c1"># can gaussianize as projector or as involution (last is default)</span>
            <span class="k">if</span> <span class="n">form</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;p+&quot;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">*=</span> <span class="mf">0.5</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Na</span> <span class="o">+</span> <span class="n">Mi</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Ni</span> <span class="o">+</span> <span class="n">Ma</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">form</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;p-&quot;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">*=</span> <span class="mf">0.5</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Na</span> <span class="o">+</span> <span class="n">Mi</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Ni</span> <span class="o">+</span> <span class="n">Ma</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">form</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;g+&quot;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">([],</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Just for clarity will be subtracted anyway</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Na</span> <span class="o">+</span> <span class="n">Mi</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Ni</span> <span class="o">+</span> <span class="n">Ma</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">form</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;g-&quot;</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">([],</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Just for clarity will be subtracted anyway</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Na</span> <span class="o">+</span> <span class="n">Mi</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Ni</span> <span class="o">+</span> <span class="n">Ma</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">form</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;p0&quot;</span><span class="p">:</span>
                <span class="c1"># P0: we only construct P0 and don&#39;t keep the original generator</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">([],</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Just for clarity will be subtracted anyway</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Na</span> <span class="o">+</span> <span class="n">Mi</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="n">op</span> <span class="o">+=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">Ni</span> <span class="o">+</span> <span class="n">Ma</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                    <span class="s2">&quot;Unknown generator form </span><span class="si">{}</span><span class="s2">, supported are G, P+, P-, G+, G- and P0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">form</span><span class="p">))</span>

        <span class="n">qop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

        <span class="c1"># remove constant terms</span>
        <span class="c1"># they have no effect in the unitary (if not controlled)</span>
        <span class="k">if</span> <span class="n">remove_constant_term</span><span class="p">:</span>
            <span class="n">qop</span><span class="o">.</span><span class="n">qubit_operator</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="nb">tuple</span><span class="p">()]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># check if the operator is hermitian and cast coefficients to floats</span>
        <span class="c1"># in order to avoid trouble with the simulation backends</span>
        <span class="k">assert</span> <span class="n">qop</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qop</span><span class="o">.</span><span class="n">qubit_operator</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">qop</span><span class="o">.</span><span class="n">qubit_operator</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">qop</span> <span class="o">=</span> <span class="n">qop</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Excitation generator is a unit operator.</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="s2">&quot;Non-standard transformations might not work with general fermionic operators</span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="s2">&quot;indices = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">category</span><span class="o">=</span><span class="n">TequilaWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qop</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_hardcore_boson_excitation_gate">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_hardcore_boson_excitation_gate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_hardcore_boson_excitation_gate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">compile_options</span><span class="o">=</span><span class="s2">&quot;optimize&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make excitation generator in the hardcore-boson approximation (all electrons are forced to spin-pairs)</span>
<span class="sd">        use only in combination with make_hardcore_boson_hamiltonian()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices</span>
<span class="sd">        angle</span>
<span class="sd">        control</span>
<span class="sd">        assume_real</span>
<span class="sd">        compile_options</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="n">target</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up_then_down</span><span class="p">:</span>
            <span class="n">consistency</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">target</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">consistency</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">target</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">consistency</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;make_hardcore_boson_excitation_gate: Inconsistencies in indices=</span><span class="si">{}</span><span class="s2"> for encoding: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">gates</span><span class="o">.</span><span class="n">QubitExcitation</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="n">control</span><span class="p">,</span>
                                     <span class="n">compile_options</span><span class="o">=</span><span class="n">compile_options</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="QuantumChemistryBase.UR">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.UR">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">UR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for orbital rotation circuit (rotating spatial orbital i and j) with standard naming of variables</span>
<span class="sd">        See arXiv:2207.12421 Eq.6 for UR(0,1)</span>
<span class="sd">        Parameters:</span>
<span class="sd">        ----------</span>
<span class="sd">            indices:</span>
<span class="sd">                tuple of two spatial(!) orbital indices</span>
<span class="sd">            angle:</span>
<span class="sd">                Numeric or hashable type or tequila objective. Default is None and results</span>
<span class="sd">                in automatic naming as (&quot;R&quot;,i,j)</span>
<span class="sd">            label:</span>
<span class="sd">                can be passed instead of angle to have auto-naming with label (&quot;R&quot;,i,j,label)</span>
<span class="sd">                useful for repreating gates with individual variables</span>
<span class="sd">            control:</span>
<span class="sd">                List of possible control qubits</span>
<span class="sd">            assume_real:</span>
<span class="sd">                Assume that the wavefunction will always stay real.</span>
<span class="sd">                Will reduce potential gradient costs by a factor of 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_excitation_indices</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">label</span><span class="p">))</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
            
        <span class="n">circuit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">)],</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="n">control</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">circuit</span><span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="n">control</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">circuit</span></div>

    
<div class="viewcode-block" id="QuantumChemistryBase.UC">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.UC">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">UC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for orbital correlator circuit (correlating spatial orbital i and j through a spin-paired double excitation) with standard naming of variables</span>
<span class="sd">        See arXiv:2207.12421 Eq.22 for UC(1,2)</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">        ----------</span>
<span class="sd">            indices:</span>
<span class="sd">                tuple of two spatial(!) orbital indices</span>
<span class="sd">            angle:</span>
<span class="sd">                Numeric or hashable type or tequila objective. Default is None and results</span>
<span class="sd">                in automatic naming as (&quot;R&quot;,i,j)</span>
<span class="sd">            label:</span>
<span class="sd">                can be passed instead of angle to have auto-naming with label (&quot;R&quot;,i,j,label)</span>
<span class="sd">                useful for repreating gates with individual variables</span>
<span class="sd">            control:</span>
<span class="sd">                List of possible control qubits</span>
<span class="sd">            assume_real:</span>
<span class="sd">                Assume that the wavefunction will always stay real.</span>
<span class="sd">                Will reduce potential gradient costs by a factor of 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_excitation_indices</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">label</span><span class="p">))</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="s2">&quot;jordanwigner&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up_then_down</span><span class="p">:</span>
            <span class="c1"># for JW we can use the optimized form shown in arXiv:2207.12421 Eq.22</span>
            <span class="k">return</span> <span class="n">gates</span><span class="o">.</span><span class="n">QubitExcitation</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="n">control</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="p">),(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="n">control</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_orbital_rotation_gate">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_orbital_rotation_gate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_orbital_rotation_gate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span><span class="nb">tuple</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># backward compatibility</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">UR</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="QuantumChemistryBase.make_excitation_gate">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_excitation_gate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_excitation_gate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a fermionic excitation gate defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            e^{-i\\frac{a}{2} G}</span>
<span class="sd">        with generator defines by the indices [(p0,q0),(p1,q1),...]</span>
<span class="sd">        .. math::</span>
<span class="sd">            G = i(\\prod_{k} a_{p_k}^\\dagger a_{q_k} - h.c.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            indices:</span>
<span class="sd">                List of tuples that define the generator</span>
<span class="sd">            angle:</span>
<span class="sd">                Numeric or hashable type or tequila objective</span>
<span class="sd">            control:</span>
<span class="sd">                List of possible control qubits</span>
<span class="sd">            assume_real:</span>
<span class="sd">                Assume that the wavefunction will always stay real.</span>
<span class="sd">                Will reduce potential gradient costs by a factor of 2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_ucc</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Molecule with transformation </span><span class="si">{}</span><span class="s2"> does not support general UCC operations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">))</span>

        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_generator</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">remove_constant_term</span><span class="o">=</span><span class="n">control</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_generator</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s2">&quot;P0&quot;</span><span class="p">,</span> <span class="n">remove_constant_term</span><span class="o">=</span><span class="n">control</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up_then_down</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">,</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span><span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">return</span> <span class="n">QCircuit</span><span class="o">.</span><span class="n">wrap_gate</span><span class="p">(</span>
            <span class="n">FermionicGateImpl</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span>
                              <span class="n">transformation</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">indices</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                              <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span>
                              <span class="n">control</span><span class="o">=</span><span class="n">control</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_molecule">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_molecule">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MolecularData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a molecule in openfermion format by running psi4 and extracting the data</span>
<span class="sd">        Will check for previous outputfiles before running</span>
<span class="sd">        Will not recompute if a file was found</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameters :</span>
<span class="sd">            An instance of ParametersQC, which also holds an instance of ParametersPsi4 via parameters.psi4</span>
<span class="sd">            The molecule will be saved in parameters.filename, if this file exists before the call the molecule will be imported from the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            the molecule in openfermion.MolecularData format</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">molecular_data_param</span><span class="p">)</span>

        <span class="n">do_compute</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># try:</span>
        <span class="c1">#     import os</span>
        <span class="c1">#     if os.path.exists(self.parameters.filename):</span>
        <span class="c1">#         molecule.load()</span>
        <span class="c1">#         do_compute = False</span>
        <span class="c1"># except OSError:</span>
        <span class="c1">#     do_compute = True</span>

        <span class="k">if</span> <span class="n">do_compute</span><span class="p">:</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_make_molecule</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1">#molecule.save()</span>
        <span class="k">return</span> <span class="n">molecule</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.initialize_integral_manager">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.initialize_integral_manager">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_integral_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by self.__init__() with args and kwargs passed through</span>
<span class="sd">        Override this in derived class such that it returns an intitialized instance of the integral manager</span>

<span class="sd">        In the BaseClass it is required to pass the following with kwargs on init:</span>
<span class="sd">        - one_body_integrals as matrix</span>
<span class="sd">        - two_body_integrals as NBTensor of numpy.ndarray (four indices, openfermion ordering)</span>
<span class="sd">        - nuclear_repulsion (constant part of hamiltonian - optional)</span>

<span class="sd">        Method sets:</span>
<span class="sd">        - result of self.get_integrals()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_electrons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">n_electrons</span>
        <span class="k">if</span> <span class="s2">&quot;n_electrons&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">n_electrons</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_electrons&quot;</span><span class="p">]</span>

        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;one_body_integrals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="s2">&quot;two_body_integrals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">one_body_integrals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;one_body_integrals&quot;</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;one_body_integrals&quot;</span><span class="p">)</span>
        <span class="n">two_body_integrals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;two_body_integrals&quot;</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;two_body_integrals&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">two_body_integrals</span><span class="p">,</span> <span class="n">NBodyTensor</span><span class="p">):</span>
            <span class="c1"># assuming two_body_integrals are given in openfermion ordering</span>
            <span class="n">ordering</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be auto-detected</span>
            <span class="k">if</span> <span class="s2">&quot;ordering&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">ordering</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ordering&quot;</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ordering&quot;</span><span class="p">)</span>  <span class="c1"># let&#39;s not confuse the IntegralManager</span>
            <span class="n">two_body_integrals</span> <span class="o">=</span> <span class="n">NBodyTensor</span><span class="p">(</span><span class="n">two_body_integrals</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="n">ordering</span><span class="p">)</span>

        <span class="n">two_body_integrals</span> <span class="o">=</span> <span class="n">two_body_integrals</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">to</span><span class="o">=</span><span class="s2">&quot;chem&quot;</span><span class="p">)</span>

        <span class="n">constant_part</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="s2">&quot;constant_term&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">constant_part</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;constant_term&quot;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;constant_term&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;nuclear_repulsion&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">constant_part</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nuclear_repulsion&quot;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nuclear_repulsion&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;active_space&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>

            <span class="n">active_orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">one_body_integrals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">if</span> <span class="s2">&quot;active_orbitals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;active_orbitals&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">active_orbitals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;active_orbitals&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;frozen_orbitals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;frozen_orbitals&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fo</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;frozen_orbitals&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">fo</span> <span class="ow">in</span> <span class="n">active_orbitals</span><span class="p">:</span>
                        <span class="n">active_orbitals</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fo</span><span class="p">)</span>

            <span class="n">reference_orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="s2">&quot;reference_orbitals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;reference_orbitals&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reference_orbitals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;reference_orbitals&quot;</span><span class="p">]</span>

            <span class="n">active_space</span> <span class="o">=</span> <span class="n">ActiveSpaceData</span><span class="p">(</span><span class="n">active_orbitals</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">active_orbitals</span><span class="p">),</span>
                                           <span class="n">reference_orbitals</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">reference_orbitals</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;active_space&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">active_space</span>

        <span class="k">if</span> <span class="s2">&quot;basis_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;basis_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">basis_set</span>

        <span class="n">manager</span> <span class="o">=</span> <span class="n">IntegralManager</span><span class="p">(</span><span class="n">one_body_integrals</span><span class="o">=</span><span class="n">one_body_integrals</span><span class="p">,</span> <span class="n">two_body_integrals</span><span class="o">=</span><span class="n">two_body_integrals</span><span class="p">,</span>
                                  <span class="n">constant_term</span><span class="o">=</span><span class="n">constant_part</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">manager</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.transform_orbitals">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.transform_orbitals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbital_coefficients</span><span class="p">,</span> <span class="n">ignore_active_space</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbital_coefficients: second index is new orbital indes, first is old orbital index (summed over), indices are assumed to be defined on the active space</span>
<span class="sd">        ignore_active_space: if true orbital_coefficients are not assumed to be given in the active space</span>
<span class="sd">        name: str, name the new orbitals</span>
<span class="sd">        args</span>
<span class="sd">        kwargs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        New molecule with transformed orbitals</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">orbital_coefficients</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># mo_coeff by default only acts on the active space</span>
        <span class="n">active_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">idx_total</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_orbitals</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ignore_active_space</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">orbital_coefficients</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kk</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active_indices</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ll</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active_indices</span><span class="p">):</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">orbital_coefficients</span><span class="p">[</span><span class="n">kk</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span>

        <span class="c1"># can not be an instance of a specific backend (otherwise we get inconsistencies with classical methods in the backend)</span>
        <span class="n">integral_manager</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="p">)</span>
        <span class="n">integral_manager</span><span class="o">.</span><span class="n">transform_orbitals</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">QuantumChemistryBase</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">integral_manager</span><span class="o">=</span><span class="n">integral_manager</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    
<div class="viewcode-block" id="QuantumChemistryBase.orthonormalize_basis_orbitals">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.orthonormalize_basis_orbitals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">orthonormalize_basis_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># backward compatibility</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_native_orbitals</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="QuantumChemistryBase.use_native_orbitals">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.use_native_orbitals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">use_native_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        New molecule in the native (orthonormalized) basis given</span>
<span class="sd">        e.g. for standard basis sets the orbitals are orthonormalized Gaussian Basis Functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_space_is_trivial</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;orthonormalize_basis_orbitals: active space is set and might lead to inconsistent behaviour&quot;</span><span class="p">,</span> <span class="n">TequilaWarning</span><span class="p">)</span>

        <span class="c1"># can not be an instance of a specific backend (otherwise we get inconsistencies with classical methods in the backend)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">transform_to_native_orbitals</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">integral_manager</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="p">)</span>
            <span class="n">integral_manager</span><span class="o">.</span><span class="n">transform_to_native_orbitals</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">QuantumChemistryBase</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">integral_manager</span><span class="o">=</span><span class="n">integral_manager</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="QuantumChemistryBase.do_make_molecule">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.do_make_molecule">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_make_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by self.make_molecule with args and kwargs passed through</span>
<span class="sd">        Override this in derived class if needed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;integral_manager&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">constant_term</span><span class="p">,</span> <span class="n">one_body_integrals</span><span class="p">,</span> <span class="n">two_body_integrals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">(</span><span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;of&quot;</span><span class="p">)</span>
        <span class="n">two_body_integrals</span> <span class="o">=</span> <span class="n">two_body_integrals</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">to</span><span class="o">=</span><span class="s2">&quot;of&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;n_orbitals&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">n_orbitals</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_orbitals&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_orbitals</span> <span class="o">=</span> <span class="n">one_body_integrals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="n">n_orbitals</span> <span class="o">==</span> <span class="n">two_body_integrals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">molecule</span> <span class="o">=</span> <span class="n">MolecularData</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">molecular_data_param</span><span class="p">)</span>

        <span class="n">molecule</span><span class="o">.</span><span class="n">one_body_integrals</span> <span class="o">=</span> <span class="n">one_body_integrals</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">two_body_integrals</span> <span class="o">=</span> <span class="n">two_body_integrals</span><span class="o">.</span><span class="n">elems</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">nuclear_repulsion</span> <span class="o">=</span> <span class="n">constant_term</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">=</span> <span class="n">n_orbitals</span>
        <span class="k">if</span> <span class="s2">&quot;n_electrons&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_electrons&quot;</span><span class="p">]</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">molecule</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_orbitals</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reference_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_reference_orbitals</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The number of active orbitals in this Molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_orbitals</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">active_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_space</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_electrons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The number of active electrons in this molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">active_reference_orbitals</span><span class="p">)</span>

<div class="viewcode-block" id="QuantumChemistryBase.make_annihilation_op">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_annihilation_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_annihilation_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbital</span><span class="p">,</span> <span class="n">coefficient</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute annihilation operator on spin-orbital in qubit representation</span>
<span class="sd">        Spin-orbital order is always (up,down,up,down,...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">orbital</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">aop</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">orbital</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">aop</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_creation_op">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_creation_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_creation_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbital</span><span class="p">,</span> <span class="n">coefficient</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute creation operator on spin-orbital in qubit representation</span>
<span class="sd">        Spin-orbital order is always (up,down,up,down,...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">orbital</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">cop</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">orbital</span><span class="si">}</span><span class="s1">^&#39;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">cop</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_number_op">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_number_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_number_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbital</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute number operator on spin-orbital in qubit representation</span>
<span class="sd">        Spin-orbital order is always (up,down,up,down,...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_creation_op</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_annihilation_op</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num_op</span></div>

    
<div class="viewcode-block" id="QuantumChemistryBase.make_sz_op">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_sz_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_sz_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the spin_z operator of the molecule in qubit representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">QubitHamiltonian</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">one</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_creation_op</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_annihilation_op</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">two</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_creation_op</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_annihilation_op</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sz</span> <span class="o">+=</span> <span class="p">(</span><span class="n">one</span> <span class="o">-</span> <span class="n">two</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sz</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_sp_op">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_sp_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_sp_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the spin+ operator of the molecule in qubit representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">QubitHamiltonian</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">):</span>
            <span class="n">sp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_creation_op</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_annihilation_op</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sp</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_sm_op">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_sm_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_sm_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the spin- operator of the molecule in qubit representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="n">QubitHamiltonian</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">):</span>
            <span class="n">sm</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_creation_op</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_annihilation_op</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sm</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_s2_op">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_s2_op">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_s2_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the spin^2 operator of the molecule in qubit representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s2_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sm_op</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sp_op</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_sz_op</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_sz_op</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s2_op</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_hamiltonian">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QubitHamiltonian</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        occupied_indices: will be auto-assigned according to specified active space. Can be overridden by passing specific lists (same as in open fermion)</span>
<span class="sd">        active_indices: will be auto-assigned according to specified active space. Can be overridden by passing specific lists (same as in open fermion)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Qubit Hamiltonian in the Fermion-to-Qubit transformation defined in self.parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># warnings for backward comp</span>
        <span class="k">if</span> <span class="s2">&quot;active_indices&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;active space can&#39;t be changed in molecule. Will ignore active_orbitals passed to make_hamiltonian&quot;</span><span class="p">)</span>

        <span class="n">of_molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_molecule</span><span class="p">()</span>
        <span class="n">fop</span> <span class="o">=</span> <span class="n">of_molecule</span><span class="o">.</span><span class="n">get_molecular_hamiltonian</span><span class="p">()</span>
        <span class="n">fop</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">get_fermion_operator</span><span class="p">(</span><span class="n">fop</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">qop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">fop</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">qop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">openfermion</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">get_interaction_operator</span><span class="p">(</span><span class="n">fop</span><span class="p">))</span>
        <span class="n">qop</span><span class="o">.</span><span class="n">is_hermitian</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">qop</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_hardcore_boson_hamiltonian">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_hardcore_boson_hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_hardcore_boson_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condensed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hamiltonian in Hardcore-Boson approximation (electrons are forced into spin-pairs)</span>
<span class="sd">        Indepdent of Fermion-to-Qubit mapping</span>
<span class="sd">        condensed: always give Hamiltonian back from qubit 0 to N where N is the number of orbitals</span>
<span class="sd">        if condensed=False then JordanWigner would give back the Hamiltonian defined on even qubits between 0 to 2N</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># integrate with QubitEncoding at some point</span>
        <span class="n">n_orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">obt</span><span class="p">,</span> <span class="n">tbt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">()</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">n_orbitals</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">n_orbitals</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orbitals</span><span class="p">):</span>
            <span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">obt</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orbitals</span><span class="p">):</span>
                <span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="o">+</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">q</span><span class="p">:</span>
                    <span class="n">g</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">-</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orbitals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orbitals</span><span class="p">):</span>
                <span class="n">up</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">uq</span> <span class="o">=</span> <span class="n">q</span>
                <span class="n">H</span> <span class="o">+=</span> <span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">up</span><span class="p">)</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">uq</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">up</span><span class="p">)</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">up</span><span class="p">)</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">uq</span><span class="p">)</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">uq</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up_then_down</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">condensed</span><span class="p">:</span>
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">idx</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span><span class="p">}</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">map_qubits</span><span class="p">(</span><span class="n">alpha_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_molecular_hamiltonian">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_molecular_hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_molecular_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">occupied_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Create a MolecularHamiltonian as openfermion Class</span>
<span class="sd">        (used internally here, not used in tequila)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_molecule</span><span class="p">()</span><span class="o">.</span><span class="n">get_molecular_hamiltonian</span><span class="p">(</span><span class="n">occupied_indices</span><span class="o">=</span><span class="n">occupied_indices</span><span class="p">,</span> <span class="n">active_indices</span><span class="o">=</span><span class="n">active_indices</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.get_integrals">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.get_integrals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>

<span class="sd">        options for kwargs: &quot;ordering = [&quot;openfermion&quot;, &quot;chem&quot;, &quot;phys&quot;], ignore_active_space = [True, False]&quot;</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple with:</span>
<span class="sd">        constant part (nuclear_repulsion + possible integrated parts from active-spaces)</span>
<span class="sd">        one_body_integrals</span>
<span class="sd">        two_body_integrals</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># backward compatibility</span>
        <span class="k">if</span> <span class="s2">&quot;two_body_ordering&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;ordering&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;two_body_ordering&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_one_body_integrals">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_one_body_integrals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_one_body_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; convenience function &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">h1</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_two_body_integrals">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_two_body_integrals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_two_body_integrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;openfermion&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">(</span><span class="n">ordering</span><span class="o">=</span><span class="n">ordering</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h2</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_constant_part">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_constant_part">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_constant_part</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_ccsd_amplitudes">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_ccsd_amplitudes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_ccsd_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClosedShellAmplitudes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;BaseClass Method&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_reference_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        used internally</span>
<span class="sd">        gives back reference state occupation vector (in second quantization or JW notation)</span>
<span class="sd">        transformation to current encoding is done in def prepare_reference</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">state</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="o">.</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">state</span>

<div class="viewcode-block" id="QuantumChemistryBase.prepare_reference">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.prepare_reference">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A tequila circuit object which prepares the reference of this molecule in the chosen transformation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reference_state</span><span class="p">()</span>

        <span class="n">reference_state</span> <span class="o">=</span> <span class="n">BitString</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">map_state</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">))</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">prepare_product_state</span><span class="p">(</span><span class="n">reference_state</span><span class="p">)</span>
        <span class="c1"># prevent trace out in direct wfn simulation</span>
        <span class="n">U</span><span class="o">.</span><span class="n">n_qubits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># adapt when tapered transformations work</span>
        <span class="k">return</span> <span class="n">U</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.prepare_hardcore_boson_reference">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.prepare_hardcore_boson_reference">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepare_hardcore_boson_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare reference state in the Hardcore-Boson approximation (eqch qubit represents two spin-paired electrons)</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tq.QCircuit that prepares the HCB reference</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">gates</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span><span class="p">])</span>
        <span class="n">U</span><span class="o">.</span><span class="n">n_qubits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>
        <span class="k">return</span> <span class="n">U</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.hcb_to_me">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.hcb_to_me">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hcb_to_me</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">condensed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a circuit in the hardcore-boson encoding (HCB)</span>
<span class="sd">        to the encoding of this molecule</span>
<span class="sd">        HCB is supposed to be encoded on the first n_orbitals qubits</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        U: HCB circuit (using the alpha qubits)</span>
<span class="sd">        condensed: assume that incoming U is condensed (HCB on the first n_orbitals; and not, as for example in JW on the first n even orbitals)</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ups</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span><span class="p">]</span>
            <span class="n">consistency</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="ow">in</span> <span class="n">ups</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">U</span><span class="o">.</span><span class="n">qubits</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">consistency</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;hcb_to_me: given circuit is not defined on all first </span><span class="si">{}</span><span class="s2"> qubits. Is this a HCB circuit?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">))</span>

        <span class="c1"># map to alpha qubits</span>
        <span class="k">if</span> <span class="n">condensed</span><span class="p">:</span>
            <span class="n">alpha_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)}</span>
            <span class="n">alpha_U</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">map_qubits</span><span class="p">(</span><span class="n">qubit_map</span><span class="o">=</span><span class="n">alpha_map</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha_U</span> <span class="o">=</span> <span class="n">U</span>

        <span class="n">UX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">hcb_to_me</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">UX</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;transformation=</span><span class="si">{}</span><span class="s2"> has no hcb_to_me function implemented&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">alpha_U</span> <span class="o">+</span> <span class="n">UX</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.get_pair_specific_indices">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.get_pair_specific_indices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pair_specific_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">pair_info</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">include_singles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">general_excitations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assuming a pair-specific model, create a pair-specific index list</span>
<span class="sd">        to be used in make_upccgsd_ansatz(indices = ... )</span>
<span class="sd">        Excite from a set of references (i) to any pair coming from (i),</span>
<span class="sd">        i.e. any (i,j)/(j,i). If general excitations are allowed, also</span>
<span class="sd">        allow excitations from pairs to appendant pairs and reference.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pair_info</span>
<span class="sd">            file or list including information about pair structure</span>
<span class="sd">            references single number, pair double</span>
<span class="sd">            example: as file: &quot;0,1,11,11,00,10&quot; (hand over file name)</span>
<span class="sd">                     in file, skip first row assuming some text with information</span>
<span class="sd">                     as list:[&#39;0&#39;,&#39;1`&#39;,&#39;11&#39;,&#39;11&#39;,&#39;00&#39;,&#39;10&#39;]</span>
<span class="sd">                     ~&gt; two reference orbitals 0 and 1,</span>
<span class="sd">                     then two orbitals from pair 11, one from 00, one mixed 10</span>
<span class="sd">        include_singles</span>
<span class="sd">            include single excitations</span>
<span class="sd">        general_excitations</span>
<span class="sd">            allow general excitations</span>
<span class="sd">       Returns</span>
<span class="sd">        -------</span>
<span class="sd">            list of indices with pair-specific ansatz</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">pair_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Need to provide some pair information.&quot;</span><span class="p">)</span>
        <span class="c1"># If pair-information given on file, load (layout see above)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pair_info</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">pair_info</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pair_info</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">pair_info</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pair_info</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Pair information needs to be contained in a list or filename.&quot;</span><span class="p">)</span>

        <span class="n">connect</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="c1"># determine &quot;connectivity&quot;</span>
        <span class="n">generalized</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">connect</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">))</span>
                                <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">]))]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">general_excitations</span><span class="p">:</span>
                <span class="n">connect</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">))</span>
                                <span class="k">if</span> <span class="p">(((</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)</span>
                                    <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">idx</span><span class="p">))]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Invalid reference of pair id.&quot;</span><span class="p">)</span>

        <span class="c1"># create generating indices from connectivity</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">to</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connect</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">to</span><span class="p">:</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">include_singles</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)))</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.format_excitation_indices">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.format_excitation_indices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_excitation_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Consistent formatting of excitation indices</span>
<span class="sd">        idx = [(p0,q0),(p1,q1),...,(pn,qn)]</span>
<span class="sd">        sorted as: p0&lt;p1&lt;pn and pi&lt;qi</span>
<span class="sd">        :param idx: list of index tuples describing a single(!) fermionic excitation</span>
<span class="sd">        :return: tuple-list of index tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_upccgsd_indices">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_upccgsd_indices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_upccgsd_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">reference_orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">reference_orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">idx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># add doubles in hcb encoding</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ladder&quot;</span><span class="p">:</span>
            <span class="c1"># ladder structure of the pair excitations</span>
            <span class="c1"># ensures local connectivity</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;g&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">reference_orbitals</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)</span> <span class="k">if</span>
                       <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference_orbitals</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;g&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Unknown recipe: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format_excitation_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_hardcore_boson_upccgd_layer">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_hardcore_boson_upccgd_layer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_hardcore_boson_upccgd_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="s2">&quot;UpCCGD&quot;</span><span class="p">,</span>
                                         <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                         <span class="n">assume_real</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_indices</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="n">UD</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">UD</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_hardcore_boson_excitation_gate</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">),</span>
                                                           <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UD</span></div>

    
<div class="viewcode-block" id="QuantumChemistryBase.make_spa_ansatz">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_spa_ansatz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_spa_ansatz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">hcb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="n">use_units_of_pi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ladder</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Separable Pair Ansatz (SPA) for general molecules</span>
<span class="sd">        see arxiv: </span>
<span class="sd">        edges: a list of tuples that contain the orbital indices for the specific pairs</span>
<span class="sd">               one example: edges=[(0,), (1,2,3), (4,5)] are three pairs, one with a single orbital [0], one with three orbitals [1,2,3] and one with two orbitals [4,5]</span>
<span class="sd">        hcb: spa ansatz in the hcb (hardcore-boson) space without transforming to current transformation (e.g. JordanWigner), use this for example in combination with the self.make_hardcore_boson_hamiltonian() and see the article above for more info</span>
<span class="sd">        use_units_of_pi: circuit angles in units of pi</span>
<span class="sd">        label: label the variables in the circuit</span>
<span class="sd">        optimize: optimize the circuit construction (see article). Results in shallow circuit from Ry and CNOT gates</span>
<span class="sd">        ladder: if true the excitation pattern will be local. E.g. in the pair from orbitals (1,2,3) we will have the excitations 1-&gt;2 and 2-&gt;3, if set to false we will have standard coupled-cluster style excitations - in this case this would be 1-&gt;2 and 1-&gt;3 </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;SPA ansatz within a standard orbital basis needs edges. Please provide with the keyword edges.</span><span class="se">\n</span><span class="s2">Example: edges=[(0,1,2),(3,4)] would correspond to two edges created from orbitals (0,1,2) and (3,4), note that orbitals can only be assigned to a single edge&quot;</span><span class="p">)</span>
        
        <span class="c1"># sanity checks</span>
        <span class="c1"># current SPA implementation needs even number of electrons</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;need even number of electrons for SPA ansatz.</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> active electrons&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">))</span>
        <span class="c1"># making sure that enough edges are assigned</span>
        <span class="n">n_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;number of edges need to be equal to number of active electrons//2</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> edges given</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> active electrons</span><span class="se">\n</span><span class="s2">frozen core is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">frozen_core</span><span class="p">))</span>
        <span class="c1"># making sure that orbitals are uniquely assigned to edges</span>
        <span class="k">for</span> <span class="n">edge_qubits</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">q1</span> <span class="ow">in</span> <span class="n">edge_qubits</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">edge2</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">edge2</span><span class="o">==</span><span class="n">edge_qubits</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">q1</span> <span class="ow">in</span> <span class="n">edge2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;make_spa_ansatz: faulty list of edges, orbitals are overlapping e.g. orbital </span><span class="si">{}</span><span class="s2"> is in edge </span><span class="si">{}</span><span class="s2"> and edge </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">edge_qubits</span><span class="p">,</span> <span class="n">edge2</span><span class="p">))</span>
        
        <span class="c1"># auto assign if the circuit construction is optimized</span>
        <span class="c1"># depending on the current qubit encoding (if hcb_to_me is implemnented we can optimize)</span>
        <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">have_hcb_to_me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hcb_to_me</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">have_hcb_to_me</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">have_hcb_to_me</span><span class="p">:</span> 
                <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optimize</span><span class="o">=</span><span class="kc">False</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        
        <span class="c1"># construction of the optimized circuit</span>
        <span class="k">if</span> <span class="n">optimize</span><span class="p">:</span>
            <span class="c1"># circuit in HCB representation</span>
            <span class="c1"># depends a bit on the ordering of the spin-orbitals in the encoding</span>
            <span class="c1"># here we transform it to the qubits representing the up-spins</span>
            <span class="c1"># the hcb_to_me sequence will then transfer to the actual encoding later</span>
            <span class="k">for</span> <span class="n">edge_orbitals</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">edge_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge_orbitals</span><span class="p">]</span>
                <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">edge_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_qubits</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_qubits</span><span class="p">)):</span>
                    <span class="n">q1</span><span class="o">=</span><span class="n">edge_qubits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">edge_qubits</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ladder</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">=</span><span class="n">edge_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">angle</span><span class="o">=</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="p">((</span><span class="n">edge_orbitals</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge_orbitals</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&quot;D&quot;</span> <span class="p">,</span><span class="n">label</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">use_units_of_pi</span><span class="p">:</span>
                        <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">q1</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">q1</span><span class="p">,</span> <span class="n">control</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>


            <span class="k">if</span> <span class="ow">not</span> <span class="n">hcb</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hcb_to_me</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># construction of the non-optimized circuit (UpCCD with paired doubles according to edges)</span>
            <span class="k">if</span> <span class="n">hcb</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_hardcore_boson_reference</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_reference</span><span class="p">()</span>
            <span class="c1"># will only work if the first orbitals in the edges are the reference orbitals</span>
            <span class="n">sane</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">reference_orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span>
            <span class="k">for</span> <span class="n">edge_qubits</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">edge_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reference_orbitals</span><span class="p">:</span>
                    <span class="n">sane</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_qubits</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">q1</span> <span class="ow">in</span> <span class="n">edge_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">reference_orbitals</span><span class="p">:</span>
                            <span class="n">sane</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sane</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Non-Optimized SPA (e.g. with encodings that are not JW) will only work if the first orbitals of all SPA edges are occupied reference orbitals and all others are not. You gave edges=</span><span class="si">{}</span><span class="s2"> and reference_orbitals are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">reference_orbitals</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">edge_qubits</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">previous</span> <span class="o">=</span> <span class="n">edge_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_qubits</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">q1</span> <span class="ow">in</span> <span class="n">edge_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">previous</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ladder</span><span class="p">:</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="n">edge_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="p">((</span><span class="n">c</span><span class="p">,</span><span class="n">q1</span><span class="p">),</span> <span class="s2">&quot;D&quot;</span> <span class="p">,</span><span class="n">label</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">use_units_of_pi</span><span class="p">:</span>
                            <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
                        <span class="k">if</span> <span class="n">hcb</span><span class="p">:</span>
                            <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_hardcore_boson_excitation_gate</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="n">q1</span><span class="p">,</span><span class="n">c</span><span class="p">)],</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">q1</span><span class="p">),(</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">q1</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span>
                        <span class="n">previous</span> <span class="o">=</span> <span class="n">q1</span>
        <span class="k">return</span> <span class="n">U</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_ansatz">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_ansatz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_ansatz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically calls the right subroutines to construct ansatze implemented in tequila.chemistry</span>
<span class="sd">        name: namne of the ansatz, examples are: UpCCGSD, UpCCD, SPA, UCCSD, SPA+UpCCD, SPA+GS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">QCircuit</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;+&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
            <span class="n">subparts</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>
            <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ansatz</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">subparts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># making sure the there are is no undesired behaviour in layers after +</span>
            <span class="c1"># reference should not be included since we are not starting from |00...0&gt; anymore</span>
            <span class="k">if</span> <span class="s2">&quot;include_reference&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;include_reference&quot;</span><span class="p">)</span>
            <span class="c1"># hcb optimization can also not be used (in almost all cases)</span>
            <span class="k">if</span> <span class="s2">&quot;hcb_optimization&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;hcb_optimization&quot;</span><span class="p">)</span>
            <span class="c1"># making sure that we have no repeating variable names</span>
            <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">subpart</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subparts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ansatz</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">subpart</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">i</span><span class="p">),</span> <span class="n">include_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hcb_optimization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">U</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;uccsd&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_uccsd_ansatz</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;spa&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;hcb&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">hcb</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="s2">&quot;hcb&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="n">hcb</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;hcb&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">hcb</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_spa_ansatz</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;d&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_ansatz</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;unknown ansatz with name=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_upccgsd_ansatz">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_upccgsd_ansatz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_upccgsd_ansatz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">include_reference</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;UpCCGSD&quot;</span><span class="p">,</span>
                            <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">assume_real</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">hcb_optimization</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">spin_adapt_singles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">neglect_z</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">mix_sd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        UpGCCSD Ansatz similar as described by Lee et. al.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include_reference</span>
<span class="sd">            include the HF reference state as initial state</span>
<span class="sd">        indices</span>
<span class="sd">            pass custom defined set of indices from which the ansatz will be created</span>
<span class="sd">            List of tuples of tuples spin-indices e.g. [((2*p,2*q),(2*p+1,2*q+1)), ...]</span>
<span class="sd">        label</span>
<span class="sd">            An additional label that is set with the variables</span>
<span class="sd">            default is None and no label will be set: variables names will be</span>
<span class="sd">            (x, (p,q)) for x in range(order)</span>
<span class="sd">            with a label the variables will be named</span>
<span class="sd">            (label, (x, (p,q)))</span>
<span class="sd">        order</span>
<span class="sd">            Order of the ansatz (default is 1)</span>
<span class="sd">            determines how often the ordering gets repeated</span>
<span class="sd">            parameters of repeating layers are independent</span>
<span class="sd">        assume_real</span>
<span class="sd">            assume a real wavefunction (that is always the case if the reference state is real)</span>
<span class="sd">            reduces potential gradient costs from 4 to 2</span>
<span class="sd">        mix_sd</span>
<span class="sd">            Changes the ordering from first all doubles and then all singles excitations (DDDDD....SSSS....) to</span>
<span class="sd">            a mixed order (DS-DS-DS-DS-...) where one DS pair acts on the same MOs. Useful to consider when systems</span>
<span class="sd">            with high electronic correlation and system high error associated with the no Trotterized UCC.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            UpGCCSD ansatz</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;A&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">neglect_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">neglect_z</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neglect_z</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;-&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_indices</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># check if the used qubit encoding has a hcb transformation</span>
        <span class="n">have_hcb_trafo</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">hcb_to_me</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">have_hcb_trafo</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">have_hcb_trafo</span> <span class="o">=</span> <span class="kc">False</span>
        

        <span class="c1"># consistency checks for optimization</span>
        <span class="k">if</span> <span class="n">have_hcb_trafo</span> <span class="ow">and</span> <span class="n">hcb_optimization</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">include_reference</span><span class="p">:</span>
            <span class="n">hcb_optimization</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s2">&quot;HCB&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">hcb_optimization</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">hcb_optimization</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">have_hcb_trafo</span> <span class="ow">and</span> <span class="s2">&quot;HCB&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;use_hcb=</span><span class="si">{}</span><span class="s2"> but transformation=</span><span class="si">{}</span><span class="s2"> has no </span><span class="se">\&#39;</span><span class="s2">hcb_to_me</span><span class="se">\&#39;</span><span class="s2"> function. Try transformation=</span><span class="se">\&#39;</span><span class="s2">ReorderedJordanWigner</span><span class="se">\&#39;</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">hcb_optimization</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="s2">&quot;HCB&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;HCB&quot;</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;name=</span><span class="si">{}</span><span class="s2">, Singles can&#39;t be realized without mapping back to the standard encoding leave S or HCB out of the name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hcb_optimization</span> <span class="ow">and</span> <span class="n">mix_sd</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;Mixed SD can not be employed together with HCB Optimization&quot;</span><span class="p">)</span>
        <span class="c1"># convenience</span>
        <span class="n">S</span> <span class="o">=</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">D</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

        <span class="c1"># first layer</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hcb_optimization</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">include_reference</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_reference</span><span class="p">()</span>
            <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_layer</span><span class="p">(</span><span class="n">include_singles</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">include_doubles</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span>
                                         <span class="n">label</span><span class="o">=</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mix_sd</span><span class="o">=</span><span class="n">mix_sd</span><span class="p">,</span> <span class="n">spin_adapt_singles</span><span class="o">=</span><span class="n">spin_adapt_singles</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">include_reference</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_hardcore_boson_reference</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">D</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_hardcore_boson_upccgd_layer</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                                           <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;HCB&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="p">(</span><span class="n">include_reference</span> <span class="ow">or</span> <span class="n">D</span><span class="p">):</span>
                <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hcb_to_me</span><span class="p">(</span><span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_singles</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                               <span class="n">spin_adapt_singles</span><span class="o">=</span><span class="n">spin_adapt_singles</span><span class="p">,</span> <span class="n">neglect_z</span><span class="o">=</span><span class="n">neglect_z</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
            <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_layer</span><span class="p">(</span><span class="n">include_singles</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">include_doubles</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span>
                                         <span class="n">spin_adapt_singles</span><span class="o">=</span><span class="n">spin_adapt_singles</span><span class="p">,</span> <span class="n">neglect_z</span><span class="o">=</span><span class="n">neglect_z</span><span class="p">,</span> <span class="n">mix_sd</span><span class="o">=</span><span class="n">mix_sd</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">U</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_upccgsd_layer">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_upccgsd_layer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_upccgsd_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">include_singles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">include_doubles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="n">assume_real</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">spin_adapt_singles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">angle_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mix_sd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">neglect_z</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">idx</span><span class="p">]),</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">include_doubles</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;jordanwigner&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up_then_down</span><span class="p">:</span>
                    <span class="c1"># we can optimize with qubit excitations for the JW representation</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">QubitExcitation</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span>
                                                   <span class="n">indices</span><span class="o">=</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                                                   <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">include_singles</span> <span class="ow">and</span> <span class="n">mix_sd</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_singles</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="n">idx</span><span class="p">,)],</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                                               <span class="n">spin_adapt_singles</span><span class="o">=</span><span class="n">spin_adapt_singles</span><span class="p">,</span> <span class="n">angle_transform</span><span class="o">=</span><span class="n">angle_transform</span><span class="p">,</span>
                                               <span class="n">neglect_z</span><span class="o">=</span><span class="n">neglect_z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">include_singles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mix_sd</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_singles</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                                           <span class="n">spin_adapt_singles</span><span class="o">=</span><span class="n">spin_adapt_singles</span><span class="p">,</span> <span class="n">angle_transform</span><span class="o">=</span><span class="n">angle_transform</span><span class="p">,</span>
                                           <span class="n">neglect_z</span><span class="o">=</span><span class="n">neglect_z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">U</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_upccgsd_singles">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_upccgsd_singles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_upccgsd_singles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="s2">&quot;UpCCGSD&quot;</span><span class="p">,</span> <span class="n">spin_adapt_singles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">assume_real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">neglect_z</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">neglect_z</span> <span class="ow">and</span> <span class="s2">&quot;jordanwigner&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;neglegt-z approximation in UpCCGSD singles needs the (Reversed)JordanWigner representation&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_indices</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spin_adapt_singles</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angle_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">angle</span> <span class="o">=</span> <span class="n">angle_transform</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">neglect_z</span><span class="p">:</span>
                    <span class="n">targeta</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">targetb</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">QubitExcitation</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">targeta</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">QubitExcitation</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">targetb</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                                                   <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                                                   <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">angle1</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;SU&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="n">angle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;SD&quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">angle_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">angle1</span> <span class="o">=</span> <span class="n">angle_transform</span><span class="p">(</span><span class="n">angle1</span><span class="p">)</span>
                    <span class="n">angle2</span> <span class="o">=</span> <span class="n">angle_transform</span><span class="p">(</span><span class="n">angle2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">neglect_z</span><span class="p">:</span>
                    <span class="n">targeta</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">targetb</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">QubitExcitation</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle1</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">targeta</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">QubitExcitation</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle2</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">targetb</span><span class="p">,</span> <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle1</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
                                                   <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">U</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">angle</span><span class="o">=</span><span class="n">angle2</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
                                                   <span class="n">assume_real</span><span class="o">=</span><span class="n">assume_real</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">U</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.make_uccsd_ansatz">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.make_uccsd_ansatz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_uccsd_ansatz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trotter_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="n">initial_amplitudes</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Amplitudes</span><span class="p">,</span> <span class="n">ClosedShellAmplitudes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">include_reference_ansatz</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">parametrized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">,</span>
                          <span class="n">add_singles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">screening</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QCircuit</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initial_amplitudes :</span>
<span class="sd">            initial amplitudes given as ManyBodyAmplitudes structure or as string</span>
<span class="sd">            where &#39;mp2&#39;, &#39;cc2&#39; or &#39;ccsd&#39; are possible initializations</span>
<span class="sd">        include_reference_ansatz :</span>
<span class="sd">            Also do the reference ansatz (prepare closed-shell Hartree-Fock) (Default value = True)</span>
<span class="sd">        parametrized :</span>
<span class="sd">            Initialize with variables, otherwise with static numbers (Default value = True)</span>
<span class="sd">        trotter_steps: int :</span>

<span class="sd">        initial_amplitudes: typing.Union[str :</span>

<span class="sd">        Amplitudes :</span>

<span class="sd">        ClosedShellAmplitudes] :</span>
<span class="sd">             (Default value = &quot;cc2&quot;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            Parametrized QCircuit</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">initial_amplitudes</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mp2&quot;</span> <span class="ow">and</span> <span class="n">add_singles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">add_singles</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">initial_amplitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">add_singles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;make_uccsd_anstatz: add_singles has no effect when explicit amplitudes are passed down&quot;</span><span class="p">,</span>
                          <span class="n">TequilaWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">add_singles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">add_singles</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;make_uccsd_ansatz currently only for closed shell systems&quot;</span><span class="p">)</span>

        <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">nvirt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">-</span> <span class="n">nocc</span>

        <span class="n">Uref</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">include_reference_ansatz</span><span class="p">:</span>
            <span class="n">Uref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_reference</span><span class="p">()</span>

        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">initial_amplitudes</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">initial_amplitudes</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mp2&quot;</span><span class="p">:</span>
                <span class="n">amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mp2_amplitudes</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;ccsd&quot;</span><span class="p">:</span>
                <span class="n">amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_ccsd_amplitudes</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">amplitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_amplitudes</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="se">\n</span><span class="s2">Don&#39;t know how to initialize </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s2"> amplitudes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">,</span> <span class="n">initial_amplitudes</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">amplitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tia</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">add_singles</span><span class="p">:</span> <span class="n">tia</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">nocc</span><span class="p">,</span> <span class="n">nvirt</span><span class="p">])</span>
            <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">ClosedShellAmplitudes</span><span class="p">(</span>
                <span class="n">tIjAb</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">nocc</span><span class="p">,</span> <span class="n">nocc</span><span class="p">,</span> <span class="n">nvirt</span><span class="p">,</span> <span class="n">nvirt</span><span class="p">]),</span>
                <span class="n">tIA</span><span class="o">=</span><span class="n">tia</span><span class="p">)</span>
            <span class="n">screening</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">closed_shell</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span> <span class="n">ClosedShellAmplitudes</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">screening</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">amplitudes</span><span class="o">.</span><span class="n">make_parameter_dictionary</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">screening</span><span class="o">=</span><span class="n">screening</span><span class="p">)</span>
            <span class="n">amplitudes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">amplitudes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">amplitudes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">screening</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">closed_shell</span><span class="p">:</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">add_singles</span><span class="p">:</span>
                        <span class="c1"># singles</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">t</span>
                        <span class="k">if</span> <span class="n">parametrized</span><span class="p">:</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                        <span class="n">idx_a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">idx_b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">indices</span><span class="p">[</span><span class="n">idx_a</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>
                        <span class="n">indices</span><span class="p">[</span><span class="n">idx_b</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">t</span>
                        <span class="k">if</span> <span class="n">parametrized</span><span class="p">:</span>
                            <span class="n">angle</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                        <span class="n">idx_abab</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                        <span class="n">indices</span><span class="p">[</span><span class="n">idx_abab</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span>
                        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                            <span class="n">idx_aaaa</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                            <span class="n">idx_bbbb</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">partner</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
                            <span class="n">anglex</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">amplitudes</span><span class="p">[</span><span class="n">partner</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">parametrized</span><span class="p">:</span>
                                <span class="n">anglex</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span> <span class="o">-</span> <span class="n">Variable</span><span class="p">(</span><span class="n">partner</span><span class="p">))</span>
                            <span class="n">indices</span><span class="p">[</span><span class="n">idx_aaaa</span><span class="p">]</span> <span class="o">=</span> <span class="n">anglex</span>
                            <span class="n">indices</span><span class="p">[</span><span class="n">idx_bbbb</span><span class="p">]</span> <span class="o">=</span> <span class="n">anglex</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;only closed-shell supported, please assemble yourself .... sorry :-)&quot;</span><span class="p">)</span>

        <span class="n">UCCSD</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">trotter_steps</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trotter_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">converted</span> <span class="o">=</span> <span class="p">[(</span><span class="n">idx</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
                <span class="n">UCCSD</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_excitation_gate</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">converted</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">factor</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">initial_amplitudes</span><span class="p">,</span>
                   <span class="s2">&quot;lower&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">initial_amplitudes</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mp2&quot;</span> <span class="ow">and</span> <span class="n">parametrized</span> <span class="ow">and</span> <span class="n">add_singles</span><span class="p">:</span>
            <span class="c1"># mp2 has no singles, need to initialize them here (if not parametrized initializling as 0.0 makes no sense though)</span>
            <span class="n">UCCSD</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_upccgsd_layer</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="s2">&quot;upccsd&quot;</span><span class="p">,</span> <span class="n">include_singles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_doubles</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Uref</span> <span class="o">+</span> <span class="n">UCCSD</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_amplitudes">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_amplitudes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute closed-shell CC amplitudes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method :</span>
<span class="sd">            coupled-cluster methods like cc2, ccsd, cc3, ccsd(t)</span>
<span class="sd">            Success might depend on backend</span>
<span class="sd">            got an extra function for MP2</span>
<span class="sd">        *args :</span>

<span class="sd">        **kwargs :</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;compute amplitudes: Needs to be overwritten by backend&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_energy">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_energy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call classical methods over PySCF (needs to be installed) or</span>
<span class="sd">        use as a shortcut to calculate quantum energies (see make_upccgsd_ansatz)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method: method name</span>
<span class="sd">                classical: HF, MP2, CCSD, CCSD(T), FCI -- with pyscf</span>
<span class="sd">                quantum: UpCCD, UpCCSD, UpCCGSD, k-UpCCGSD, UCCSD,</span>
<span class="sd">                see make_upccgsd_ansatz of the this class for more information</span>
<span class="sd">        args</span>
<span class="sd">        kwargs: for quantum methods, keyword arguments for minimizer</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;U&quot;</span><span class="p">]]):</span>
            <span class="c1"># simulate entirely in HCB representation if no singles are involved</span>
            <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;HCB&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">():</span>
                <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;HCB-&quot;</span> <span class="o">+</span> <span class="n">method</span>
            <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_ansatz</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;hcb&quot;</span> <span class="ow">in</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_hardcore_boson_hamiltonian</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_hamiltonian</span><span class="p">()</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">ExpectationValue</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">)</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">tequila</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
            <span class="k">return</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="o">=</span><span class="n">E</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">energy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">tequila.quantumchemistry</span><span class="w"> </span><span class="kn">import</span> <span class="n">INSTALLED_QCHEMISTRY_BACKENDS</span>
            <span class="k">if</span> <span class="s2">&quot;pyscf&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">INSTALLED_QCHEMISTRY_BACKENDS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                    <span class="s2">&quot;PySCF needs to be installed to compute </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">basis_set</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">tequila.quantumchemistry</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantumChemistryPySCF</span>
                <span class="n">molx</span> <span class="o">=</span> <span class="n">QuantumChemistryPySCF</span><span class="o">.</span><span class="n">from_tequila</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">molx</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_fock_matrix">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_fock_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_fock_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">to</span><span class="o">=</span><span class="s2">&quot;phys&quot;</span><span class="p">)</span>

        <span class="c1"># fock matrix is:</span>
        <span class="c1"># Fkl = hkl + 2.0 &lt;k|J|l&gt; - &lt;k|K|l&gt; = hkl + 2.0* &lt;ki|g|li&gt; - &lt;ki|g|il&gt;</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">h</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">ii</span><span class="o">.</span><span class="n">idx</span>
                    <span class="n">tmp</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>
                <span class="n">F</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">F</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_mp2_amplitudes">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_mp2_amplitudes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_mp2_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hf_energy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_energy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClosedShellAmplitudes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Compute closed-shell mp2 amplitudes (canonical amplitudes only)</span>

<span class="sd">        .. math::</span>
<span class="sd">            t(a,i,b,j) = 0.25 * g(a,i,b,j)/(e(i) + e(j) -a(i) - b(j) )</span>

<span class="sd">        :return:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">()</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_fock_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_canonical</span><span class="p">(</span><span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fock_matrix</span><span class="o">=</span><span class="n">fi</span><span class="p">)</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed_shell</span><span class="p">(</span><span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nocc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span><span class="p">)</span>
        <span class="n">ei</span> <span class="o">=</span> <span class="n">fi</span><span class="p">[:</span><span class="n">nocc</span><span class="p">]</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="n">fi</span><span class="p">[</span><span class="n">nocc</span><span class="p">:]</span>
        <span class="n">abgij</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">elems</span><span class="p">[</span><span class="n">nocc</span><span class="p">:,</span> <span class="n">nocc</span><span class="p">:,</span> <span class="p">:</span><span class="n">nocc</span><span class="p">,</span> <span class="p">:</span><span class="n">nocc</span><span class="p">]</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">abgij</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">ei</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ei</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ai</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">ai</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">ClosedShellAmplitudes</span><span class="p">(</span><span class="n">tIjAb</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abij -&gt; ijab&#39;</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">return_energy</span><span class="p">:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abij,abij-&gt;&#39;</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">,</span> <span class="n">abgij</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;abji,abij&#39;</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">,</span> <span class="n">abgij</span><span class="p">,</span><span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">E</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.compute_cis_amplitudes">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_cis_amplitudes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_cis_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the CIS amplitudes of the molecule</span>
<span class="sd">        Warning: Not field tested!</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nd">@dataclass</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">ResultCIS</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>
            <span class="n">omegas</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span>  <span class="c1"># excitation energies [omega0, ...]</span>
            <span class="n">amplitudes</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">ClosedShellAmplitudes</span><span class="p">]</span>  <span class="c1"># corresponding amplitudes [x_{ai}_0, ...]</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitudes</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed_shell</span><span class="p">(</span><span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integrals</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">to</span><span class="o">=</span><span class="s2">&quot;openfermion&quot;</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">elems</span>
        <span class="n">fij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_fock_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_canonical</span><span class="p">(</span><span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fock_matrix</span><span class="o">=</span><span class="n">fij</span><span class="p">)</span>
        <span class="n">fij</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fij</span><span class="p">)</span>

        <span class="n">nocc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">nvirt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">-</span> <span class="n">nocc</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nocc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nocc</span><span class="p">,</span> <span class="n">nocc</span> <span class="o">+</span> <span class="n">nvirt</span><span class="p">):</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">xx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">eia</span> <span class="o">=</span> <span class="n">fij</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">fij</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">for</span> <span class="n">yy</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">y</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">gpart</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">g</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">M</span><span class="p">[</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">]</span> <span class="o">=</span> <span class="n">eia</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">+</span> <span class="n">gpart</span>

        <span class="n">omega</span><span class="p">,</span> <span class="n">xvecs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c1"># convert amplitudes to ndarray sorted by excitation energy</span>
        <span class="n">nex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nex</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">nvirt</span><span class="p">,</span> <span class="n">nocc</span><span class="p">])</span>
            <span class="n">exvec</span> <span class="o">=</span> <span class="n">xvecs</span><span class="p">[</span><span class="n">ex</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">xx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">t</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="n">nocc</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exvec</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span>
            <span class="n">amplitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ClosedShellAmplitudes</span><span class="p">(</span><span class="n">tIA</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ResultCIS</span><span class="p">(</span><span class="n">omegas</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">amplitudes</span><span class="o">=</span><span class="n">amplitudes</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.is_closed_shell">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.is_closed_shell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_closed_shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">verify</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;not a closed shell molecule: having </span><span class="si">{}</span><span class="s2"> electrons&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_electrons</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cs</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.is_canonical">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.is_canonical">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_canonical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fock_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">canonical</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">fock_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fock_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_fock_matrix</span><span class="p">()</span>

        <span class="n">is_diagonal</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fock_matrix</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fock_matrix</span><span class="p">))),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.e-4</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_diagonal</span><span class="p">:</span>
            <span class="n">canonical</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">refo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_orbitals</span>

        <span class="k">if</span> <span class="n">refo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">canonical</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">refo</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">refo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">idx_total</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">refo</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">idx_total</span><span class="p">:</span>
                <span class="n">canonical</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">verify</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">canonical</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;reference_orbitals&quot;</span><span class="p">:</span><span class="n">refo</span><span class="p">,</span> <span class="s2">&quot;fock_matrix&quot;</span><span class="p">:</span><span class="n">fock_matrix</span><span class="p">}</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;orbitals are not canonical or can not be verified as such -&gt; implemented method only works for standard orbitals (preferably from psi4)</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">canonical</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rdm1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Returns RMD1 if computed with compute_rdms function before</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1-RDM has not been computed. Return None for 1-RDM.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rdm2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns RMD2 if computed with compute_rdms function before</span>
<span class="sd">        This is returned in Dirac (physics) notation by default (can be changed in compute_rdms with keyword)!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2-RDM has not been computed. Return None for 2-RDM.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="QuantumChemistryBase.compute_rdms">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.compute_rdms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_rdms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">QCircuit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Variables</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spin_free</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">get_rdm1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">get_rdm2</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;dirac&quot;</span><span class="p">,</span> <span class="n">use_hcb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">rdm_trafo</span><span class="p">:</span> <span class="n">QubitHamiltonian</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the one- and two-particle reduced density matrices (rdm1 and rdm2) given</span>
<span class="sd">        a unitary U. This method uses the standard ordering in physics as denoted below.</span>
<span class="sd">        Note, that the representation of the density matrices depends on the qubit transformation</span>
<span class="sd">        used. The Jordan-Wigner encoding corresponds to &#39;classical&#39; second quantized density</span>
<span class="sd">        matrices in the occupation picture.</span>

<span class="sd">        We only consider real orbitals and thus real-valued RDMs.</span>
<span class="sd">        The matrices are set as private members _rdm1, _rdm2 and can be accessed via the properties rdm1, rdm2.</span>

<span class="sd">        .. math :</span>
<span class="sd">            \\text{rdm1: } \\gamma^p_q = \\langle \\psi | a^p a_q | \\psi \\rangle</span>
<span class="sd">                                     = \\langle U 0 | a^p a_q | U 0 \\rangle</span>
<span class="sd">            \\text{rdm2: } \\gamma^{pq}_{rs} = \\langle \\psi | a^p a^q a_s a_r | \\psi \\rangle</span>
<span class="sd">                                             = \\langle U 0 | a^p a^q a_s a_r | U 0 \\rangle</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        U :</span>
<span class="sd">            Quantum Circuit to achieve the desired state \\psi = U |0\\rangle, non-optional</span>
<span class="sd">        variables :</span>
<span class="sd">            If U is parametrized, then need to hand over a set of fixed variables</span>
<span class="sd">        spin_free :</span>
<span class="sd">            Set whether matrices should be spin-free (summation over spin) or defined by spin-orbitals</span>
<span class="sd">        get_rdm1, get_rdm2 :</span>
<span class="sd">            Set whether either one or both rdm1, rdm2 should be computed. If both are needed at some point,</span>
<span class="sd">            it is recommended to compute them at once.</span>
<span class="sd">        rdm_trafo :</span>
<span class="sd">            The rdm operators can be transformed, e.g., a^dagger_i a_j -&gt; U^dagger a^dagger_i a_j U,</span>
<span class="sd">            where U represents the transformation. The default is set to None, implying that U equas the identity.</span>
<span class="sd">        evaluate :</span>
<span class="sd">            if true, the tequila expectation values are evaluated directly via the tq.simulate command.</span>
<span class="sd">            the protocol is optimized to avoid repetation of wavefunction simulation</span>
<span class="sd">            if false, the rdms are returned as tq.QTensors</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check whether unitary circuit is not 0</span>
        <span class="k">if</span> <span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s1">&#39;Need to specify a Quantum Circuit.&#39;</span><span class="p">)</span>
        <span class="c1"># Check whether transformation is BKSF.</span>
        <span class="c1"># Issue here: when a single operator acts only on a subset of qubits, BKSF might not yield the correct</span>
        <span class="c1"># transformation, because it computes the number of qubits incorrectly in this case.</span>
        <span class="c1"># A hotfix such as for symmetry_conserving_bravyi_kitaev would require deeper changes, thus omitted for now</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;BravyiKitaevFast&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                <span class="s2">&quot;The Bravyi-Kitaev-Superfast transformation does not support general FermionOperators yet.&quot;</span><span class="p">)</span>
        <span class="c1"># Set up number of spin-orbitals and molecular orbitals respectively</span>
        <span class="n">n_SOs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>
        <span class="n">n_MOs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>

        <span class="c1"># Check whether unitary circuit is not 0</span>
        <span class="k">if</span> <span class="n">U</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s1">&#39;Need to specify a Quantum Circuit.&#39;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_hcb_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;Build the hardcore boson operators: b^\dagger_ib_j + h.c. in qubit encoding &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># iijj uddu+duud</span>
                    <span class="k">return</span> <span class="n">Sm</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">Sm</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># ijij uuuu+dddd</span>
                    <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># ijji abba</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sm</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Sp</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Zero</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_of_op</span><span class="p">(</span><span class="n">operator_tuple</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns operator given by a operator tuple as OpenFermion - Fermion operator &quot;&quot;&quot;</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">FermionOperator</span><span class="p">(</span><span class="n">operator_tuple</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">op</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_qop_hermitian</span><span class="p">(</span><span class="n">of_operator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QubitHamiltonian</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns Hermitian part of Fermion operator as QubitHamiltonian &quot;&quot;&quot;</span>
            <span class="n">qop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">(</span><span class="n">of_operator</span><span class="p">)</span>
            <span class="c1"># qop = QubitHamiltonian(self.transformation(of_operator))</span>
            <span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="n">qop</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">real</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">real</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                    <span class="s2">&quot;Qubit Hamiltonian does not have a Hermitian part. Operator =</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">of_operator</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_build_1bdy_operators_spinful</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns spinful one-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetry pq = qp</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_build_2bdy_operators_spinful</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns spinful two-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetries pqrs = -pqsr = -qprs = qpsr</span>
            <span class="c1">#                and      =  rspq</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">s</span><span class="p">:</span>
                                <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                                <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                                <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_build_1bdy_operators_spinfree</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns spinfree one-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetry pq = qp (not changed by spin-summation)</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Spin aa</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin bb</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_build_2bdy_operators_spinfree</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns spinfree two-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetries pqrs = qpsr (due to spin summation, &#39;-pqsr = -qprs&#39; drops out)</span>
            <span class="c1">#                and      = rspq</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">s</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">):</span>
                    <span class="c1"># Spin aaaa</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">s</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin abab</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span>
                            <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin baba</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span>
                            <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="ow">and</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin bbbb</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span>
                            <span class="n">p</span> <span class="o">!=</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">s</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_of_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_assemble_rdm1</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">rdm1</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns spin-ful or spin-free one-particle RDM built by symmetry conditions</span>
<span class="sd">            Same symmetry with or without spin, so we can use the same function</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">n_MOs</span> <span class="k">if</span> <span class="n">spin_free</span> <span class="k">else</span> <span class="n">n_SOs</span>
            <span class="k">if</span> <span class="n">rdm1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rdm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">])</span>
            <span class="n">ctr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">rdm1</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span>
                    <span class="c1"># Symmetry pq = qp</span>
                    <span class="n">rdm1</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm1</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
                    <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">rdm1</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_assemble_rdm2_spinful</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">rdm2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns spin-ful two-particle RDM built by symmetry conditions &quot;&quot;&quot;</span>
            <span class="n">ctr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">rdm2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rdm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_SOs</span><span class="p">,</span> <span class="n">n_SOs</span><span class="p">,</span> <span class="n">n_SOs</span><span class="p">,</span> <span class="n">n_SOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_SOs</span> <span class="o">+</span> <span class="n">s</span><span class="p">:</span>
                                <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span>
                                <span class="c1"># Symmetry pqrs = rspq</span>
                                <span class="n">rdm2</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
                                <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Further permutational symmetries due to anticommutation relations</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_SOs</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                            <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># pqrs = -pqsr</span>
                            <span class="n">rdm2</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># pqrs = -qprs</span>
                            <span class="n">rdm2</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>  <span class="c1"># pqrs =  qpsr</span>

            <span class="k">return</span> <span class="n">rdm2</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_assemble_rdm2_spinfree</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">rdm2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns spin-free two-particle RDM built by symmetry conditions &quot;&quot;&quot;</span>
            <span class="n">ctr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">rdm2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rdm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">s</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">):</span>
                    <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span>
                    <span class="c1"># Symmetry pqrs = rspq</span>
                    <span class="n">rdm2</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
                    <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Further permutational symmetry: pqrs = qpsr</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">:</span>
                    <span class="n">rdm2</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm2</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">rdm2</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_build_1bdy_operators_hcb</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns hcb one-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetry pq = qp (not changed by spin-summation)</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up_then_down</span><span class="p">):</span>
                            <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">_get_hcb_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">_get_hcb_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                        <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Zero</span><span class="p">()]</span>
            <span class="k">return</span> <span class="n">ops</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_build_2bdy_operators_hcb</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Returns hcb two-body operators as a symmetry-reduced list of QubitHamiltonians &quot;&quot;&quot;</span>
            <span class="c1"># Exploit symmetries pqrs = qpsr (due to spin summation, &#39;-pqsr = -qprs&#39; drops out)</span>
            <span class="c1">#                and      = rspq</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="o">.</span><span class="n">up_then_down</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">n_MOs</span> <span class="o">+</span> <span class="n">s</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">):</span>
                    <span class="c1"># Spin abba+ baab allow p=q=r=s orb iijj</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">scale</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span>
                            <span class="n">p</span> <span class="o">==</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_get_hcb_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin abba+ baab dont allow p=q=r=s orb ijij</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">scale</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span>
                            <span class="n">p</span> <span class="o">!=</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_hcb_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="c1"># Spin aaaa+ bbbb dont allow p=q=r=s  orb ijji</span>
                    <span class="n">op_tuple</span> <span class="o">=</span> <span class="p">((</span><span class="n">scale</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="p">(</span>
                            <span class="n">p</span> <span class="o">!=</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">!=</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">==</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">q</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;0.0 []&#39;</span>
                    <span class="n">op</span> <span class="o">+=</span> <span class="n">_get_hcb_op</span><span class="p">(</span><span class="n">op_tuple</span><span class="p">)</span>
                    <span class="n">ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">op</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ops</span>

        <span class="c1"># Build operator lists</span>
        <span class="n">qops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">spin_free</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_hcb</span><span class="p">:</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_1bdy_operators_spinfree</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm1</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_2bdy_operators_spinfree</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">use_hcb</span><span class="p">:</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_1bdy_operators_hcb</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm1</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_2bdy_operators_hcb</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_hcb</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span>
                    <span class="s2">&quot;compute_rdms: spin_free=</span><span class="si">{}</span><span class="s2"> and use_hcb=</span><span class="si">{}</span><span class="s2"> are not compatible&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spin_free</span><span class="p">,</span> <span class="n">use_hcb</span><span class="p">))</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_1bdy_operators_spinful</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm1</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">qops</span> <span class="o">+=</span> <span class="n">_build_2bdy_operators_spinful</span><span class="p">()</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="c1"># Transform operator lists to QubitHamiltonians</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">use_hcb</span><span class="p">):</span>
            <span class="n">qops</span> <span class="o">=</span> <span class="p">[</span><span class="n">_get_qop_hermitian</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">qops</span><span class="p">]</span>

        <span class="c1"># Compute expected values</span>
        <span class="n">rdm1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rdm2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">tequila</span><span class="w"> </span><span class="kn">import</span> <span class="n">QTensor</span>
        <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rdm_trafo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">evals</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">qops</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">qops</span><span class="p">)]),</span> <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qops</span> <span class="o">=</span> <span class="p">[</span><span class="n">rdm_trafo</span><span class="o">.</span><span class="n">dagger</span><span class="p">()</span><span class="o">*</span><span class="n">qops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">rdm_trafo</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qops</span><span class="p">))]</span>
                <span class="n">evals</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">qops</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">qops</span><span class="p">)]),</span> <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rdm_trafo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">evals</span> <span class="o">=</span> <span class="p">[</span><span class="n">ExpectationValue</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">qops</span><span class="p">]</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">n_MOs</span> <span class="k">if</span> <span class="n">spin_free</span> <span class="k">else</span> <span class="n">n_SOs</span>
                <span class="n">rdm1</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">])</span>
                <span class="n">rdm2</span> <span class="o">=</span> <span class="n">QTensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;compute_rdms: rdm_trafo was set but evaluate flag is False (not supported)&quot;</span><span class="p">)</span>

        <span class="c1"># Assemble density matrices</span>
        <span class="c1"># If self._rdm1, self._rdm2 exist, reset them if they are of the other spin-type</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_reset_rdm</span><span class="p">(</span><span class="n">rdm</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rdm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">spin_free</span> <span class="ow">or</span> <span class="n">use_hcb</span><span class="p">)</span> <span class="ow">and</span> <span class="n">rdm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_MOs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">spin_free</span> <span class="ow">and</span> <span class="n">rdm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_SOs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">rdm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="o">=</span> <span class="n">_reset_rdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="n">_reset_rdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">)</span>
        <span class="c1"># Split expectation values in 1- and 2-particle expectation values</span>
        <span class="k">if</span> <span class="n">get_rdm1</span><span class="p">:</span>
            <span class="n">len_1</span> <span class="o">=</span> <span class="n">n_MOs</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_MOs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">if</span> <span class="p">(</span><span class="n">spin_free</span> <span class="ow">or</span> <span class="n">use_hcb</span><span class="p">)</span> <span class="k">else</span> <span class="n">n_SOs</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_SOs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">len_1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">evals_1</span><span class="p">,</span> <span class="n">evals_2</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[:</span><span class="n">len_1</span><span class="p">],</span> <span class="n">evals</span><span class="p">[</span><span class="n">len_1</span><span class="p">:]</span>
        <span class="c1"># Build matrices using the expectation values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="o">=</span> <span class="n">_assemble_rdm1</span><span class="p">(</span><span class="n">evals_1</span><span class="p">,</span> <span class="n">rdm1</span><span class="o">=</span><span class="n">rdm1</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_rdm1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span>
        <span class="k">if</span> <span class="n">spin_free</span> <span class="ow">or</span> <span class="n">use_hcb</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="n">_assemble_rdm2_spinfree</span><span class="p">(</span><span class="n">evals_2</span><span class="p">,</span> <span class="n">rdm2</span><span class="o">=</span><span class="n">rdm2</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="n">_assemble_rdm2_spinful</span><span class="p">(</span><span class="n">evals_2</span><span class="p">,</span> <span class="n">rdm2</span><span class="o">=</span><span class="n">rdm2</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_rdm2</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span>

        <span class="k">if</span> <span class="n">get_rdm2</span><span class="p">:</span>
            <span class="n">rdm2</span> <span class="o">=</span> <span class="n">NBodyTensor</span><span class="p">(</span><span class="n">elems</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rdm2</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="s2">&quot;dirac&quot;</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">rdm2</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">to</span><span class="o">=</span><span class="n">ordering</span><span class="p">)</span>
            <span class="n">rdm2</span> <span class="o">=</span> <span class="n">rdm2</span><span class="o">.</span><span class="n">elems</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="o">=</span> <span class="n">rdm2</span>

        <span class="k">if</span> <span class="n">get_rdm1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_rdm2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdm1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdm2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdm1</span>
        <span class="k">elif</span> <span class="n">get_rdm2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rdm2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;compute_rdms called with instruction to not compute?&quot;</span><span class="p">,</span> <span class="n">TequilaWarning</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.rdm_spinsum">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.rdm_spinsum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rdm_spinsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sum_rdm1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sum_rdm2</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the spin-ful 1- and 2-particle reduced density matrices, compute the spin-free RDMs by spin summation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            sum_rdm1, sum_rdm2 :</span>
<span class="sd">               If set to true, perform spin summation on rdm1, rdm2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            rdm1_spinsum, rdm2_spinsum :</span>
<span class="sd">                The desired spin-free matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_MOs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span>
        <span class="n">rdm1_spinsum</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rdm2_spinsum</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Spin summation on rdm1</span>
        <span class="k">if</span> <span class="n">sum_rdm1</span><span class="p">:</span>
            <span class="c1"># Check whether spin-rdm2 exists</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The spin-RDM for the 1-RDM does not exist!&quot;</span><span class="p">)</span>
            <span class="c1"># Check whether existing rdm1 is in spin-orbital basis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_MOs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The existing RDM needs to be in spin-orbital basis, it is already spin-free!&quot;</span><span class="p">)</span>
            <span class="c1"># Do summation</span>
            <span class="n">rdm1_spinsum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">]</span>
                    <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm1</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdm1_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

        <span class="c1"># Spin summation on rdm2</span>
        <span class="k">if</span> <span class="n">sum_rdm2</span><span class="p">:</span>
            <span class="c1"># Check whether spin-rdm2 exists</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The spin-RDM for the 2-RDM does not exist!&quot;</span><span class="p">)</span>
            <span class="c1"># Check whether existing rdm2 is in spin-orbital basis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_MOs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TequilaException</span><span class="p">(</span><span class="s2">&quot;The existing RDM needs to be in spin-orbital basis, it is already spin-free!&quot;</span><span class="p">)</span>
            <span class="c1"># Do summation</span>
            <span class="n">rdm2_spinsum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">,</span> <span class="n">n_MOs</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_MOs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">]</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="p">]</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">rdm2_spinsum</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdm2</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rdm1_spinsum</span><span class="p">,</span> <span class="n">rdm2_spinsum</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.perturbative_f12_correction">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.perturbative_f12_correction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">perturbative_f12_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rdm1</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rdm2</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.4</span><span class="p">,</span> <span class="n">n_ri</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">external_info</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the spin-free [2]_R12 correction, needing only the 1- and 2-RDM of a reference method</span>
<span class="sd">        Requires either 1-RDM, 2-RDM or information to compute them in kwargs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdm1 :</span>
<span class="sd">            1-electron reduced density matrix</span>
<span class="sd">        rdm2 :</span>
<span class="sd">            2-electron reduced density matrix</span>
<span class="sd">        gamma :</span>
<span class="sd">            f12-exponent, for a correlation factor f_12 = -1/gamma * exp[-gamma*r_12]</span>
<span class="sd">        n_ri :</span>
<span class="sd">            dimensionality of RI-basis; specify only, if want to truncate available RI-basis</span>
<span class="sd">            if None, then the maximum available via tensors / basis-set is used</span>
<span class="sd">            must not be larger than size of available RI-basis, and not smaller than size of OBS</span>
<span class="sd">            for n_ri==dim(OBS), the correction returns zero</span>
<span class="sd">        external_info :</span>
<span class="sd">            for usage in qc_base, need to provide information where to find one-body tensor f12-tensor &lt;rs|f_12|pq&gt;;</span>
<span class="sd">            pass dictionary with {&quot;f12_filename&quot;: where to find f12-tensor, &quot;scheme&quot;: ordering scheme of tensor}</span>
<span class="sd">        kwargs :</span>
<span class="sd">            e.g. RDM-information via {&quot;U&quot;: QCircuit, &quot;variables&quot;: optimal angles}, needs to be passed if rdm1,rdm2 not</span>
<span class="sd">            yet computed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            the f12 correction for the energy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.f12_corrections._f12_correction_base</span><span class="w"> </span><span class="kn">import</span> <span class="n">ExplicitCorrelationCorrection</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">ExplicitCorrelationCorrection</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">rdm1</span><span class="o">=</span><span class="n">rdm1</span><span class="p">,</span> <span class="n">rdm2</span><span class="o">=</span><span class="n">rdm2</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
                                                   <span class="n">n_ri</span><span class="o">=</span><span class="n">n_ri</span><span class="p">,</span> <span class="n">external_info</span><span class="o">=</span><span class="n">external_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">correction</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuantumChemistryBase.n_rotation">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.n_rotation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">n_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Creates a quantum circuit that applies a phase rotation based on phi to both components (up and down) of a given qubit.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - i (int): The index of the qubit to which the rotation will be applied.</span>
<span class="sd">        - phi (float): The rotation angle. The actual rotation applied will be multiplied with -2 for both components.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - QCircuit: A quantum circuit object containing the sequence of rotations applied to the up and down components of the specified qubit.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Generate number operators for the up and down components of the qubit.</span>
        <span class="n">n_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_number_op</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
        <span class="n">n_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_number_op</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Start a new circuit and apply rotations to each component.</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">gates</span><span class="o">.</span><span class="n">GeneralizedRotation</span><span class="p">(</span><span class="n">generator</span> <span class="o">=</span> <span class="n">n_up</span><span class="p">,</span> <span class="n">angle</span><span class="o">=-</span><span class="mi">2</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">circuit</span> <span class="o">+=</span> <span class="n">gates</span><span class="o">.</span><span class="n">GeneralizedRotation</span><span class="p">(</span><span class="n">generator</span> <span class="o">=</span> <span class="n">n_down</span><span class="p">,</span> <span class="n">angle</span><span class="o">=-</span><span class="mi">2</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">circuit</span></div>

        
<div class="viewcode-block" id="QuantumChemistryBase.get_givens_circuit">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.get_givens_circuit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_givens_circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unitary</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="n">ordering</span> <span class="o">=</span> <span class="n">OPTIMIZED_ORDERING</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Constructs a quantum circuit from a given real unitary matrix using Givens rotations.</span>
<span class="sd">        </span>
<span class="sd">        This method decomposes a unitary matrix into a series of Givens and Rz (phase) rotations,</span>
<span class="sd">        then constructs and returns a quantum circuit that implements this sequence of rotations.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - unitary (numpy.array): A real unitary matrix representing the transformation to implement.</span>
<span class="sd">        - tol (float): A tolerance threshold below which matrix elements are considered zero.</span>
<span class="sd">        - ordering (list of tuples or &#39;Optimized&#39;): Custom ordering of indices for Givens rotations or &#39;Optimized&#39; to generate them automatically.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - QCircuit: A quantum circuit implementing the series of rotations decomposed from the unitary.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Decompose the unitary matrix into Givens and phase (Rz) rotations.</span>
        <span class="n">theta_list</span><span class="p">,</span> <span class="n">phi_list</span> <span class="o">=</span> <span class="n">get_givens_decomposition</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">ordering</span><span class="p">)</span>

        <span class="c1"># Initialize an empty quantum circuit.</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QCircuit</span><span class="p">()</span>

        <span class="c1"># Add all Rz (phase) rotations to the circuit.</span>
        <span class="k">for</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">phi_list</span><span class="p">:</span>
            <span class="n">circuit</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rotation</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Add all Givens rotations to the circuit.</span>
        <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">theta_list</span><span class="p">):</span>
            <span class="n">circuit</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">UR</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">circuit</span></div>



<div class="viewcode-block" id="QuantumChemistryBase.print_basis_info">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.QuantumChemistryBase.print_basis_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">print_basis_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="o">.</span><span class="n">print_basis_info</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;Qubit Encoding</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;Parameters</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;n_qubits&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{key:15}</span><span class="s2"> : </span><span class="si">{value:15}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;reference state&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_state</span><span class="p">()))</span>

        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Basis</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">integral_manager</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">more information with: self.print_basis_info()</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="givens_matrix">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.givens_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">givens_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Construct a complex Givens rotation matrix of dimension n by theta between rows/columns p and q.</span>
<span class="sd">    &#39;&#39;&#39;</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generates a Givens rotation matrix of size n x n to rotate by angle theta in the (p, q) plane. This matrix can be complex</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - n (int): The size of the Givens rotation matrix.</span>
<span class="sd">    - p (int): The first index for the rotation plane.</span>
<span class="sd">    - q (int): The second index for the rotation plane.</span>
<span class="sd">    - theta (float): The rotation angle.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - numpy.array: The Givens rotation matrix.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># Matrix to hold complex numbers</span>
    <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">sin_theta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="c1"># Directly assign cosine and sine without complex phase adjustment</span>
    <span class="n">matrix</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_theta</span>
    <span class="n">matrix</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_theta</span>
    <span class="n">matrix</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_theta</span>
    <span class="n">matrix</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sin_theta</span>

    <span class="k">return</span> <span class="n">matrix</span></div>


<div class="viewcode-block" id="get_givens_decomposition">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.get_givens_decomposition">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_givens_decomposition</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="n">ordering</span> <span class="o">=</span> <span class="n">OPTIMIZED_ORDERING</span><span class="p">,</span> <span class="n">return_diagonal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Decomposes a real unitary matrix into Givens rotations (theta) and Rz rotations (phi).</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - unitary (numpy.array): A real unitary matrix to decompose. It cannot be complex.</span>
<span class="sd">    - tol (float): Tolerance for considering matrix elements as zero. Elements with absolute value less than tol are treated as zero.</span>
<span class="sd">    - ordering (list of tuples or &#39;Optimized&#39;): Custom ordering of indices for Givens rotations or &#39;Optimized&#39; to generate them automatically.</span>
<span class="sd">    - return_diagonal (bool): If True, the function also returns the diagonal matrix as part of the output.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - list: A list of tuples, each representing a Givens rotation. Each tuple contains the rotation angle theta and indices (i,j) of the rotation.</span>
<span class="sd">    - list: A list of tuples, each representing an Rz rotation. Each tuple contains the rotation angle phi and the index (i) of the rotation.</span>
<span class="sd">    - numpy.array (optional): The diagonal matrix after applying all Givens rotations, returned if return_diagonal is True.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">unitary</span> <span class="c1"># no need to copy as we don&#39;t modify the original</span>
    <span class="n">U</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Zeroing out the small elements as per the tolerance level.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Determine optimized ordering if specified.</span>
    <span class="k">if</span> <span class="n">ordering</span> <span class="o">==</span> <span class="n">OPTIMIZED_ORDERING</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">depth_eff_order_mf</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">theta_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">phi_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">calcTheta</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Calculate and apply the Givens rotation for a specific matrix element.&#39;&#39;&#39;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">U</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
        <span class="n">theta_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">givens_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">U</span>

    <span class="c1"># Apply and store Givens rotations as per the given or computed ordering.</span>
    <span class="k">if</span> <span class="n">ordering</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">calcTheta</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ordering</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">calcTheta</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    
    <span class="c1"># Calculating the Rz rotations based on the phases of the diagonal elements.</span>
    <span class="c1"># For real elements this means a 180 degree shift, i.e. a sign change.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">phi_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ph</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="c1"># Filtering out rotations without significance.</span>
    <span class="n">theta_list_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theta_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">theta_list_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    
    <span class="n">phi_list_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phi_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">phi_list_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_diagonal</span><span class="p">:</span>
        <span class="c1"># Optionally return the resulting diagonal</span>
        <span class="k">return</span> <span class="n">theta_list_new</span><span class="p">,</span> <span class="n">phi_list_new</span><span class="p">,</span> <span class="n">U</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta_list_new</span><span class="p">,</span> <span class="n">phi_list_new</span></div>

    
<div class="viewcode-block" id="reconstruct_matrix_from_givens">
<a class="viewcode-back" href="../../../quantumchemistry.html#tequila_code.quantumchemistry.qc_base.reconstruct_matrix_from_givens">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_matrix_from_givens</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta_list</span><span class="p">,</span> <span class="n">phi_list</span><span class="p">,</span> <span class="n">to_real_if_possible</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Reconstructs a matrix from given Givens rotations and Rz diagonal rotations.</span>
<span class="sd">    This function is effectively an inverse of get_givens_decomposition, and therefore only works with data in the same format as its output.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - n (int): The size of the unitary matrix to be reconstructed.</span>
<span class="sd">    - theta_list (list of tuples): Each tuple contains (angle, i, j) representing a Givens rotation of `angle` radians, applied to rows/columns `i` and `j`.</span>
<span class="sd">    - phi_list (list of tuples): Each tuple contains (angle, i), representing an Rz rotation by `angle` radians applied to the `i`th diagonal element.</span>
<span class="sd">    - to_real_if_possible (bool): If True, converts the matrix to real if its imaginary part is effectively zero.</span>
<span class="sd">    - tol (float): The tolerance whether to swap a complex rotation for a sign change.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - numpy.ndarray: The reconstructed complex or real matrix, depending on the `to_real_if_possible` flag and matrix composition.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Start with an identity matrix</span>
    <span class="n">reconstructed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    
    <span class="c1"># Apply Rz rotations for diagonal elements</span>
    <span class="k">for</span> <span class="n">phi</span> <span class="ow">in</span> <span class="n">phi_list</span><span class="p">:</span>
        <span class="n">angle</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">phi</span>
        <span class="c1"># Directly apply a sign flip if the rotation angle is π</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
            <span class="n">reconstructed</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reconstructed</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span>
        
    <span class="c1"># Apply Givens rotations in reverse order</span>
    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">theta_list</span><span class="p">):</span>
        <span class="n">angle</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">givens_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">reconstructed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">reconstructed</span><span class="p">)</span> <span class="c1"># Transpose of Givens matrix applied to the left</span>

    <span class="c1"># Convert matrix to real if its imaginary part is negligible unless disabled via to_real_if_possible</span>
    <span class="k">if</span> <span class="n">to_real_if_possible</span><span class="p">:</span>
        <span class="c1"># Directly apply a sign flip if the rotation angle is π</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">reconstructed</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Convert to real by taking the real part</span>
            <span class="n">reconstructed</span> <span class="o">=</span> <span class="n">reconstructed</span><span class="o">.</span><span class="n">real</span>

    <span class="k">return</span> <span class="n">reconstructed</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Ram Mosco.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>