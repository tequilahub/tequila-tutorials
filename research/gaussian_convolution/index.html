<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Oliver Hüttenhofer">
<meta name="dcterms.date" content="2024-11-23">

<title>Tequila Tutorials - Building a Quantum Circuit for Gaussian Convolutions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V7DRP5E70N"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-V7DRP5E70N', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"express",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  });
});
</script> 
  

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Tequila Tutorials - Building a Quantum Circuit for Gaussian Convolutions">
<meta property="og:description" content="">
<meta property="og:image" content="https://github.com/tequilahub/tequila-tutorials/research/gaussian_convolution/img/thumbnail.jpg">
<meta property="og:site-name" content="Tequila Tutorials">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../tequila_logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Tequila Tutorials</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html" rel="" target="">
 <span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials.html" rel="" target="">
 <span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../FAQ/FAQ.html" rel="" target="">
 <span class="menu-text">FAQ</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Contribution/Contribution.html" rel="" target="">
 <span class="menu-text">Contribution</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../docs/sphinx/index.html" rel="" target="">
 <span class="menu-text">Docs</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Building a Quantum Circuit for Gaussian Convolutions</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Oliver Hüttenhofer </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 23, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">1</span> Overview</a>
  <ul class="collapse">
  <li><a href="#goal" id="toc-goal" class="nav-link" data-scroll-target="#goal"><span class="header-section-number">1.1</span> Goal</a></li>
  <li><a href="#high-level-circuit" id="toc-high-level-circuit" class="nav-link" data-scroll-target="#high-level-circuit"><span class="header-section-number">1.2</span> High-level circuit</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">1.3</span> Summary</a></li>
  </ul></li>
  <li><a href="#state-preparation" id="toc-state-preparation" class="nav-link" data-scroll-target="#state-preparation"><span class="header-section-number">2</span> State Preparation</a>
  <ul class="collapse">
  <li><a href="#core-idea" id="toc-core-idea" class="nav-link" data-scroll-target="#core-idea"><span class="header-section-number">2.1</span> Core Idea</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation"><span class="header-section-number">2.2</span> Implementation</a></li>
  <li><a href="#decomposing-multi-controlled-rotations" id="toc-decomposing-multi-controlled-rotations" class="nav-link" data-scroll-target="#decomposing-multi-controlled-rotations"><span class="header-section-number">2.3</span> Decomposing multi-controlled rotations</a></li>
  <li><a href="#gate-count" id="toc-gate-count" class="nav-link" data-scroll-target="#gate-count"><span class="header-section-number">2.4</span> Gate count</a></li>
  </ul></li>
  <li><a href="#addition" id="toc-addition" class="nav-link" data-scroll-target="#addition"><span class="header-section-number">3</span> Addition</a>
  <ul class="collapse">
  <li><a href="#allowing-different-register-sizes" id="toc-allowing-different-register-sizes" class="nav-link" data-scroll-target="#allowing-different-register-sizes"><span class="header-section-number">3.1</span> Allowing different register sizes</a></li>
  <li><a href="#increment-gate" id="toc-increment-gate" class="nav-link" data-scroll-target="#increment-gate"><span class="header-section-number">3.2</span> Increment gate</a></li>
  <li><a href="#implementation-1" id="toc-implementation-1" class="nav-link" data-scroll-target="#implementation-1"><span class="header-section-number">3.3</span> Implementation</a></li>
  <li><a href="#gate-count-1" id="toc-gate-count-1" class="nav-link" data-scroll-target="#gate-count-1"><span class="header-section-number">3.4</span> Gate count</a></li>
  </ul></li>
  <li><a href="#constant-addition" id="toc-constant-addition" class="nav-link" data-scroll-target="#constant-addition"><span class="header-section-number">4</span> Constant Addition</a>
  <ul class="collapse">
  <li><a href="#carry-circuit" id="toc-carry-circuit" class="nav-link" data-scroll-target="#carry-circuit"><span class="header-section-number">4.1</span> Carry circuit</a></li>
  <li><a href="#implementation-2" id="toc-implementation-2" class="nav-link" data-scroll-target="#implementation-2"><span class="header-section-number">4.2</span> Implementation</a></li>
  <li><a href="#gate-count-2" id="toc-gate-count-2" class="nav-link" data-scroll-target="#gate-count-2"><span class="header-section-number">4.3</span> Gate count</a></li>
  </ul></li>
  <li><a href="#integration" id="toc-integration" class="nav-link" data-scroll-target="#integration"><span class="header-section-number">5</span> Integration</a>
  <ul class="collapse">
  <li><a href="#toeplitz-matrix" id="toc-toeplitz-matrix" class="nav-link" data-scroll-target="#toeplitz-matrix"><span class="header-section-number">5.1</span> Toeplitz matrix</a></li>
  <li><a href="#gate-count-3" id="toc-gate-count-3" class="nav-link" data-scroll-target="#gate-count-3"><span class="header-section-number">5.2</span> Gate count</a></li>
  <li><a href="#postselection-success-probability" id="toc-postselection-success-probability" class="nav-link" data-scroll-target="#postselection-success-probability"><span class="header-section-number">5.3</span> Postselection success probability</a></li>
  <li><a href="#multiple-dimensions" id="toc-multiple-dimensions" class="nav-link" data-scroll-target="#multiple-dimensions"><span class="header-section-number">5.4</span> Multiple dimensions</a></li>
  <li><a href="#lcu" id="toc-lcu" class="nav-link" data-scroll-target="#lcu"><span class="header-section-number">5.5</span> LCU</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">5.6</span> Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">5.7</span> References</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/tequilahub/tequila-tutorials/blob/main/research/gaussian_convolution/index.qmd" class="toc-action">View source</a></p><p><a href="https://github.com/tequilahub/tequila-tutorials/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="overview" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Overview</h1>
<p>This post shows how to use Tequila to implement a quantum circuit which performs a Gaussian convolution.</p>
<p>The first chapter will give an overview over the structure that the circuit will have, and divide it into smaller subproblems which can be implemented separately. These implementations will be described in the next chapters, and combined into the final circuit at the end.</p>
<section id="goal" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="goal"><span class="header-section-number">1.1</span> Goal</h2>
<p>A Gaussian Convolution has an impulse response that is a Gaussian function <span class="math inline">\(g(x) = a \cdot \exp\left(-||x - b||_2^2 / c \right)\)</span>, so when applied to a function <span class="math inline">\(f: \mathbb{R}^d \to \mathbb{R}^d\)</span>, it yields a new function <span class="math display">\[ (f * g)(i) = \int_{\mathbb{R}^d} f(j) \cdot g(i - j) dj \]</span></p>
<p>Note that <span class="math inline">\(g\)</span> is separable, so even if we are interested in high-dimensional functions, it is sufficient to consider the one-dimensional case for now. We can then run the one-dimensional implementation multiple times on separate qubits to get a multi-dimensional implementation.</p>
<p>To implement this on a quantum computer, we want a circuit that instead of a function <span class="math inline">\(f\)</span> takes a state <span class="math inline">\(\ket{\psi} = \sum_{k = 0}^{N - 1} \alpha_i \ket{i}\)</span> on <span class="math inline">\(n\)</span> qubits with <span class="math inline">\(N = 2^n\)</span>, and outputs the state <span class="math display">\[ U \ket{\psi}
= \ket{\psi} * g
= z \cdot \sum_{i = 0}^{N - 1} \left(\sum_{j = 0}^{N - 1} \alpha_j \cdot g(i - j)\right) \ket{i} \]</span> for some normalization factor <span class="math inline">\(z\)</span>.</p>
<p>For a basis state <span class="math inline">\(\ket{\psi} = \ket{j}\)</span>, this gives us <span class="math display">\[ U \ket{j}
= z \cdot \sum_{i = 0}^{N - 1} g(i - j) \ket{i}
= z \cdot \sum_{i = 0}^{N - 1} \exp(-(i - j - b)^2 / c) \ket{i} \]</span> where <span class="math inline">\(z\)</span> might be a different normalization factor than before and might depend on <span class="math inline">\(j\)</span>.</p>
<p>Because the result will be normalized, <span class="math inline">\(a\)</span> does not have any effect and can be ignored. We will also have to make an approximation to implement this efficiently, as we will see in the next section.</p>
</section>
<section id="high-level-circuit" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="high-level-circuit"><span class="header-section-number">1.2</span> High-level circuit</h2>
<p>Now we need to find a way to embed this operation into a quantum circuit. To do this, notice that the matrix representation is a Toeplitz matrix, i.e.&nbsp;a matrix where elements on the same diagonal have the same value.</p>
<p>For example, with <span class="math inline">\(n = 2\)</span>, <span class="math inline">\(b = -1\)</span> and <span class="math inline">\(c = 1\)</span>, it would be <span class="math display">\[ A = \begin{pmatrix}
e^{-1} &amp; 1 &amp; e^{-1} &amp; e^{-4} \\
e^{-4} &amp; e^{-1} &amp; 1 &amp; e^{-1} \\
e^{-9} &amp; e^{-4} &amp; e^{-1} &amp; 1 \\
e^{-16} &amp; e^{-9} &amp; e^{-4} &amp; e^{-1} \\
\end{pmatrix} \]</span></p>
<p>We can follow <span class="citation" data-cites="Sünderhauf_2024"><a href="#ref-Sünderhauf_2024" role="doc-biblioref">[1]</a></span> to implement this, however because we will have to load the value of each diagonal separately, we need to limit the number of diagonals to make this efficient. Luckily this is not an issue if we can tolerate some small error, since the values decrease exponentially in the distance, the number of diagonals only need to be logarithmic in the cutoff value.</p>
<p>In our example, we could limit it to three diagonals, ignoring values <span class="math inline">\(\leq e^{-4}\)</span>, resulting in the following matrix representation: <span class="math display">\[ A' = \begin{pmatrix}
e^{-1} &amp; 1 &amp; e^{-1} &amp; 0 \\
0 &amp; e^{-1} &amp; 1 &amp; e^{-1} \\
0 &amp; 0 &amp; e^{-1} &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; e^{-1} \\
\end{pmatrix} \]</span></p>
<p>Then we can build the following circuit, where <span class="math inline">\(\ket{0} \bra{0}\)</span> indicates postselecting the register as <span class="math inline">\(\ket{0 \dots 0}\)</span>, i.e.&nbsp;rerunning the algorithm until a measurement of this register yields only zeros:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/full.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>First, we use a PREP operation which can initialize any arbitrary state to load a single column of values onto the s register, in this example this would be <span class="math display">\[ \begin{align}
\text{PREP} \ket{0}^{\otimes 2}
= z \cdot \begin{pmatrix} e^{-1} \\ 1 \\ e^{-1} \\ 0 \end{pmatrix}
= z \cdot (e^{-1} \ket{0} + \ket{1} + e^{-1} \ket{2}) \\
= z \cdot \sum_{k = 0}^2 e^{-(k - 1)^2} \ket{k}
= z \cdot \sum_{k = 0}^2 g(k - 2) \ket{k}
\end{align}\]</span> with some normalization factor <span class="math inline">\(z\)</span>.</p>
<p>Then we use an addition operation to add the state from the s register to the j register, which contains the input of the algorithm. This essentially copies the state initialized by PREP onto the register, but shifted by the incoming value (it copies in the sense that a CNOT gate copies a bit, not in the sense that violates the no-cloning theorem).</p>
<p>Next, we subtract some constant <span class="math inline">\(k\)</span> to add an offset from the main diagonal. If we are considering <span class="math inline">\(2 \cdot m + 1\)</span> diagonals, and the main diagonal with value <span class="math inline">\(1\)</span> is in the center, that means there are <span class="math inline">\(m\)</span> diagonals above that. Then <span class="math inline">\(k = m - b\)</span>, so in this example <span class="math inline">\(k = 2\)</span>.</p>
<p>The overflow qubit is treated as an additional high bit of the j register, and indicates that the two additions overflowed and caused values to wrap around the matrix. By postselecting it as <span class="math inline">\(\ket{0}\)</span>, those values can be filtered out. This part can be removed to optimize the circuit, if overflows are impossible or tolerable.</p>
<p>At the end we perform an UNPREP operation on the s register, which is in this case equivalent to a Hadamard gate on each qubit. The register is then postselected as <span class="math inline">\(\ket{0}^{\otimes n}\)</span>. This applies the first row of the matrix representation of <span class="math inline">\(H^{\otimes n}\)</span>, which contains only ones, i.e.&nbsp;builds a sum of the input values, combining the different values in the s register into a single state.</p>
<p>An alternative way of looking at this is as a linear combination of unitaries, where each of the unitaries is one of the diagonals.</p>
<p>Denoting the addition gates in square brackets, and <span class="math inline">\(\ket{0}_s \bra{0}_s\)</span> as the postselection / projection on the <span class="math inline">\(\ket{0}^{\otimes d}\)</span> state on the s register, the result of the circuit is: <span class="math display">\[ \begin{align}
\ket{0}_s \bra{0}_s U \left(\ket{0} \otimes \ket{j} \otimes \ket{0}\right)
=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} \cdot [-2] \cdot [+d] \cdot \text{PREP} \\
&amp;\quad \cdot \left(\ket{0} \otimes \ket{j} \otimes \ket{0}\right) \\[0.5em]
=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} \cdot [-2] \cdot [+d] \\
&amp;\quad \cdot \left(z \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{k} \otimes \ket{j} \otimes \ket{0}\right) \\[0.5em]
=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} \cdot [-2] \\
&amp;\quad \cdot \left(z \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{k} \otimes \ket{(k + j) \text{ mod } 4} \otimes \ket{\text{overflow}}\right) \\[0.5em]
=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} \\
&amp;\quad \cdot \left( z \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{k} \otimes \ket{(k + j - 2) \text{ mod } 4} \otimes \ket{\text{overflow}} \right) \\[0.5em]
=&amp; \widetilde{z} \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{0} \otimes \ket{(k + j - 2) \text{ mod } 4} \otimes \ket{\text{overflow}} \\[0.5em]
\overset{i = k + j - 2}{=}&amp; \widetilde{z} \cdot \ket{0} \otimes \sum_{i = j - 2}^{j} g(i - j) \cdot \ket{i \text{ mod } 4} \otimes \ket{\text{overflow}}
\end{align} \]</span> for some normalization factor <span class="math inline">\(\widetilde{z}\)</span>.</p>
<p>After postselecting the overflow bit as <span class="math inline">\(\ket{0}\)</span>, the values where the modulo operation has an effect are removed, so the sum will run from <span class="math inline">\(i = \max(j - 2, 0)\)</span> to <span class="math inline">\(i = \min(j, 3) = j\)</span>, and the middle register contains the desired results.</p>
<p>The PREP and UNPREP operation here correspond to chosing <span class="math inline">\(p = 1\)</span> in chapter 2.3 of <span class="citation" data-cites="Sünderhauf_2024"><a href="#ref-Sünderhauf_2024" role="doc-biblioref">[1]</a></span>. This makes the calculation easier to follow, however the paper shows that chosing <span class="math inline">\(p = 1 / 2\)</span> is better because it decreases the subnormalization, increasing the success rate of the postselection without changing the result of the circuit, so this is what we will do in the implementation.</p>
</section>
<section id="summary" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="summary"><span class="header-section-number">1.3</span> Summary</h2>
<p>We have seen that we can build a quantum circuit which implements a Gaussian convolution from three building blocks:</p>
<ul>
<li>A PREP block, which can initialize arbitrary states (which can also be used for the UNPREP block)</li>
<li>An addition block which can add a value from one register to another</li>
<li>An addition block which can add a compile time constant to a register</li>
</ul>
<p>In the next chapters, we will see how to build these subcircuits, and at the end we will combine them to the full circuit.</p>
</section>
</section>
<section id="state-preparation" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> State Preparation</h1>
<p>To implement the preparation of arbitrary states, we will follow chapter 4 from <span class="citation" data-cites="Shende_2006"><a href="#ref-Shende_2006" role="doc-biblioref">[2]</a></span>.</p>
<section id="core-idea" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="core-idea"><span class="header-section-number">2.1</span> Core Idea</h2>
<p>To illustrate the idea, we will consider the reverse of what we actually want to do: Assume that we get some arbitrary (but determined at compile time) state <span class="math inline">\(\ket{\psi}\)</span>, and need to transform it to <span class="math inline">\(\ket{0}^{\otimes n}\)</span>. If we can do this, we can simply run the inverse of the circuit to go from <span class="math inline">\(\ket{0}^{\otimes n}\)</span> to <span class="math inline">\(\ket{\psi}\)</span>.</p>
<p>For a single-qubit state this is easily done via a Z-rotation followed by a Y-rotation.</p>
<p>If we instead have a multi-qubit state on <span class="math inline">\(n\)</span> qubits, we can write it in the following way:</p>
<p><span class="math display">\[ \ket{\psi}
= \sum_{k = 0}^{2^{n - 1} - 1} c_k \ket{k} \otimes \ket{\psi_k} \]</span></p>
<p>Here, <span class="math inline">\(\ket{k}\)</span> are the basis states of the first <span class="math inline">\(n - 1\)</span> qubits, <span class="math inline">\(c_k\)</span> some coefficients, and <span class="math inline">\(\ket{\psi_k}\)</span> are single qubit states on the last qubit. With this formulation, we can apply our earlier single qubit approach to each <span class="math inline">\(\ket{\psi_k}\)</span> individually by using multi-controlled rotations, and turning this state into</p>
<p><span class="math display">\[ \sum_{k = 0}^{2^{n - 1} - 1} c_k \ket{k} \otimes \ket{0}
= \left(\sum_{k = 0}^{2^{n - 1} - 1} c_k \ket{k}\right) \otimes \ket{0} \]</span></p>
<p>So we have successfully unentangled the last qubit from the rest of the state. This can now be recursively repeated for the remaining <span class="math inline">\(n - 1\)</span> qubits, until all of them are in the state <span class="math inline">\(\ket{0}\)</span>.</p>
</section>
<section id="implementation" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="implementation"><span class="header-section-number">2.2</span> Implementation</h2>
<p>To make the calculation of the angles efficient, we have to go from least to most signficant bit, allowing us to reuse results from lower bits for the calculation of higher bits.</p>
<p>Then we go through all the possible basis states <span class="math inline">\(i\)</span> of the higher bits, and consider the coefficients <span class="math inline">\(a_0 \ket{0} + a_1 \ket{1}\)</span> where the higher bits are in state <span class="math inline">\(i\)</span>. This allows us to calculate the relative magnitude and phase of these two coefficients, giving us the angles <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\varphi\)</span> for the rotations. But we also need to calculate the “combined” coefficient, which will then be used for the next higher bit.</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prepare_state(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    state: npt.NDArray[<span class="bu">float</span>],</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bit <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(n)):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">**</span> bit):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            a0 <span class="op">=</span> state[<span class="dv">2</span> <span class="op">*</span> i] <span class="cf">if</span> bit <span class="op">==</span> n <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> combined[bit <span class="op">+</span> <span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> i]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            a1 <span class="op">=</span> state[<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>] <span class="cf">if</span> bit <span class="op">==</span> n <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> combined[bit <span class="op">+</span> <span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> hypot(<span class="bu">abs</span>(a0), <span class="bu">abs</span>(a1))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            theta[bit, i] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.arccos(np.<span class="bu">abs</span>(a0) <span class="op">/</span> r) <span class="cf">if</span> r <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            phi[bit, i] <span class="op">=</span> phase(a1) <span class="op">-</span> phase(a0)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            combined[bit, i] <span class="op">=</span> rect(r, (phase(a0) <span class="op">+</span> phase(a1)) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    ...</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Now that we know the rotation angles, we can build the actual circuit. For this, we go from the most to least signifcant bit (we are doing the reverse of what was described earlier), and for each bit, iterate through states of the higher bits and apply the rotations. We implement the controls by inserting NOT gates, so that at the time of each rotation, the state we are looking at is <span class="math inline">\(\ket{1 \dots 1}\)</span>.</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bit <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">**</span> bit):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            diff <span class="op">=</span> i <span class="op">^</span> (i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(bit):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> diff <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (bit <span class="op">-</span> j <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>target[j])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>theta[bit, i], target<span class="op">=</span>target[bit], control<span class="op">=</span>target[:bit])</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.Rz(angle<span class="op">=</span>phi[bit, i], target<span class="op">=</span>target[bit], control<span class="op">=</span>target[:bit])</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Calling this code with a 3-qubit state yields the following circuit:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/prepare_state.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>It performs the correct operation, however there are multi-controlled rotations which will likely be a problem when attempting to run this on real hardware. We could let a compiler take care of this, but we don’t know how efficient that will be. Instead we’ll manually decompose it into single-controlled rotations and Toffoli gates, using our knowledge that there are other qubits in this circuit that we can borrow.</p>
</section>
<section id="decomposing-multi-controlled-rotations" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="decomposing-multi-controlled-rotations"><span class="header-section-number">2.3</span> Decomposing multi-controlled rotations</h2>
<p>If you refer to the overview of the full circuit in the previous chapter, you can see that we only have one additional qubit with a known initialization, the overflow qubit. Unfortunately this is not enough for our purposes, and we’d also like to keep the option of removing the overflow bit when we don’t need it. We could of course simply require additional ancilla qubits, but this would make the circuit more difficult to run. Luckily, we can use a trick described in <span class="citation" data-cites="Gidney_2017"><a href="#ref-Gidney_2017" role="doc-biblioref">[3]</a></span>, which allows us to borrow qubits that are already used for something else and in an unknown state. The only requirement is that this unknown state does not change while they’re borrowed.</p>
<p>For this, we use the fact that <span class="math display">\[ X \cdot R_{Y/Z}(\theta) \cdot X = R_{Y/Z}(-\theta) \]</span> to decompose the circuit in the following way:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/controlled_rotation_decomposition.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>If we have a clean qubit in state <span class="math inline">\(\ket{0}\)</span>, the decomposition is easy: We simply run a multi-controlled NOT on the ancilla qubit, and then use that ancilla as the control for the rotation. Then we repeat the controlled NOT to uncompute the effect on the ancilla.</p>
<p>If we don’t know the state of our ancilla, we run two rotations, one inside the two controlled NOTs, and one outside. This means that if the controlled NOTs are run, exactly one of those rotations gets executed, achieving the desired result. If the controlled NOTs are not run, it depends on the state of the ancilla. If this state is <span class="math inline">\(\ket{0}\)</span>, nothing happens. But if the state is <span class="math inline">\(\ket{1}\)</span>, then both rotations are run. Because of this there are two additional CNOTs, which will in this case flip the second rotation, making them cancel each other out. Note that this also works if the ancilla is in a superposition, since each component of the superposition will reach the same result.</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_controlled_Ry(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    angle: <span class="bu">float</span>,</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    target: <span class="bu">int</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    controls: Sequence[<span class="bu">int</span>],</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(controls) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>angle, target<span class="op">=</span>target, control<span class="op">=</span>controls)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>angle, target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>], controls<span class="op">=</span>controls, ancillae<span class="op">=</span>ancillae[:<span class="op">-</span><span class="dv">1</span>], uncompute<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>angle, target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>], controls<span class="op">=</span>controls, ancillae<span class="op">=</span>ancillae[:<span class="op">-</span><span class="dv">1</span>], uncompute<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>The code for the Z-rotation is the same, simply replace Ry with Rz.</p>
<p>But now, even though we got rid of the multi-controlled rotation, we instead have multi-controlled NOTs, which we can also not directly execute. Luckily we can also resolve this using borrowed ancillae:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/controlled_not_decomposition.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>The idea here is similar to the previous circuit. By running controlled operations twice, interleaved with controlled NOTs, we are independent of the initial state of the qubit.</p>
<p>Note that the last three Toffoli gates in the circuit on the right are only necessary to uncompute the ancillae. In cases where we run this circuit twice, like in the decomposition of the rotation above, this is not necessary, since the two circuits will perform the same bitflips and cancel out.</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_controlled_not(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    target: <span class="bu">int</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    controls: Sequence[<span class="bu">int</span>],</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>],</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    uncompute: <span class="bu">bool</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(controls) <span class="op">&lt;=</span> <span class="dv">2</span>:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tq.gates.X(target<span class="op">=</span>target, control<span class="op">=</span>controls)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    staircase <span class="op">=</span> tq.QCircuit()</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(controls) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        staircase <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[i], second<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">2</span>], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="op">-</span><span class="dv">1</span>], second<span class="op">=</span>ancillae[<span class="bu">len</span>(controls) <span class="op">-</span> <span class="dv">3</span>], target<span class="op">=</span>target)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> staircase.dagger()</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="dv">0</span>], second<span class="op">=</span>controls[<span class="dv">1</span>], target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> staircase</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="op">-</span><span class="dv">1</span>], second<span class="op">=</span>ancillae[<span class="bu">len</span>(controls) <span class="op">-</span> <span class="dv">3</span>], target<span class="op">=</span>target)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> uncompute:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> staircase.dagger()</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="dv">0</span>], second<span class="op">=</span>controls[<span class="dv">1</span>], target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> staircase</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>The Toffoli gates can be directly decomposed into CNOTs and T gates, which we will not do here.</p>
</section>
<section id="gate-count" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="gate-count"><span class="header-section-number">2.4</span> Gate count</h2>
<p>We will now analyze the gate usage of these circuits, counting the rotations and Toffoli gates, as they determine the main cost of running the circuit, and ignoring NOT and CNOT gates.</p>
<p>The multi-controlled NOT decomposition with <span class="math inline">\(c \geq 2\)</span> controls and without uncomputing the result uses <span class="math inline">\(2 + 2 \cdot (c - 3) + 1 = 2 c - 3\)</span> Toffoli gates.</p>
<p>Multi controlled rotations with <span class="math inline">\(c \geq 2\)</span> controls have two such decompositions, so <span class="math inline">\(4 c - 6\)</span> Toffoli gates and two rotations.</p>
<p>For comparison, decomposing multi-controlled NOTs and rotations with <span class="math inline">\(c\)</span> controls using the Tequila <code>compile_circuit</code> function doesn’t require any ancillae but seems to take approximately <span class="math inline">\(2^c\)</span> single qubit rotations and CNOTs each, from some very quick tests.</p>
<p>The part of the PREP circuit operating on the <span class="math inline">\(k\)</span>-th qubit (counting from 1) requires <span class="math inline">\(2^k\)</span> <span class="math inline">\(Y\)</span> and <span class="math inline">\(Z\)</span> rotations, each with <span class="math inline">\(k - 1\)</span> controls. However, if we assume that the coefficients of our state are real and positive, there are no phases so the Z-rotations can be removed. Some of the angles of the Y-rotations might be <span class="math inline">\(0\)</span> too, but we assume here that they are all necessary.</p>
<p>This results in <span class="math inline">\(2^k\)</span> rotations and <span class="math inline">\(2^{k - 1} \cdot (4 \cdot (k - 1) - 6) = 2^k \cdot (2 k - 5)\)</span> Toffoli gates, except for <span class="math inline">\(k \leq 2\)</span> where the decomposition is not necessary, so we get half as many rotations and no Toffoli gates.</p>
<p>Let <span class="math inline">\(D\)</span> be the number of diagonals that we are loading in the PREP operation. Assuming that <span class="math inline">\(D\)</span> is a power of 2 and we are operating on <span class="math inline">\(d = \log_2(D)\)</span> qubits in total, for <span class="math inline">\(d = 1\)</span> we have one rotation, and for <span class="math inline">\(d &gt;= 2\)</span> <span class="math display">\[ 3 + \sum_{k = 3}^{d} 2^k
= 2^{d + 1} - 5
= 2 D - 5 \]</span> rotations. The number of Toffoli gates is <span class="math inline">\(0\)</span> for <span class="math inline">\(d \leq 2\)</span>, and otherwise <span class="math display">\[ \sum_{k = 3}^d 2^k \cdot (2k - 5)
= 2^d \cdot (4 d - 14) + 24
= D \cdot (4 \log_2(D) - 14) + 24 \]</span></p>
<p>The costs are exponential in <span class="math inline">\(d\)</span>, but this is not surprising as the number of values we are loading is exponential in <span class="math inline">\(d\)</span>. More interesting to us is how the cost scales with <span class="math inline">\(D\)</span>. Especially considering that, if we allow cutting off values below some error threshold <span class="math inline">\(\varepsilon\)</span>, we only need <span class="math inline">\(D \in O(\log \varepsilon)\)</span>, we get costs in <span class="math inline">\(O(\log \varepsilon \cdot \log \log \varepsilon)\)</span>.</p>
</section>
</section>
<section id="addition" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Addition</h1>
<p>In this chapter we will implement the second building block we need: An addition circuit that adds the value of a source register to a target register. For this we will follow <span class="citation" data-cites="Takahashi_2009"><a href="#ref-Takahashi_2009" role="doc-biblioref">[4]</a></span>, which introduces the following circuit:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/addition_paper.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>Here <span class="math inline">\(s\)</span> is the sum <span class="math inline">\(a + b\)</span> that we want to calculate. Unfortunately we can’t use the circuit directly, because it expects the source and target register to have the same size. In our case however, the target register might be larger, so we need to adapt it for that.</p>
<section id="allowing-different-register-sizes" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="allowing-different-register-sizes"><span class="header-section-number">3.1</span> Allowing different register sizes</h2>
<p>Instead of applying a NOT operation on a single overflow bit, we want to increment the high bits of the target register.</p>
<p>We cannot simply replace the two controlled NOTs with increment operations, because if both NOTs are executed, they cancel out, but if both increment operations are executed, they increment the value twice. To fix this, we will use a trick from <span class="citation" data-cites="Gidney_2015"><a href="#ref-Gidney_2015" role="doc-biblioref">[5]</a></span>: Similar to the rotations in the previous chapter, an increment operation inverts, i.e.&nbsp;becomes a decrement, when its target bits are flipped before and after the operation.</p>
<p>This works because the bitwise complement of a two’s complement number is almost the negative of the number, more precisely <span class="math inline">\(\overline{a} = -a - 1\)</span>, so <span class="math display">\[ \overline{\overline{a} + 1}
= \overline{-a - 1 + 1}
= \overline{-a}
= a - 1 \]</span></p>
<p>So if we add controlled NOTs to all target registers at the beginning and end of the circuit that run if the first increment will run, then the increments cancel out. If only one of them is running, they will operate correctly.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/addition_increment.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>Next, we need a way to implement an increment operation.</p>
</section>
<section id="increment-gate" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="increment-gate"><span class="header-section-number">3.2</span> Increment gate</h2>
<p>We will first implement an increment circuit that requires n borrowed ancilla qubits, and then improve this to only a single ancilla. Both are taken from <span class="citation" data-cites="Gidney_2015"><a href="#ref-Gidney_2015" role="doc-biblioref">[5]</a></span>.</p>
<p>We start with this subtraction widget, which is a modified version of a VanRentergem adder and subtracts the garbage in a register and a carry bit from the value in another register:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/subtraction_widget.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _subtraction_widget(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    v: Sequence[<span class="bu">int</span>],</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    g: Sequence[<span class="bu">int</span>],</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    c: <span class="bu">int</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> [c] <span class="op">+</span> <span class="bu">list</span>(g)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(v) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i], target<span class="op">=</span>v[i])</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>], target<span class="op">=</span>g[i])</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>g[i], second<span class="op">=</span>v[i], target<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[<span class="op">-</span><span class="dv">1</span>], target<span class="op">=</span>v[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="bu">len</span>(v) <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>g[i], second<span class="op">=</span>v[i], target<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>], target<span class="op">=</span>g[i])</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>], target<span class="op">=</span>v[i])</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Then we apply this widget twice, but toggle the qubits of <span class="math inline">\(g\)</span> around the second time, so the result in the <span class="math inline">\(v\)</span> register will be <span class="math display">\[ v - g - c - (-g - 1) - c
= v - 2 c + 1 \]</span></p>
<p>The result is that if <span class="math inline">\(c = 0\)</span>, we perform an increment, and if <span class="math inline">\(c = 1\)</span>, we perform a decrement. We want to always perform an increment, and we know that we can turn a decrement into an increment by surrounding it with NOTs, so we do that, controlled by c.</p>
<p>As a last detail, because <span class="math inline">\(v\)</span> has one more bit than <span class="math inline">\(g\)</span>, when adding both <span class="math inline">\(g\)</span> and <span class="math inline">\(\overline{g}\)</span>, one of those will be negative, but the sign will act as a normal binary digit, toggling the high bit of <span class="math inline">\(v\)</span>. We can fix this by adding an additional NOT gate on this bit, ending up with the following circuit:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/increment_n_ancillae.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> increment_circuit_n_ancillae(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> target[::<span class="op">-</span><span class="dv">1</span>]  <span class="co"># LSB ordering</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If there are more than n ancillas, ignore them</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> ancillae[:<span class="bu">len</span>(target)]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(v)):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[<span class="dv">0</span>], target<span class="op">=</span>v[i])</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(g)):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>g[i])</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>v[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _subtraction_widget(v, g[<span class="dv">1</span>:], g[<span class="dv">0</span>])</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(g)):</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>g[i])</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _subtraction_widget(v, g[<span class="dv">1</span>:], g[<span class="dv">0</span>])</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(v)):</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[<span class="dv">0</span>], target<span class="op">=</span>v[i])</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Next, we want to improve this from requiring <span class="math inline">\(n\)</span> ancillae, to only one. To do this, we split one large increment gates into two smaller ones, each acting on half of the register, the second one indirectly controlled by the bits of the lower register using the borrowed ancilla. Reducing the size of the increments like this gives us enough unused qubits to use our <span class="math inline">\(n\)</span> ancilla version.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/increment_1_ancilla.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>We already know from the previous chapter how to decompose the multi-controlled NOTs, and have enough unused qubits here. Making a controlled increment is not a problem either, since this is equivalent to a larger increment and a NOT gate.</p>
<p>To see this, note that an increment gate is equivalent to a triangle of multi-controlled NOTs:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/controlled_increment.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>There is one issue left: Since this method increases the size of the increment on the higher bits, if the size of <span class="math inline">\(v\)</span> is even, we are short one ancilla (if it is odd, we split the register so that the more significant half is one qubit smaller). This can be solved by pulling out the largest multi-controlled NOT, decreasing the size of the increment by one.</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> increment_circuit_single_ancilla(</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    ancilla: <span class="bu">int</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a> ) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    split <span class="op">=</span> (<span class="bu">len</span>(target) <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla], ancillae<span class="op">=</span>target[split:])</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancilla)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancilla, target<span class="op">=</span>target[i])</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancilla, controls<span class="op">=</span>target[split:], ancillae<span class="op">=</span>target[:split])</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla], ancillae<span class="op">=</span>target[split:])</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancilla)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancilla, controls<span class="op">=</span>target[split:], ancillae<span class="op">=</span>target[:split])</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancilla, target<span class="op">=</span>target[i])</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The increment is too large, so pull one qubit out of the operation</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>target[split], controls<span class="op">=</span>target[split <span class="op">+</span> <span class="dv">1</span>:], ancillae<span class="op">=</span>target[:split])</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span>target[split <span class="op">+</span> <span class="dv">1</span>:], ancillae<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla])</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_n_ancillae(target[split:], <span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla])</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="implementation-1" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="implementation-1"><span class="header-section-number">3.3</span> Implementation</h2>
<p>Now we have all of the tools we need to implement the addition circuit from the paper, with the changes mentioned above. Finding even a single ancilla is not easy though, since this operation covers every single qubit in our entire circuit, leaving not even borrowable ancillas.</p>
<p>We solve this problem by noting that we don’t need the ancilla for the entire addition circuit, but only during the increment. This increment only touches the last qubit of the s register, so we simply require that it has at least two qubits and use the first as the ancilla. It seems unlikely that we will want to implement a convolution with only two diagonals, so this limitation shouldn’t be an issue.</p>
<p>With this we get the following implementation:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> addition_circuit(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    source: Sequence[<span class="bu">int</span>],</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(source)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Change register to LSB ordering and name them like in the paper.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note that unlike in the paper, A_n does not exist, because of the special handling for larger target registers.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> source[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> target[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>b[i])</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">&gt;</span> n:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_single_ancilla(target<span class="op">=</span><span class="bu">list</span>(b[n:][::<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> [a[n <span class="op">-</span> <span class="dv">1</span>]], ancilla<span class="op">=</span>b[<span class="dv">0</span>])</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="bu">len</span>(b)):</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>b[i])</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>a[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>a[i], second<span class="op">=</span>b[i], target<span class="op">=</span>a[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">&gt;</span> n:</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_single_ancilla(target<span class="op">=</span><span class="bu">list</span>(b[n:][::<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> [a[n <span class="op">-</span> <span class="dv">1</span>], b[n <span class="op">-</span> <span class="dv">1</span>]], ancilla<span class="op">=</span>b[<span class="dv">0</span>])</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>b[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>b[n <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="dv">1</span>, n)):</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>b[i])</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>a[i <span class="op">-</span> <span class="dv">1</span>], second<span class="op">=</span>b[i <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>a[i])</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>a[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>b[i])</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">&gt;</span> n:</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="bu">len</span>(b)):</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>b[i])</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="gate-count-1" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="gate-count-1"><span class="header-section-number">3.4</span> Gate count</h2>
<p>Like before, we will only count Toffoli gates (there are no rotations here).</p>
<p>Our subtraction widget with <span class="math inline">\(n\)</span> qubit registers has <span class="math inline">\(2 (n - 1)\)</span> Toffoli gates.</p>
<p>The n ancilla increment gate uses two such widgets and contains no other Toffoli gates, so <span class="math inline">\(4 n - 4\)</span> Toffoli gates.</p>
<p>The calculation for the one ancilla increment gate depends on the parity of <span class="math inline">\(n\)</span>.</p>
<p>For even <span class="math inline">\(n\)</span>, we need to keep the extra multi-controlled NOT in mind that was pulled out from the increment gate on the less significant bits. The more significant part has <span class="math inline">\(n / 2 - 1\)</span> qubits, and the less significant part has <span class="math inline">\(n / 2 + 1\)</span> qubits, so there are two increment gates on <span class="math inline">\((n / 2 - 1) + 1\)</span> qubits, one on <span class="math inline">\((n / 2 + 1) - 1\)</span> qubits, two NOTs with <span class="math inline">\(n / 2 + 1\)</span> controls and one with <span class="math inline">\((n / 2 + 1) - 1\)</span> controls. Unlike before, we need to uncompute the result of the multi-controlled not, requiring <span class="math inline">\(4c - 8\)</span> Toffoli gates for <span class="math inline">\(c\)</span> controls. This brings the total for the incrementer to <span class="math inline">\(12n - 28\)</span> for <span class="math inline">\(n \geq 6\)</span> (for smaller <span class="math inline">\(n\)</span> the parts into which the register is split become too small for this calculation).</p>
<p>For odd <span class="math inline">\(n\)</span>, the more significant part has <span class="math inline">\((n - 1) / 2\)</span> qubits, and the less significant part <span class="math inline">\((n + 1) / 2\)</span>. So we get two multi-controlled NOTs with <span class="math inline">\((n - 1) / 2\)</span> controls, two increment gates on <span class="math inline">\((n + 1) / 2 + 1\)</span> qubits, and one on <span class="math inline">\((n - 1) / 2\)</span> qubits, for a total of <span class="math inline">\(10 n - 18\)</span> Toffoli gates for <span class="math inline">\(n \geq 5\)</span>.</p>
<p>The adder from <span class="citation" data-cites="Takahashi_2009"><a href="#ref-Takahashi_2009" role="doc-biblioref">[4]</a></span> with registers of size <span class="math inline">\(n\)</span> uses <span class="math inline">\(2 n - 1\)</span> Toffoli gates.</p>
<p>Let <span class="math inline">\(n\)</span> be the size of the source register and <span class="math inline">\(n + k\)</span> the size of the target register. If <span class="math inline">\(k = 0\)</span>, then we remove the Toffoli gate acting on the overflow qubit and get <span class="math inline">\(2 n - 2\)</span> Toffoli gates. If <span class="math inline">\(k &gt; 0\)</span>, we also remove this Toffoli gate, but add a <span class="math inline">\(k + 1\)</span> and a <span class="math inline">\(k + 2\)</span> qubit single-ancilla increment gate, one of which has is an even number of qubits and the other odd. If <span class="math inline">\(k \geq 5\)</span>, we get <span class="math inline">\(2 n + 22 k - 14\)</span> Toffoli gates for even <span class="math inline">\(k\)</span> and <span class="math inline">\(2 n + 22 k - 16\)</span> for odd <span class="math inline">\(k\)</span>.</p>
<p>Even though it is linear, the cost of the modification to allow differently sized registers is high. A more efficient solution would be desirable, especially since our source register will generally be very small due to its exponential cost (as shown in the previous chapter), while the target register might be fairly large.</p>
</section>
</section>
<section id="constant-addition" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Constant Addition</h1>
<p>In this chapter we will build a circuit that, instead of adding a value from another register, simply adds a compile time constant. For this, we will follow <span class="citation" data-cites="Häner_2017"><a href="#ref-Häner_2017" role="doc-biblioref">[6]</a></span>. You might expect that it is easier to only add a single constant, however the problem here is that unlike in the previous chapter, we don’t have the second register to use as temporary working space. This makes this arguable the more difficult operation, which also shows in the asymptotic gate count not being linear but <span class="math inline">\(\Theta(n \log n)\)</span>.</p>
<section id="carry-circuit" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="carry-circuit"><span class="header-section-number">4.1</span> Carry circuit</h2>
<p>The main idea of this algorithm is that if we split the register we are working on in two parts, the only interaction between those is when there is a carry from the less significant to the more significant part. This means that, if we can detect this carry and increment the more significant part when it occurs, we can then work on the two parts separately, halving the size of the operation.</p>
<p>For this, we need the following carry operation:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/carry_gate.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>Depending on the constant <span class="math inline">\(c\)</span> that is added, some of the gates are removed, see <span class="citation" data-cites="Häner_2017"><a href="#ref-Häner_2017" role="doc-biblioref">[6]</a></span> for details.</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _carry_circuit(</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    const: <span class="bu">int</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    carry: <span class="bu">int</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(target)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> const <span class="op">&amp;</span> <span class="dv">1</span>:</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>target[<span class="dv">0</span>], target<span class="op">=</span>carry)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[n <span class="op">-</span> <span class="dv">2</span>], target<span class="op">=</span>carry)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    half <span class="op">=</span> tq.QCircuit()</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="dv">1</span>, n)):</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> const <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i):</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>            half <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>target[i], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            half <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>target[i])</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            half <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">2</span>], second<span class="op">=</span>target[i], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> const <span class="op">&amp;</span> <span class="dv">1</span>:</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>        half <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>target[<span class="dv">0</span>], second<span class="op">=</span>target[<span class="dv">1</span>], target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>        half <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">2</span>], second<span class="op">=</span>target[i], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> half</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[n <span class="op">-</span> <span class="dv">2</span>], target<span class="op">=</span>carry)</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> half.dagger()</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</section>
<section id="implementation-2" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="implementation-2"><span class="header-section-number">4.2</span> Implementation</h2>
<p>This carry operation allows us to split the operation in half like described earlier:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/const_addition.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>Here <span class="math inline">\(x_H\)</span> is the more significant half, and <span class="math inline">\(x_L\)</span> the less significant half of the register, and similarly <span class="math inline">\(c_H\)</span> and <span class="math inline">\(c_L\)</span> are the more and less significant halves of the constant. Even though it looks like it, the carry operation doesn’t act on <span class="math inline">\(x_H\)</span>, only on <span class="math inline">\(x_L\)</span> and the <span class="math inline">\(g\)</span> ancilla.</p>
<p>We can reuse the n-ancilla incrementer from the last chapter here, and like before we have to be careful about the number of ancillae. If the register size is odd, we have exactly the right amount, but if it is even, we are missing one. We could solve this by not splitting the register in half, and instead making the less significant part larger, at the cost of a higher recursion depth. However we already required that the s register consists of at least two qubits in the last chapter, so we can use those as ancillae. One of these qubits can then be used as the additional ancilla we are missing.</p>
<p>Once the recursion reaches a single qubit, the addition operation is simply a NOT gate if <span class="math inline">\(c = 1\)</span>.</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> const_addition_circuit(</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    const: <span class="bu">int</span>,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(target)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> const <span class="op">&amp;</span> <span class="dv">1</span>:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>target[<span class="dv">0</span>])</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">abs</span>(const) <span class="op">&lt;</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">len</span>(ancillae) <span class="op">&gt;=</span> <span class="dv">2</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    split <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancillae[<span class="dv">0</span>]],</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                                      ancillae<span class="op">=</span><span class="bu">list</span>(target[split:]) <span class="op">+</span> [ancillae[<span class="dv">1</span>]])</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[<span class="dv">0</span>], target<span class="op">=</span>target[i])</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _carry_circuit(target<span class="op">=</span>target[split:][::<span class="op">-</span><span class="dv">1</span>], const<span class="op">=</span>const <span class="op">%</span> (<span class="dv">2</span> <span class="op">**</span> (n <span class="op">-</span> split)), carry<span class="op">=</span>ancillae[<span class="dv">0</span>],</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>                        ancillae<span class="op">=</span><span class="bu">list</span>(target[:split]))</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancillae[<span class="dv">0</span>]],</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>                                      ancillae<span class="op">=</span><span class="bu">list</span>(target[split:]) <span class="op">+</span> [ancillae[<span class="dv">1</span>]])</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _carry_circuit(target<span class="op">=</span>target[split:][::<span class="op">-</span><span class="dv">1</span>], const<span class="op">=</span>const <span class="op">%</span> (<span class="dv">2</span> <span class="op">**</span> (n <span class="op">-</span> split)), carry<span class="op">=</span>ancillae[<span class="dv">0</span>],</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>                        ancillae<span class="op">=</span><span class="bu">list</span>(target[:split]))</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[<span class="dv">0</span>], target<span class="op">=</span>target[i])</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> const_addition_circuit(target<span class="op">=</span>target[:split], const<span class="op">=</span>const <span class="op">&gt;&gt;</span> (n <span class="op">-</span> split), ancillae<span class="op">=</span>ancillae)</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> const_addition_circuit(target<span class="op">=</span>target[split:], const<span class="op">=</span>const <span class="op">%</span> (<span class="dv">2</span> <span class="op">**</span> (n <span class="op">-</span> split)), ancillae<span class="op">=</span>ancillae)</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>With this, we have all the building blocks we need for the full circuit that implements a Toeplitz matrix and the convolution.</p>
</section>
<section id="gate-count-2" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="gate-count-2"><span class="header-section-number">4.3</span> Gate count</h2>
<p>Again, we are only counting the Toffoli gates.</p>
<p>From the figure, we can see that the carry operation on an <span class="math inline">\(n\)</span> qubit target register requires <span class="math inline">\(4 n - 6\)</span> Toffoli gates if the lowest bit of the constant is set (otherwise two less) for <span class="math inline">\(n \geq 2\)</span> and none for <span class="math inline">\(n = 1\)</span> (there the circuit is a CNOT).</p>
<p>The constant addition on <span class="math inline">\(n\)</span> qubits contains two <span class="math inline">\(\lceil n / 2 \rceil\)</span> qubit carry gates, two <span class="math inline">\(\lfloor n / 2 \rfloor + 1\)</span> qubit increment gates, and two smaller constant addition circuits with <span class="math inline">\(\lceil n / 2 \rceil\)</span> and <span class="math inline">\(\lfloor n / 2 \rfloor\)</span> qubits. For simplicity, we only calculate the number of gates for powers of two, and assume all bits of the constant are set. Denoting this number as <span class="math inline">\(f(n)\)</span> we get <span class="math display">\[f(n) = \begin{cases}
  0 &amp;\text{ for } n = 1 \\
  8 &amp;\text{ for } n = 2 \\
  8 n - 12 + 2 f(n / 2) \\
  \quad = 8 n \log_2(n) - 10 n + 12 &amp;\text{ for } n &gt; 2
\end{cases} \]</span></p>
</section>
</section>
<section id="integration" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Integration</h1>
<p>Now that we have all the building blocks, we can combine them to implement Toeplitz matrices and Gaussian convolutions.</p>
<section id="toeplitz-matrix" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="toeplitz-matrix"><span class="header-section-number">5.1</span> Toeplitz matrix</h2>
<p>As a reminder, this is the circuit we want to implement:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/full.svg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>We have built all the parts in the previous chapters, but one detail was only mentioned briefly. Let <span class="math inline">\(A_d\)</span> be the diagonals of the Toeplitz matrix. Instead of directly loading the values in PREP and using UNPREP only for combining the different values to a single state, we can follow chapter 2.3 from <span class="citation" data-cites="Sünderhauf_2024"><a href="#ref-Sünderhauf_2024" role="doc-biblioref">[1]</a></span> and choose <span class="math inline">\(p = 1 / 2\)</span> (which is shown there to be optimal), resulting in <span class="math display">\[
\text{PREP} \ket{0}
= \frac{\sum_d \text{sgn}(A_d) \sqrt{|A_d|} \ket{d}}{\sqrt{\sum_d |A_d|}}
\]</span> and <span class="math display">\[
\bra{0} \text{UNPREP}
= \frac{\sum_d \sqrt{|A_d|} \bra{d}}{\sqrt{\sum_d |A_d|}}
\]</span></p>
<p>Implementing the Toeplitz matrix circuit is fairly simple now:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> toeplitz_matrix(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    diags: npt.NDArray[<span class="bu">float</span>],</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>],</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    overflow: Optional[<span class="bu">int</span>],</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    offset: <span class="bu">int</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(target)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">len</span>(ancillae)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> d</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> overflow <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        target <span class="op">=</span> np.append(overflow, target)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    prep_values <span class="op">=</span> np.exp(np.angle(diags) <span class="op">*</span> <span class="ot">1j</span>) <span class="op">*</span> np.sqrt(np.<span class="bu">abs</span>(diags))</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(prep_values), target<span class="op">=</span>ancillae, ancillae<span class="op">=</span>target)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> addition_circuit(source<span class="op">=</span>ancillae, target<span class="op">=</span>target)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> const_addition_circuit(target<span class="op">=</span>target, const<span class="op">=-</span>offset, ancillae<span class="op">=</span>ancillae)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    unprep_values <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(diags))</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(unprep_values), target<span class="op">=</span>ancillae, ancillae<span class="op">=</span>target).dagger()</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>With this, we are at the point where we can implement the example matrix from the first chapter:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>)])</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>overflow <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j, ancillae<span class="op">=</span>s, overflow<span class="op">=</span>overflow, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>...</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>Even this small example results in a fairly large circuit, however that is expected, given the large constant factors in the gate counts:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/complete_circuit.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>At the start there are some redundant gates which could be simplified, this is due to the small circuit size and doesn’t happen for larger circuits. Some of the constructions from the previous chapters would need special handling for small registers to fix this.</p>
<p>A way to verify that this circuit does what it is supposed to is to evaluate it on all the basis states and visualize the resulting matrix. We can also use this opportunity to show the postselection success probability.</p>
<p>For this, it is convenient to write a helper function to encode the input, perform the postselection, and return the result as a Numpy array/matrix instead of a Tequila wavefunction, particularly for when we later want to have multiple dimensions:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eval_circuit(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    states: Union[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    U: tq.QCircuit,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    ranges: Union[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    offsets: Union[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    postselection_mask: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[np.ndarray, <span class="bu">float</span>]:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    state_combined <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(states, <span class="bu">list</span>):</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> state, offset <span class="kw">in</span> <span class="bu">zip</span>(states, offsets):</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>            state_combined <span class="op">|=</span> state <span class="op">&lt;&lt;</span> offset</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        state_combined <span class="op">=</span> states <span class="op">&lt;&lt;</span> offsets</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    wvn <span class="op">=</span> tq.simulate(prepare_basis_state(state_combined, U.n_qubits) <span class="op">+</span> U, backend<span class="op">=</span><span class="st">"qulacs"</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    postselected <span class="op">=</span> {k.integer: v <span class="cf">for</span> k, v <span class="kw">in</span> wvn.state.items() <span class="cf">if</span> k.integer <span class="op">&amp;</span> postselection_mask <span class="op">==</span> <span class="dv">0</span>}</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    angle <span class="op">=</span> np.angle(postselected[<span class="bu">min</span>(postselected.keys())])</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> np.zeros(ranges, dtype<span class="op">=</span>np.complex128)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, val <span class="kw">in</span> postselected.items():</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(ranges, <span class="bu">list</span>):</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> <span class="bu">tuple</span>((i <span class="op">&gt;&gt;</span> offset) <span class="op">%</span> N <span class="cf">for</span> offset, N <span class="kw">in</span> <span class="bu">zip</span>(offsets, ranges))</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> (i <span class="op">&gt;&gt;</span> offsets) <span class="op">%</span> ranges</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> result[index] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Multiple values in the same state with different ancilla states."</span>)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>        result[index] <span class="op">=</span> val <span class="op">*</span> np.exp(<span class="op">-</span>angle <span class="op">*</span> <span class="ot">1j</span>)</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    normalization <span class="op">=</span> np.linalg.norm(result)</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> normalization <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>        result <span class="op">/=</span> normalization</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result, normalization</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>This makes visualizing the result with Pyplot simple:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> j: eval_circuit(states<span class="op">=</span>j, U<span class="op">=</span>U, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b11001</span>), <span class="bu">range</span>(N))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>columns, normalizations <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>results)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>matrix <span class="op">=</span> np.column_stack(columns)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>normalization <span class="op">=</span> np.array(normalizations)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, height_ratios<span class="op">=</span>[N, <span class="dv">1</span>], figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Operation Matrix"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> ax[<span class="dv">0</span>].imshow(np.real(matrix))</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im0, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Postselection Probability"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_visible(<span class="va">False</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> ax[<span class="dv">1</span>].imshow(np.square(normalization).reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>), vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im1, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/example_visualization.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>The top left corner might look wrong at first, but remember that each column has to be normalized, so we can’t get the exact matrix we intended. The third and fourth column are correct because none of the values are cut off, so the postselection has no effect.</p>
<p>We can also remove the overflow flag from the postselection mask to see what happens without it:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/example_visualization_no_overflow.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>This might also look wrong at first, but this is because in a 4x4 matrix with 3 diagonals we only have one diagonal with value zero. The three values in the bottom left are what was cut off before, and now that we are skipping this step, you can see that the diagonals actually all have the same value.</p>
<p>To make the connection to the continuous convolution clearer, we can increase the number of qubits and plot the resulting wavefunction as a graph:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">32</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">15</span>, <span class="dv">16</span>)])</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>overflow <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j, ancillae<span class="op">=</span>s, overflow<span class="op">=</span>overflow, offset<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> eval_circuit(states<span class="op">=</span><span class="dv">32</span>, U<span class="op">=</span>U, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b111110000001</span>)[<span class="dv">0</span>]</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(result))</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"State"</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/graph.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>For comparison, this is what the function <span class="math inline">\(g(x) = \exp((x - 32)^2 / 32)\)</span> looks like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/graph_comparison.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>The only major difference is the scale of the y-Axis, which is due to the normalization of quantum states.</p>
<p>We can also try what happens when we input a state that isn’t a basis state, but some superposition. Usually this superposition would be the result of the previous part of a larger circuit, but in our case we can simply add some Hadamard and NOT gates to get a similar effect. The circuit smooths the input state, as expected from a Gaussian convolution:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">32</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">15</span>, <span class="dv">16</span>)])</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>overflow <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">=</span> tq.QCircuit()</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co"># make sure qubits aren't optimized out</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    prepare <span class="op">+=</span> tq.gates.Rz(angle<span class="op">=</span><span class="dv">0</span>, target<span class="op">=</span>i)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j[<span class="dv">0</span>])</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j[<span class="dv">0</span>])</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j[<span class="dv">1</span>])</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>init, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span><span class="dv">0</span>, U<span class="op">=</span>prepare, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b0</span>)</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j, ancillae<span class="op">=</span>s, overflow<span class="op">=</span>overflow, offset<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>result, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span><span class="dv">0</span>, U<span class="op">=</span>prepare <span class="op">+</span> U, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b111110000001</span>)</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Initialization"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(np.real(init))</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">"State"</span>)</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Result"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(np.real(result))</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">"State"</span>)</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/graph_init.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="gate-count-3" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="gate-count-3"><span class="header-section-number">5.2</span> Gate count</h2>
<p>Let <span class="math inline">\(D\)</span> be the number of diagonals and a power of 2, and <span class="math inline">\(d = log_2(D)\)</span> the size of the s register. Let <span class="math inline">\(n\)</span> be the number of input and output qubits and assume <span class="math inline">\(n + 1\)</span> is a power of 2 and that <span class="math inline">\(n + 1 - d \geq 5\)</span>. The <span class="math inline">\(+1\)</span> is because we also need to consider the overflow gate in the addition operations. Assuming the values of the diagonals are real and non-negative (otherwise the PREP and UNPREP operation would use more gates), we get the following gate counts:</p>
<ul>
<li><span class="math inline">\(2 D - 5\)</span> rotations and <span class="math inline">\(D \cdot (4 \log_2(D) - 14) + 24\)</span> Toffoli gates for the PREP and UNPREP block each</li>
<li><span class="math inline">\(2 d + 22 (n + 1 - d) - 14\)</span> Toffoli gates for the addition or two less if <span class="math inline">\(n + 1 - d\)</span> is odd</li>
<li>up to <span class="math inline">\(8 (n + 1) \log_2(n + 1) - 10 (n + 1) + 12\)</span> Toffoli gates for the constant addition, depending on the constant</li>
</ul>
<p>So the total number of rotations is up to <span class="math inline">\(4 D - 10 \in O(D)\)</span>, and the total number of Toffoli gates is up to <span class="math inline">\(2 D \cdot (4 d - 14) - 20 d + 8 (n + 1) \log_2(n + 1) + 12 n + 58\)</span> <span class="math inline">\(\in O(D \log(D) +n \log(n))\)</span>.</p>
</section>
<section id="postselection-success-probability" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="postselection-success-probability"><span class="header-section-number">5.3</span> Postselection success probability</h2>
<p>Another important factor when considering the cost of this algorithm is subnormalization, which influences the chance that the postselection succeeds, as this will determine how often the algorithm needs to be repeated.</p>
<p>If we don’t postselect the overflow qubit, the implementation here is optimal. This is because the uniform wavefunction <span class="math inline">\(\ket{\psi} = \frac{1}{\sqrt{N}} \sum_{k = 0}^{N - 1} \ket{k}\)</span> is a fixpoint of our algorithm. A Gaussian convolution has a smoothing effect, so if the wavefunction is already completely uniform, there is nothing left for it to do. But here, we are less interested in the shape of the result, and more in the norm. For this we need to multiply the scale of the PREP and UNPREP operations from earlier, which gives us the factor <span class="math inline">\(1 / \sum_d |A_d|\)</span>. However this is the exact value that the result gets from summing the different terms (except for a phase, which doesn’t matter for our uniform wavefunction), so it cancels out, and we get scale <span class="math inline">\(1\)</span>, i.e.&nbsp;a postselection success probability of 100%. This shows that we can’t possibly achieve a lower subnormalization, because then we could map <span class="math inline">\(\ket{\psi}\)</span> to a wavefunction with norm greater than <span class="math inline">\(1\)</span>.</p>
<p>This doesn’t apply with the postselection on the overflow bit, but if we assume that the kernel is much smaller than the wavefunction (which we have to anyways, because of the exponential costs), then only a small number of values is removed, so the norm is still close to <span class="math inline">\(1\)</span>, and the circuit thus close to optimal.</p>
<p>Of course for other wavefunctions the success probability can be much lower or even <span class="math inline">\(0\)</span>, e.g.&nbsp;a quickly oscillating function where the positive and negative parts cancel out when smoothed, but this is due to the operation, not the implementation.</p>
</section>
<section id="multiple-dimensions" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="multiple-dimensions"><span class="header-section-number">5.4</span> Multiple dimensions</h2>
<p>Now that we have implemented the one dimensional case, we can easily extend this to multiple dimensions by simply running the same circuit on multiple registers in parallel:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">4</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">4</span>)])</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>j1 <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>overflow1 <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>j2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>overflow2 <span class="op">=</span> overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>U <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>...</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>This is also the point where wrapping the evaluation in <code>eval_circuit</code> starts to really help, because otherwise dealing with multiple input and output registers quickly becomes hard to read. It also allows to easily parallelize the evaluation of multiple states using the Python <code>multiprocessing</code> module (at the time of writing this helped due to inefficiencies in the Tequila <code>simulate</code> function, but since version 1.9.7 this should no longer be necessary). We will not evaluate every basis state, instead, confirming that it behaves correctly in the center, at the edges and in corners should be sufficient:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">20</span>))</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>offsets <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">15</span>]</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> Pool(<span class="dv">9</span>) <span class="im">as</span> p:</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> p.starmap(eval_circuit, <span class="bu">zip</span>(</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="bu">list</span>(x), product(offsets, offsets)),  <span class="co"># states</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        repeat(U),  <span class="co"># U</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        repeat([N, N]),  <span class="co"># ranges</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        repeat([<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>]),  <span class="co"># offsets</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        repeat(<span class="bn">0b1110000111100001</span>),  <span class="co"># postselection mask</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    matrices, normalizations <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>results)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> plot_i, plot_j <span class="kw">in</span> product(<span class="bu">range</span>(<span class="dv">3</span>), <span class="bu">range</span>(<span class="dv">3</span>)):</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        im <span class="op">=</span> ax[plot_i, plot_j].imshow(np.real(matrices[<span class="dv">3</span> <span class="op">*</span> plot_i <span class="op">+</span> plot_j]))</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        fig.colorbar(im, ax<span class="op">=</span>ax[plot_i, plot_j])</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/example_visualization_two_dim.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>We can again add some initialization code to see how the circuit operates on other input:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">4</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">4</span>)])</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>j1 <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>overflow1 <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>j2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>overflow2 <span class="op">=</span> overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">=</span> tq.QCircuit()</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># make sure qubits aren't optimized out</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> (n <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    prepare <span class="op">+=</span> tq.gates.Rx(angle<span class="op">=</span><span class="dv">0</span>, target<span class="op">=</span>i)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j1[<span class="dv">1</span>])</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j2[<span class="dv">0</span>])</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j2[<span class="dv">1</span>])</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>init, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>prepare, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>], postselection_mask<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> prepare <span class="op">+</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>U <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>result, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>U, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>],</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>                         postselection_mask<span class="op">=</span><span class="bn">0b1110000111100001</span>)</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Initialization"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> ax[<span class="dv">0</span>].imshow(np.real(init))</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im0, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Result"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> ax[<span class="dv">1</span>].imshow(np.real(result))</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im1, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/example_visualization_init.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>In this example, you could also ignore the postselection because no values wrap around, so it doesn’t have any effect.</p>
</section>
<section id="lcu" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="lcu"><span class="header-section-number">5.5</span> LCU</h2>
<p>Lastly, we will see how to use a linear combination of unitaries to implement a weighted sum of Gaussian convolutions. This is not part of the algorithm, so we will only look at this briefly, but it seems likely that usecases of Gaussian convolutions will require it, and it is fairly simple with the tools developed already.</p>
<p>We will use the method described in <span class="citation" data-cites="Guala_2015"><a href="#ref-Guala_2015" role="doc-biblioref">[7]</a></span>. The PREP block there is the same block we built in the second chapter, and the selection operator can be implemented in the same way as the multi controlled rotations in the PREP operator, so we get the following code:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lcu(</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    circuits: Sequence[tq.QCircuit],</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    coefficients: npt.NDArray[<span class="bu">float</span>],</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    flags: Sequence[<span class="bu">int</span>],</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    flags <span class="op">=</span> flags[:ceil(log2(<span class="bu">len</span>(circuits)))]</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    prep_values <span class="op">=</span> np.exp(np.angle(coefficients) <span class="op">*</span> <span class="ot">1j</span>) <span class="op">*</span> np.sqrt(np.<span class="bu">abs</span>(coefficients))</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(prep_values), target<span class="op">=</span>flags, ancillae<span class="op">=</span>ancillae)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (circuit, coefficient) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(circuits, coefficients)):</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> i <span class="op">^</span> (i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(flags)):</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> diff <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j):</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>                U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>flags[<span class="op">-</span>j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> circuit.add_controls(flags)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle the case that the number of circuits is not a power of 2</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(flags)):</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (<span class="bu">len</span>(circuits) <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j):</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>flags[<span class="op">-</span>j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    unprep_values <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(coefficients))</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(unprep_values), target<span class="op">=</span>flags, ancillae<span class="op">=</span>ancillae).dagger()</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>As a simple example, we can reuse the previous two dimensional circuit, but add a second convolution with the same values but slightly shifted. We give a negative coefficient to this new convolution, and double the weight of the original convolution:</p>
<details>
<summary>
Code
</summary>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">4</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">4</span>)])</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>j1 <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>overflow1 <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>j2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>overflow2 <span class="op">=</span> overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>lcu_flag <span class="op">=</span> overflow2 <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">=</span> tq.QCircuit()</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="co"># make sure qubits aren't optimized out</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> (n <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    prepare <span class="op">+=</span> tq.gates.Rx(angle<span class="op">=</span><span class="dv">0</span>, target<span class="op">=</span>i)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j1[<span class="dv">1</span>])</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j2[<span class="dv">0</span>])</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j2[<span class="dv">1</span>])</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>init, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>prepare, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>], postselection_mask<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>U1 <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>U1 <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>U2 <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>U2 <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> prepare <span class="op">+</span> lcu(circuits<span class="op">=</span>[U1, U2], coefficients<span class="op">=</span>np.array([<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>]), flags<span class="op">=</span>[lcu_flag], ancillae<span class="op">=</span><span class="bu">range</span>(lcu_flag))</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>result, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>U, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">2</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">3</span>],</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>                         postselection_mask<span class="op">=</span><span class="bn">0b11100001111000011</span>)</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Initialization"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> ax[<span class="dv">0</span>].imshow(np.real(init))</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im0, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Result"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> ax[<span class="dv">1</span>].imshow(np.real(result))</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im1, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/lcu_example.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</section>
<section id="conclusion" class="level2" data-number="5.6">
<h2 data-number="5.6" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">5.6</span> Conclusion</h2>
<p>In this post, we have seen how we can implement a Gaussian convolution on a quantum superposition. For this we developed circuits which can prepare arbitrary states, add a value in a register to another register, and add a constant to a register. Combining these three operations allowed us to implement any Toeplitz matrix, including one dimensional Gaussian convolutions. Since Gaussian convolutions are separable, we were able to simply run this algorithm multiple times in parallel to extend it to multiple dimensions. We have also briefly seen that it is possibly to combine multiple convolutions to weighted sums of convolutions.</p>
<p>To be efficient, we need to approximate the convolution by cutting it off after a certain number of values, but this should rarely be an issue because of how quickly the coefficients of a Gaussian convolution drop towards <span class="math inline">\(0\)</span>. We achieved asymptotic rotation and Toffoli gate count of <span class="math inline">\(O(D \log(D) + n \log(n))\)</span> for the one dimensional convolution, where <span class="math inline">\(D\)</span> is the number of values that are considered, and <span class="math inline">\(n\)</span> is the number of input and output qubits. By borrowing qubits which are already in use, the algorithm is able to avoid using dedicated ancilla qubits in most places.</p>
<p>Despite these favourable characteristics, there is likely to be much room for optimization, particularly for the large constant factors. Also the decompositions here focused on Toffoli gates, it would be interesting to see what costs can be achieved with different operations instead, like single qubit rotations and CNOTs.</p>
</section>
<section id="references" class="level2" data-number="5.7">
<h2 data-number="5.7" class="anchored" data-anchor-id="references"><span class="header-section-number">5.7</span> References</h2>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-Sünderhauf_2024" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">C. Sünderhauf, E. Campbell, and J. Camps, <span>“Block-encoding structured matrices for data input in quantum computing,”</span> <em>Quantum</em>, vol. 8, p. 1226, Jan. 2024, doi: <a href="https://doi.org/10.22331/q-2024-01-11-1226">10.22331/q-2024-01-11-1226</a>.</div>
</div>
<div id="ref-Shende_2006" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">V. V. Shende, S. S. Bullock, and I. L. Markov, <span>“Synthesis of quantum-logic circuits,”</span> <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</em>, vol. 25, no. 6, pp. 1000–1010, Jun. 2006, doi: <a href="https://doi.org/10.1109/tcad.2005.855930">10.1109/tcad.2005.855930</a>.</div>
</div>
<div id="ref-Gidney_2017" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">C. Gidney, <span>“Trouble adding constants into qubit registers.”</span> Accessed: May 31, 2024. [Online]. Available: <a href="https://algassert.com/post/1701">https://algassert.com/post/1701</a></div>
</div>
<div id="ref-Takahashi_2009" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">Y. Takahashi, S. Tani, and N. Kunihiro, <span>“Quantum addition circuits and unbounded fan-out.”</span> 2009. Available: <a href="https://arxiv.org/abs/0910.2530">https://arxiv.org/abs/0910.2530</a></div>
</div>
<div id="ref-Gidney_2015" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">C. Gidney, <span>“Constructing large increment gates.”</span> Accessed: May 31, 2024. [Online]. Available: <a href="https://algassert.com/circuits/2015/06/12/Constructing-Large-Increment-Gates.html">https://algassert.com/circuits/2015/06/12/Constructing-Large-Increment-Gates.html</a></div>
</div>
<div id="ref-Häner_2017" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">T. Häner, M. Roetteler, and K. M. Svore, <span>“Factoring using 2n+2 qubits with toffoli based modular multiplication.”</span> 2017. Available: <a href="https://arxiv.org/abs/1611.07995">https://arxiv.org/abs/1611.07995</a></div>
</div>
<div id="ref-Guala_2015" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">D. Guala, J. Soni, and J. M. Arrazola, <span>“Linear combination of unitaries and block encodings.”</span> Accessed: Jun. 16, 2024. [Online]. Available: <a href="https://pennylane.ai/qml/demos/tutorial_lcu_blockencoding/">https://pennylane.ai/qml/demos/tutorial_lcu_blockencoding/</a></div>
</div>
</div>
<p>The bibliography uses a citation style file from the CSL project: <a href="https://citationstyles.org/">https://citationstyles.org/</a></p>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="tequilahub/tequila-tutorials" issue-term="pathname" theme="preferred-color-scheme" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb22" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Building a Quantum Circuit for Gaussian Convolutions"</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Oliver Hüttenhofer"</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "2024-11-23"</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> "img/thumbnail.jpg"</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="an">number-sections:</span><span class="co"> true</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="an">csl:</span><span class="co"> ieee.csl</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co">  eval: false</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="fu"># Overview</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>This post shows how to use Tequila to implement a quantum circuit which performs a Gaussian convolution.</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>The first chapter will give an overview over the structure that the circuit will have, and divide it into smaller subproblems which can be implemented separately.</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>These implementations will be described in the next chapters, and combined into the final circuit at the end.</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="fu">## Goal</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>A Gaussian Convolution has an impulse response that is a Gaussian function $g(x) = a \cdot \exp\left(-||x - b||_2^2 / c \right)$, so when applied to a function $f: \mathbb{R}^d \to \mathbb{R}^d$, it yields a new function</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>$$ (f * g)(i) = \int_{\mathbb{R}^d} f(j) \cdot g(i - j) dj $$</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>Note that $g$ is separable, so even if we are interested in high-dimensional functions, it is sufficient to consider the one-dimensional case for now.</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>We can then run the one-dimensional implementation multiple times on separate qubits to get a multi-dimensional implementation.</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>To implement this on a quantum computer, we want a circuit that instead of a function $f$ takes a state $\ket{\psi} = \sum_{k = 0}^{N - 1} \alpha_i \ket{i}$ on $n$ qubits with $N = 2^n$, and outputs the state</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>$$ U \ket{\psi}</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>= \ket{\psi} * g</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>= z \cdot \sum_{i = 0}^{N - 1} \left(\sum_{j = 0}^{N - 1} \alpha_j \cdot g(i - j)\right) \ket{i} $$</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>for some normalization factor $z$.</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>For a basis state $\ket{\psi} = \ket{j}$, this gives us</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>$$ U \ket{j}</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>= z \cdot \sum_{i = 0}^{N - 1} g(i - j) \ket{i}</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>= z \cdot \sum_{i = 0}^{N - 1} \exp(-(i - j - b)^2 / c) \ket{i} $$</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>where $z$ might be a different normalization factor than before and might depend on $j$.</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>Because the result will be normalized, $a$ does not have any effect and can be ignored.</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>We will also have to make an approximation to implement this efficiently, as we will see in the next section.</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a><span class="fu">## High-level circuit</span></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>Now we need to find a way to embed this operation into a quantum circuit.</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>To do this, notice that the matrix representation is a Toeplitz matrix, i.e. a matrix where elements on the same diagonal have the same value.</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>For example, with $n = 2$, $b = -1$ and $c = 1$, it would be</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a>$$ A = \begin{pmatrix}</span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a>e^{-1} &amp; 1 &amp; e^{-1} &amp; e^{-4} <span class="sc">\\</span></span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>e^{-4} &amp; e^{-1} &amp; 1 &amp; e^{-1} <span class="sc">\\</span></span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a>e^{-9} &amp; e^{-4} &amp; e^{-1} &amp; 1 <span class="sc">\\</span></span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a>e^{-16} &amp; e^{-9} &amp; e^{-4} &amp; e^{-1} <span class="sc">\\</span></span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a>\end{pmatrix} $$</span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a>We can follow @Sünderhauf_2024 to implement this, however because we will have to load the value of each diagonal separately, we need to limit the number of diagonals to make this efficient.</span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a>Luckily this is not an issue if we can tolerate some small error, since the values decrease exponentially in the distance, the number of diagonals only need to be logarithmic in the cutoff value.</span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-62"><a href="#cb22-62" aria-hidden="true" tabindex="-1"></a>In our example, we could limit it to three diagonals, ignoring values $\leq e^{-4}$, resulting in the following matrix representation:</span>
<span id="cb22-63"><a href="#cb22-63" aria-hidden="true" tabindex="-1"></a>$$ A' = \begin{pmatrix}</span>
<span id="cb22-64"><a href="#cb22-64" aria-hidden="true" tabindex="-1"></a>e^{-1} &amp; 1 &amp; e^{-1} &amp; 0 <span class="sc">\\</span></span>
<span id="cb22-65"><a href="#cb22-65" aria-hidden="true" tabindex="-1"></a>0 &amp; e^{-1} &amp; 1 &amp; e^{-1} <span class="sc">\\</span></span>
<span id="cb22-66"><a href="#cb22-66" aria-hidden="true" tabindex="-1"></a>0 &amp; 0 &amp; e^{-1} &amp; 1 <span class="sc">\\</span></span>
<span id="cb22-67"><a href="#cb22-67" aria-hidden="true" tabindex="-1"></a>0 &amp; 0 &amp; 0 &amp; e^{-1} <span class="sc">\\</span></span>
<span id="cb22-68"><a href="#cb22-68" aria-hidden="true" tabindex="-1"></a>\end{pmatrix} $$</span>
<span id="cb22-69"><a href="#cb22-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-70"><a href="#cb22-70" aria-hidden="true" tabindex="-1"></a>Then we can build the following circuit, where $\ket{0} \bra{0}$ indicates postselecting the register as $\ket{0 \dots 0}$, i.e. rerunning the algorithm until a measurement of this register yields only zeros:</span>
<span id="cb22-71"><a href="#cb22-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-72"><a href="#cb22-72" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/full.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-73"><a href="#cb22-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-74"><a href="#cb22-74" aria-hidden="true" tabindex="-1"></a>First, we use a PREP operation which can initialize any arbitrary state to load a single column of values onto the s register, in this example this would be</span>
<span id="cb22-75"><a href="#cb22-75" aria-hidden="true" tabindex="-1"></a>$$ \begin{align}</span>
<span id="cb22-76"><a href="#cb22-76" aria-hidden="true" tabindex="-1"></a>\text{PREP} \ket{0}^{\otimes 2}</span>
<span id="cb22-77"><a href="#cb22-77" aria-hidden="true" tabindex="-1"></a>= z \cdot \begin{pmatrix} e^{-1} <span class="sc">\\</span> 1 <span class="sc">\\</span> e^{-1} <span class="sc">\\</span> 0 \end{pmatrix}</span>
<span id="cb22-78"><a href="#cb22-78" aria-hidden="true" tabindex="-1"></a>= z \cdot (e^{-1} \ket{0} + \ket{1} + e^{-1} \ket{2}) <span class="sc">\\</span></span>
<span id="cb22-79"><a href="#cb22-79" aria-hidden="true" tabindex="-1"></a>= z \cdot \sum_{k = 0}^2 e^{-(k - 1)^2} \ket{k}</span>
<span id="cb22-80"><a href="#cb22-80" aria-hidden="true" tabindex="-1"></a>= z \cdot \sum_{k = 0}^2 g(k - 2) \ket{k}</span>
<span id="cb22-81"><a href="#cb22-81" aria-hidden="true" tabindex="-1"></a>\end{align}$$</span>
<span id="cb22-82"><a href="#cb22-82" aria-hidden="true" tabindex="-1"></a>with some normalization factor $z$.</span>
<span id="cb22-83"><a href="#cb22-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-84"><a href="#cb22-84" aria-hidden="true" tabindex="-1"></a>Then we use an addition operation to add the state from the s register to the j register, which contains the input of the algorithm.</span>
<span id="cb22-85"><a href="#cb22-85" aria-hidden="true" tabindex="-1"></a>This essentially copies the state initialized by PREP onto the register, but shifted by the incoming value (it copies in the sense that a CNOT gate copies a bit, not in the sense that violates the no-cloning theorem).</span>
<span id="cb22-86"><a href="#cb22-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-87"><a href="#cb22-87" aria-hidden="true" tabindex="-1"></a>Next, we subtract some constant $k$ to add an offset from the main diagonal.</span>
<span id="cb22-88"><a href="#cb22-88" aria-hidden="true" tabindex="-1"></a>If we are considering $2 \cdot m + 1$ diagonals, and the main diagonal with value $1$ is in the center, that means there are $m$ diagonals above that. Then $k = m - b$, so in this example $k = 2$.</span>
<span id="cb22-89"><a href="#cb22-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-90"><a href="#cb22-90" aria-hidden="true" tabindex="-1"></a>The overflow qubit is treated as an additional high bit of the j register, and indicates that the two additions overflowed and caused values to wrap around the matrix.</span>
<span id="cb22-91"><a href="#cb22-91" aria-hidden="true" tabindex="-1"></a>By postselecting it as $\ket{0}$, those values can be filtered out.</span>
<span id="cb22-92"><a href="#cb22-92" aria-hidden="true" tabindex="-1"></a>This part can be removed to optimize the circuit, if overflows are impossible or tolerable.</span>
<span id="cb22-93"><a href="#cb22-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-94"><a href="#cb22-94" aria-hidden="true" tabindex="-1"></a>At the end we perform an UNPREP operation on the s register, which is in this case equivalent to a Hadamard gate on each qubit.</span>
<span id="cb22-95"><a href="#cb22-95" aria-hidden="true" tabindex="-1"></a>The register is then postselected as $\ket{0}^{\otimes n}$.</span>
<span id="cb22-96"><a href="#cb22-96" aria-hidden="true" tabindex="-1"></a>This applies the first row of the matrix representation of $H^{\otimes n}$, which contains only ones, i.e. builds a sum of the input values, combining the different values in the s register into a single state.</span>
<span id="cb22-97"><a href="#cb22-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-98"><a href="#cb22-98" aria-hidden="true" tabindex="-1"></a>An alternative way of looking at this is as a linear combination of unitaries, where each of the unitaries is one of the diagonals.</span>
<span id="cb22-99"><a href="#cb22-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-100"><a href="#cb22-100" aria-hidden="true" tabindex="-1"></a>Denoting the addition gates in square brackets, and $\ket{0}_s \bra{0}_s$ as the postselection / projection on the $\ket{0}^{\otimes d}$ state on the s register, the result of the circuit is:</span>
<span id="cb22-101"><a href="#cb22-101" aria-hidden="true" tabindex="-1"></a>$$ \begin{align}</span>
<span id="cb22-102"><a href="#cb22-102" aria-hidden="true" tabindex="-1"></a>\ket{0}_s \bra{0}_s U \left(\ket{0} \otimes \ket{j} \otimes \ket{0}\right)</span>
<span id="cb22-103"><a href="#cb22-103" aria-hidden="true" tabindex="-1"></a>=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} \cdot <span class="co">[</span><span class="ot">-2</span><span class="co">]</span> \cdot <span class="co">[</span><span class="ot">+d</span><span class="co">]</span> \cdot \text{PREP} <span class="sc">\\</span></span>
<span id="cb22-104"><a href="#cb22-104" aria-hidden="true" tabindex="-1"></a>&amp;\quad \cdot \left(\ket{0} \otimes \ket{j} \otimes \ket{0}\right) <span class="sc">\\</span><span class="co">[</span><span class="ot">0.5em</span><span class="co">]</span></span>
<span id="cb22-105"><a href="#cb22-105" aria-hidden="true" tabindex="-1"></a>=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} \cdot <span class="co">[</span><span class="ot">-2</span><span class="co">]</span> \cdot <span class="co">[</span><span class="ot">+d</span><span class="co">]</span> <span class="sc">\\</span></span>
<span id="cb22-106"><a href="#cb22-106" aria-hidden="true" tabindex="-1"></a>&amp;\quad \cdot \left(z \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{k} \otimes \ket{j} \otimes \ket{0}\right) <span class="sc">\\</span><span class="co">[</span><span class="ot">0.5em</span><span class="co">]</span></span>
<span id="cb22-107"><a href="#cb22-107" aria-hidden="true" tabindex="-1"></a>=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} \cdot <span class="co">[</span><span class="ot">-2</span><span class="co">]</span> <span class="sc">\\</span></span>
<span id="cb22-108"><a href="#cb22-108" aria-hidden="true" tabindex="-1"></a>&amp;\quad \cdot \left(z \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{k} \otimes \ket{(k + j) \text{ mod } 4} \otimes \ket{\text{overflow}}\right) <span class="sc">\\</span><span class="co">[</span><span class="ot">0.5em</span><span class="co">]</span></span>
<span id="cb22-109"><a href="#cb22-109" aria-hidden="true" tabindex="-1"></a>=&amp; \ket{0}_s \bra{0}_s \text{UNPREP} <span class="sc">\\</span></span>
<span id="cb22-110"><a href="#cb22-110" aria-hidden="true" tabindex="-1"></a>&amp;\quad \cdot \left( z \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{k} \otimes \ket{(k + j - 2) \text{ mod } 4} \otimes \ket{\text{overflow}} \right) <span class="sc">\\</span><span class="co">[</span><span class="ot">0.5em</span><span class="co">]</span></span>
<span id="cb22-111"><a href="#cb22-111" aria-hidden="true" tabindex="-1"></a>=&amp; \widetilde{z} \cdot \sum_{k = 0}^2 g(k - 2) \cdot \ket{0} \otimes \ket{(k + j - 2) \text{ mod } 4} \otimes \ket{\text{overflow}} <span class="sc">\\</span><span class="co">[</span><span class="ot">0.5em</span><span class="co">]</span></span>
<span id="cb22-112"><a href="#cb22-112" aria-hidden="true" tabindex="-1"></a>\overset{i = k + j - 2}{=}&amp; \widetilde{z} \cdot \ket{0} \otimes \sum_{i = j - 2}^{j} g(i - j) \cdot \ket{i \text{ mod } 4} \otimes \ket{\text{overflow}}</span>
<span id="cb22-113"><a href="#cb22-113" aria-hidden="true" tabindex="-1"></a>\end{align} $$</span>
<span id="cb22-114"><a href="#cb22-114" aria-hidden="true" tabindex="-1"></a>for some normalization factor $\widetilde{z}$.</span>
<span id="cb22-115"><a href="#cb22-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-116"><a href="#cb22-116" aria-hidden="true" tabindex="-1"></a>After postselecting the overflow bit as $\ket{0}$, the values where the modulo operation has an effect are removed, so the sum will run from $i = \max(j - 2, 0)$ to $i = \min(j, 3) = j$, and the middle register contains the desired results.</span>
<span id="cb22-117"><a href="#cb22-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-118"><a href="#cb22-118" aria-hidden="true" tabindex="-1"></a>The PREP and UNPREP operation here correspond to chosing $p = 1$ in chapter 2.3 of @Sünderhauf_2024.</span>
<span id="cb22-119"><a href="#cb22-119" aria-hidden="true" tabindex="-1"></a>This makes the calculation easier to follow, however the paper shows that chosing $p = 1 / 2$ is better because it decreases the subnormalization, increasing the success rate of the postselection without changing the result of the circuit, so this is what we will do in the implementation.</span>
<span id="cb22-120"><a href="#cb22-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-121"><a href="#cb22-121" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb22-122"><a href="#cb22-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-123"><a href="#cb22-123" aria-hidden="true" tabindex="-1"></a>We have seen that we can build a quantum circuit which implements a Gaussian convolution from three building blocks:</span>
<span id="cb22-124"><a href="#cb22-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-125"><a href="#cb22-125" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>A PREP block, which can initialize arbitrary states (which can also be used for the UNPREP block)</span>
<span id="cb22-126"><a href="#cb22-126" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>An addition block which can add a value from one register to another</span>
<span id="cb22-127"><a href="#cb22-127" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>An addition block which can add a compile time constant to a register</span>
<span id="cb22-128"><a href="#cb22-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-129"><a href="#cb22-129" aria-hidden="true" tabindex="-1"></a>In the next chapters, we will see how to build these subcircuits, and at the end we will combine them to the full circuit.</span>
<span id="cb22-130"><a href="#cb22-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-131"><a href="#cb22-131" aria-hidden="true" tabindex="-1"></a><span class="fu"># State Preparation</span></span>
<span id="cb22-132"><a href="#cb22-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-133"><a href="#cb22-133" aria-hidden="true" tabindex="-1"></a>To implement the preparation of arbitrary states, we will follow chapter 4 from @Shende_2006.</span>
<span id="cb22-134"><a href="#cb22-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-135"><a href="#cb22-135" aria-hidden="true" tabindex="-1"></a><span class="fu">## Core Idea</span></span>
<span id="cb22-136"><a href="#cb22-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-137"><a href="#cb22-137" aria-hidden="true" tabindex="-1"></a>To illustrate the idea, we will consider the reverse of what we actually want to do: </span>
<span id="cb22-138"><a href="#cb22-138" aria-hidden="true" tabindex="-1"></a>Assume that we get some arbitrary (but determined at compile time) state $\ket{\psi}$, and need to transform it to $\ket{0}^{\otimes n}$.</span>
<span id="cb22-139"><a href="#cb22-139" aria-hidden="true" tabindex="-1"></a>If we can do this, we can simply run the inverse of the circuit to go from $\ket{0}^{\otimes n}$ to $\ket{\psi}$.</span>
<span id="cb22-140"><a href="#cb22-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-141"><a href="#cb22-141" aria-hidden="true" tabindex="-1"></a>For a single-qubit state this is easily done via a Z-rotation followed by a Y-rotation.</span>
<span id="cb22-142"><a href="#cb22-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-143"><a href="#cb22-143" aria-hidden="true" tabindex="-1"></a>If we instead have a multi-qubit state on $n$ qubits, we can write it in the following way:</span>
<span id="cb22-144"><a href="#cb22-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-145"><a href="#cb22-145" aria-hidden="true" tabindex="-1"></a>$$ \ket{\psi}</span>
<span id="cb22-146"><a href="#cb22-146" aria-hidden="true" tabindex="-1"></a>= \sum_{k = 0}^{2^{n - 1} - 1} c_k \ket{k} \otimes \ket{\psi_k} $$</span>
<span id="cb22-147"><a href="#cb22-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-148"><a href="#cb22-148" aria-hidden="true" tabindex="-1"></a>Here, $\ket{k}$ are the basis states of the first $n - 1$ qubits, $c_k$ some coefficients, and $\ket{\psi_k}$ are single qubit states on the last qubit.</span>
<span id="cb22-149"><a href="#cb22-149" aria-hidden="true" tabindex="-1"></a>With this formulation, we can apply our earlier single qubit approach to each $\ket{\psi_k}$ individually by using multi-controlled rotations, and turning this state into</span>
<span id="cb22-150"><a href="#cb22-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-151"><a href="#cb22-151" aria-hidden="true" tabindex="-1"></a>$$ \sum_{k = 0}^{2^{n - 1} - 1} c_k \ket{k} \otimes \ket{0}</span>
<span id="cb22-152"><a href="#cb22-152" aria-hidden="true" tabindex="-1"></a>= \left(\sum_{k = 0}^{2^{n - 1} - 1} c_k \ket{k}\right) \otimes \ket{0} $$</span>
<span id="cb22-153"><a href="#cb22-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-154"><a href="#cb22-154" aria-hidden="true" tabindex="-1"></a>So we have successfully unentangled the last qubit from the rest of the state.</span>
<span id="cb22-155"><a href="#cb22-155" aria-hidden="true" tabindex="-1"></a>This can now be recursively repeated for the remaining $n - 1$ qubits, until all of them are in the state $\ket{0}$.</span>
<span id="cb22-156"><a href="#cb22-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-157"><a href="#cb22-157" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implementation</span></span>
<span id="cb22-158"><a href="#cb22-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-159"><a href="#cb22-159" aria-hidden="true" tabindex="-1"></a>To make the calculation of the angles efficient, we have to go from least to most signficant bit, allowing us to reuse results from lower bits for the calculation of higher bits.</span>
<span id="cb22-160"><a href="#cb22-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-161"><a href="#cb22-161" aria-hidden="true" tabindex="-1"></a>Then we go through all the possible basis states $i$ of the higher bits, and consider the coefficients $a_0 \ket{0} + a_1 \ket{1}$ where the higher bits are in state $i$.</span>
<span id="cb22-162"><a href="#cb22-162" aria-hidden="true" tabindex="-1"></a>This allows us to calculate the relative magnitude and phase of these two coefficients, giving us the angles $\theta$ and $\varphi$ for the rotations.</span>
<span id="cb22-163"><a href="#cb22-163" aria-hidden="true" tabindex="-1"></a>But we also need to calculate the "combined" coefficient, which will then be used for the next higher bit.</span>
<span id="cb22-164"><a href="#cb22-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-165"><a href="#cb22-165" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-166"><a href="#cb22-166" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-167"><a href="#cb22-167" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-168"><a href="#cb22-168" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prepare_state(</span>
<span id="cb22-169"><a href="#cb22-169" aria-hidden="true" tabindex="-1"></a>    state: npt.NDArray[<span class="bu">float</span>],</span>
<span id="cb22-170"><a href="#cb22-170" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>]</span>
<span id="cb22-171"><a href="#cb22-171" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-172"><a href="#cb22-172" aria-hidden="true" tabindex="-1"></a>    theta <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb22-173"><a href="#cb22-173" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb22-174"><a href="#cb22-174" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb22-175"><a href="#cb22-175" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bit <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(n)):</span>
<span id="cb22-176"><a href="#cb22-176" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">**</span> bit):</span>
<span id="cb22-177"><a href="#cb22-177" aria-hidden="true" tabindex="-1"></a>            a0 <span class="op">=</span> state[<span class="dv">2</span> <span class="op">*</span> i] <span class="cf">if</span> bit <span class="op">==</span> n <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> combined[bit <span class="op">+</span> <span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> i]</span>
<span id="cb22-178"><a href="#cb22-178" aria-hidden="true" tabindex="-1"></a>            a1 <span class="op">=</span> state[<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>] <span class="cf">if</span> bit <span class="op">==</span> n <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> combined[bit <span class="op">+</span> <span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb22-179"><a href="#cb22-179" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> hypot(<span class="bu">abs</span>(a0), <span class="bu">abs</span>(a1))</span>
<span id="cb22-180"><a href="#cb22-180" aria-hidden="true" tabindex="-1"></a>            theta[bit, i] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> np.arccos(np.<span class="bu">abs</span>(a0) <span class="op">/</span> r) <span class="cf">if</span> r <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb22-181"><a href="#cb22-181" aria-hidden="true" tabindex="-1"></a>            phi[bit, i] <span class="op">=</span> phase(a1) <span class="op">-</span> phase(a0)</span>
<span id="cb22-182"><a href="#cb22-182" aria-hidden="true" tabindex="-1"></a>            combined[bit, i] <span class="op">=</span> rect(r, (phase(a0) <span class="op">+</span> phase(a1)) <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb22-183"><a href="#cb22-183" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb22-184"><a href="#cb22-184" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-185"><a href="#cb22-185" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-186"><a href="#cb22-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-187"><a href="#cb22-187" aria-hidden="true" tabindex="-1"></a>Now that we know the rotation angles, we can build the actual circuit.</span>
<span id="cb22-188"><a href="#cb22-188" aria-hidden="true" tabindex="-1"></a>For this, we go from the most to least signifcant bit (we are doing the reverse of what was described earlier), and for each bit, iterate through states of the higher bits and apply the rotations.</span>
<span id="cb22-189"><a href="#cb22-189" aria-hidden="true" tabindex="-1"></a>We implement the controls by inserting NOT gates, so that at the time of each rotation, the state we are looking at is $\ket{1 \dots 1}$.</span>
<span id="cb22-190"><a href="#cb22-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-191"><a href="#cb22-191" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-192"><a href="#cb22-192" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-193"><a href="#cb22-193" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-194"><a href="#cb22-194" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb22-195"><a href="#cb22-195" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-196"><a href="#cb22-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-197"><a href="#cb22-197" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bit <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb22-198"><a href="#cb22-198" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">**</span> bit):</span>
<span id="cb22-199"><a href="#cb22-199" aria-hidden="true" tabindex="-1"></a>            diff <span class="op">=</span> i <span class="op">^</span> (i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb22-200"><a href="#cb22-200" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(bit):</span>
<span id="cb22-201"><a href="#cb22-201" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> diff <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> (bit <span class="op">-</span> j <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb22-202"><a href="#cb22-202" aria-hidden="true" tabindex="-1"></a>                    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>target[j])</span>
<span id="cb22-203"><a href="#cb22-203" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>theta[bit, i], target<span class="op">=</span>target[bit], control<span class="op">=</span>target[:bit])</span>
<span id="cb22-204"><a href="#cb22-204" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.Rz(angle<span class="op">=</span>phi[bit, i], target<span class="op">=</span>target[bit], control<span class="op">=</span>target[:bit])</span>
<span id="cb22-205"><a href="#cb22-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-206"><a href="#cb22-206" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-207"><a href="#cb22-207" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-208"><a href="#cb22-208" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-209"><a href="#cb22-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-210"><a href="#cb22-210" aria-hidden="true" tabindex="-1"></a>Calling this code with a 3-qubit state yields the following circuit:</span>
<span id="cb22-211"><a href="#cb22-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-212"><a href="#cb22-212" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/prepare_state.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-213"><a href="#cb22-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-214"><a href="#cb22-214" aria-hidden="true" tabindex="-1"></a>It performs the correct operation, however there are multi-controlled rotations which will likely be a problem when attempting to run this on real hardware.</span>
<span id="cb22-215"><a href="#cb22-215" aria-hidden="true" tabindex="-1"></a>We could let a compiler take care of this, but we don't know how efficient that will be.</span>
<span id="cb22-216"><a href="#cb22-216" aria-hidden="true" tabindex="-1"></a>Instead we'll manually decompose it into single-controlled rotations and Toffoli gates, using our knowledge that there are other qubits in this circuit that we can borrow.</span>
<span id="cb22-217"><a href="#cb22-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-218"><a href="#cb22-218" aria-hidden="true" tabindex="-1"></a><span class="fu">## Decomposing multi-controlled rotations</span></span>
<span id="cb22-219"><a href="#cb22-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-220"><a href="#cb22-220" aria-hidden="true" tabindex="-1"></a>If you refer to the overview of the full circuit in the previous chapter, you can see that we only have one additional qubit with a known initialization, the overflow qubit.</span>
<span id="cb22-221"><a href="#cb22-221" aria-hidden="true" tabindex="-1"></a>Unfortunately this is not enough for our purposes, and we'd also like to keep the option of removing the overflow bit when we don't need it.</span>
<span id="cb22-222"><a href="#cb22-222" aria-hidden="true" tabindex="-1"></a>We could of course simply require additional ancilla qubits, but this would make the circuit more difficult to run.</span>
<span id="cb22-223"><a href="#cb22-223" aria-hidden="true" tabindex="-1"></a>Luckily, we can use a trick described in @Gidney_2017, which allows us to borrow qubits that are already used for something else and in an unknown state.</span>
<span id="cb22-224"><a href="#cb22-224" aria-hidden="true" tabindex="-1"></a>The only requirement is that this unknown state does not change while they're borrowed.</span>
<span id="cb22-225"><a href="#cb22-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-226"><a href="#cb22-226" aria-hidden="true" tabindex="-1"></a>For this, we use the fact that</span>
<span id="cb22-227"><a href="#cb22-227" aria-hidden="true" tabindex="-1"></a>$$ X \cdot R_{Y/Z}(\theta) \cdot X = R_{Y/Z}(-\theta) $$</span>
<span id="cb22-228"><a href="#cb22-228" aria-hidden="true" tabindex="-1"></a>to decompose the circuit in the following way:</span>
<span id="cb22-229"><a href="#cb22-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-230"><a href="#cb22-230" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/controlled_rotation_decomposition.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-231"><a href="#cb22-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-232"><a href="#cb22-232" aria-hidden="true" tabindex="-1"></a>If we have a clean qubit in state $\ket{0}$, the decomposition is easy:</span>
<span id="cb22-233"><a href="#cb22-233" aria-hidden="true" tabindex="-1"></a>We simply run a multi-controlled NOT on the ancilla qubit, and then use that ancilla as the control for the rotation.</span>
<span id="cb22-234"><a href="#cb22-234" aria-hidden="true" tabindex="-1"></a>Then we repeat the controlled NOT to uncompute the effect on the ancilla.</span>
<span id="cb22-235"><a href="#cb22-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-236"><a href="#cb22-236" aria-hidden="true" tabindex="-1"></a>If we don't know the state of our ancilla, we run two rotations, one inside the two controlled NOTs, and one outside.</span>
<span id="cb22-237"><a href="#cb22-237" aria-hidden="true" tabindex="-1"></a>This means that if the controlled NOTs are run, exactly one of those rotations gets executed, achieving the desired result.</span>
<span id="cb22-238"><a href="#cb22-238" aria-hidden="true" tabindex="-1"></a>If the controlled NOTs are not run, it depends on the state of the ancilla.</span>
<span id="cb22-239"><a href="#cb22-239" aria-hidden="true" tabindex="-1"></a>If this state is $\ket{0}$, nothing happens.</span>
<span id="cb22-240"><a href="#cb22-240" aria-hidden="true" tabindex="-1"></a>But if the state is $\ket{1}$, then both rotations are run.</span>
<span id="cb22-241"><a href="#cb22-241" aria-hidden="true" tabindex="-1"></a>Because of this there are two additional CNOTs, which will in this case flip the second rotation, making them cancel each other out.</span>
<span id="cb22-242"><a href="#cb22-242" aria-hidden="true" tabindex="-1"></a>Note that this also works if the ancilla is in a superposition, since each component of the superposition will reach the same result.</span>
<span id="cb22-243"><a href="#cb22-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-244"><a href="#cb22-244" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-245"><a href="#cb22-245" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-246"><a href="#cb22-246" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-247"><a href="#cb22-247" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_controlled_Ry(</span>
<span id="cb22-248"><a href="#cb22-248" aria-hidden="true" tabindex="-1"></a>    angle: <span class="bu">float</span>,</span>
<span id="cb22-249"><a href="#cb22-249" aria-hidden="true" tabindex="-1"></a>    target: <span class="bu">int</span>,</span>
<span id="cb22-250"><a href="#cb22-250" aria-hidden="true" tabindex="-1"></a>    controls: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-251"><a href="#cb22-251" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb22-252"><a href="#cb22-252" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-253"><a href="#cb22-253" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-254"><a href="#cb22-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-255"><a href="#cb22-255" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(controls) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb22-256"><a href="#cb22-256" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>angle, target<span class="op">=</span>target, control<span class="op">=</span>controls)</span>
<span id="cb22-257"><a href="#cb22-257" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U</span>
<span id="cb22-258"><a href="#cb22-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-259"><a href="#cb22-259" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>angle, target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-260"><a href="#cb22-260" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-261"><a href="#cb22-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-262"><a href="#cb22-262" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>], controls<span class="op">=</span>controls, ancillae<span class="op">=</span>ancillae[:<span class="op">-</span><span class="dv">1</span>], uncompute<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb22-263"><a href="#cb22-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-264"><a href="#cb22-264" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Ry(angle<span class="op">=</span>angle, target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-265"><a href="#cb22-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-266"><a href="#cb22-266" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>], controls<span class="op">=</span>controls, ancillae<span class="op">=</span>ancillae[:<span class="op">-</span><span class="dv">1</span>], uncompute<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb22-267"><a href="#cb22-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-268"><a href="#cb22-268" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(target<span class="op">=</span>target, control<span class="op">=</span>ancillae[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-269"><a href="#cb22-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-270"><a href="#cb22-270" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-271"><a href="#cb22-271" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-272"><a href="#cb22-272" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-273"><a href="#cb22-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-274"><a href="#cb22-274" aria-hidden="true" tabindex="-1"></a>The code for the Z-rotation is the same, simply replace Ry with Rz.</span>
<span id="cb22-275"><a href="#cb22-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-276"><a href="#cb22-276" aria-hidden="true" tabindex="-1"></a>But now, even though we got rid of the multi-controlled rotation, we instead have multi-controlled NOTs, which we can also not directly execute.</span>
<span id="cb22-277"><a href="#cb22-277" aria-hidden="true" tabindex="-1"></a>Luckily we can also resolve this using borrowed ancillae:</span>
<span id="cb22-278"><a href="#cb22-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-279"><a href="#cb22-279" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/controlled_not_decomposition.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-280"><a href="#cb22-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-281"><a href="#cb22-281" aria-hidden="true" tabindex="-1"></a>The idea here is similar to the previous circuit.</span>
<span id="cb22-282"><a href="#cb22-282" aria-hidden="true" tabindex="-1"></a>By running controlled operations twice, interleaved with controlled NOTs, we are independent of the initial state of the qubit.</span>
<span id="cb22-283"><a href="#cb22-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-284"><a href="#cb22-284" aria-hidden="true" tabindex="-1"></a>Note that the last three Toffoli gates in the circuit on the right are only necessary to uncompute the ancillae.</span>
<span id="cb22-285"><a href="#cb22-285" aria-hidden="true" tabindex="-1"></a>In cases where we run this circuit twice, like in the decomposition of the rotation above, this is not necessary, since the two circuits will perform the same bitflips and cancel out.</span>
<span id="cb22-286"><a href="#cb22-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-287"><a href="#cb22-287" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-288"><a href="#cb22-288" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-289"><a href="#cb22-289" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-290"><a href="#cb22-290" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_controlled_not(</span>
<span id="cb22-291"><a href="#cb22-291" aria-hidden="true" tabindex="-1"></a>    target: <span class="bu">int</span>,</span>
<span id="cb22-292"><a href="#cb22-292" aria-hidden="true" tabindex="-1"></a>    controls: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-293"><a href="#cb22-293" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-294"><a href="#cb22-294" aria-hidden="true" tabindex="-1"></a>    uncompute: <span class="bu">bool</span> <span class="op">=</span> <span class="va">True</span></span>
<span id="cb22-295"><a href="#cb22-295" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-296"><a href="#cb22-296" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(controls) <span class="op">&lt;=</span> <span class="dv">2</span>:</span>
<span id="cb22-297"><a href="#cb22-297" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tq.gates.X(target<span class="op">=</span>target, control<span class="op">=</span>controls)</span>
<span id="cb22-298"><a href="#cb22-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-299"><a href="#cb22-299" aria-hidden="true" tabindex="-1"></a>    staircase <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-300"><a href="#cb22-300" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(controls) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb22-301"><a href="#cb22-301" aria-hidden="true" tabindex="-1"></a>        staircase <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[i], second<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">2</span>], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-302"><a href="#cb22-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-303"><a href="#cb22-303" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-304"><a href="#cb22-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-305"><a href="#cb22-305" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="op">-</span><span class="dv">1</span>], second<span class="op">=</span>ancillae[<span class="bu">len</span>(controls) <span class="op">-</span> <span class="dv">3</span>], target<span class="op">=</span>target)</span>
<span id="cb22-306"><a href="#cb22-306" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> staircase.dagger()</span>
<span id="cb22-307"><a href="#cb22-307" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="dv">0</span>], second<span class="op">=</span>controls[<span class="dv">1</span>], target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb22-308"><a href="#cb22-308" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> staircase</span>
<span id="cb22-309"><a href="#cb22-309" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="op">-</span><span class="dv">1</span>], second<span class="op">=</span>ancillae[<span class="bu">len</span>(controls) <span class="op">-</span> <span class="dv">3</span>], target<span class="op">=</span>target)</span>
<span id="cb22-310"><a href="#cb22-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-311"><a href="#cb22-311" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> uncompute:</span>
<span id="cb22-312"><a href="#cb22-312" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> staircase.dagger()</span>
<span id="cb22-313"><a href="#cb22-313" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>controls[<span class="dv">0</span>], second<span class="op">=</span>controls[<span class="dv">1</span>], target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb22-314"><a href="#cb22-314" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> staircase</span>
<span id="cb22-315"><a href="#cb22-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-316"><a href="#cb22-316" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-317"><a href="#cb22-317" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-318"><a href="#cb22-318" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-319"><a href="#cb22-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-320"><a href="#cb22-320" aria-hidden="true" tabindex="-1"></a>The Toffoli gates can be directly decomposed into CNOTs and T gates, which we will not do here.</span>
<span id="cb22-321"><a href="#cb22-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-322"><a href="#cb22-322" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gate count</span></span>
<span id="cb22-323"><a href="#cb22-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-324"><a href="#cb22-324" aria-hidden="true" tabindex="-1"></a>We will now analyze the gate usage of these circuits, counting the rotations and Toffoli gates, as they determine the main cost of running the circuit, and ignoring NOT and CNOT gates.</span>
<span id="cb22-325"><a href="#cb22-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-326"><a href="#cb22-326" aria-hidden="true" tabindex="-1"></a>The multi-controlled NOT decomposition with $c \geq 2$ controls and without uncomputing the result uses $2 + 2 \cdot (c - 3) + 1 = 2 c - 3$ Toffoli gates.</span>
<span id="cb22-327"><a href="#cb22-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-328"><a href="#cb22-328" aria-hidden="true" tabindex="-1"></a>Multi controlled rotations with $c \geq 2$ controls have two such decompositions, so $4 c - 6$ Toffoli gates and two rotations.</span>
<span id="cb22-329"><a href="#cb22-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-330"><a href="#cb22-330" aria-hidden="true" tabindex="-1"></a>For comparison, decomposing multi-controlled NOTs and rotations with $c$ controls using the Tequila <span class="in">`compile_circuit`</span> function doesn't require any ancillae but seems to take approximately $2^c$ single qubit rotations and CNOTs each, from some very quick tests.</span>
<span id="cb22-331"><a href="#cb22-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-332"><a href="#cb22-332" aria-hidden="true" tabindex="-1"></a>The part of the PREP circuit operating on the $k$-th qubit (counting from 1) requires $2^k$ $Y$ and $Z$ rotations, each with $k - 1$ controls.</span>
<span id="cb22-333"><a href="#cb22-333" aria-hidden="true" tabindex="-1"></a>However, if we assume that the coefficients of our state are real and positive, there are no phases so the Z-rotations can be removed.</span>
<span id="cb22-334"><a href="#cb22-334" aria-hidden="true" tabindex="-1"></a>Some of the angles of the Y-rotations might be $0$ too, but we assume here that they are all necessary.</span>
<span id="cb22-335"><a href="#cb22-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-336"><a href="#cb22-336" aria-hidden="true" tabindex="-1"></a>This results in $2^k$ rotations and $2^{k - 1} \cdot (4 \cdot (k - 1) - 6) = 2^k \cdot (2 k - 5)$ Toffoli gates, except for $k \leq 2$ where the decomposition is not necessary, so we get half as many rotations and no Toffoli gates.</span>
<span id="cb22-337"><a href="#cb22-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-338"><a href="#cb22-338" aria-hidden="true" tabindex="-1"></a>Let $D$ be the number of diagonals that we are loading in the PREP operation.</span>
<span id="cb22-339"><a href="#cb22-339" aria-hidden="true" tabindex="-1"></a>Assuming that $D$ is a power of 2 and we are operating on $d = \log_2(D)$ qubits in total, for $d = 1$ we have one rotation, and for $d &gt;= 2$</span>
<span id="cb22-340"><a href="#cb22-340" aria-hidden="true" tabindex="-1"></a>$$ 3 + \sum_{k = 3}^{d} 2^k</span>
<span id="cb22-341"><a href="#cb22-341" aria-hidden="true" tabindex="-1"></a>= 2^{d + 1} - 5</span>
<span id="cb22-342"><a href="#cb22-342" aria-hidden="true" tabindex="-1"></a>= 2 D - 5 $$</span>
<span id="cb22-343"><a href="#cb22-343" aria-hidden="true" tabindex="-1"></a>rotations.</span>
<span id="cb22-344"><a href="#cb22-344" aria-hidden="true" tabindex="-1"></a>The number of Toffoli gates is $0$ for $d \leq 2$, and otherwise</span>
<span id="cb22-345"><a href="#cb22-345" aria-hidden="true" tabindex="-1"></a>$$ \sum_{k = 3}^d 2^k \cdot (2k - 5)</span>
<span id="cb22-346"><a href="#cb22-346" aria-hidden="true" tabindex="-1"></a>= 2^d \cdot (4 d - 14) + 24</span>
<span id="cb22-347"><a href="#cb22-347" aria-hidden="true" tabindex="-1"></a>= D \cdot (4 \log_2(D) - 14) + 24 $$</span>
<span id="cb22-348"><a href="#cb22-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-349"><a href="#cb22-349" aria-hidden="true" tabindex="-1"></a>The costs are exponential in $d$, but this is not surprising as the number of values we are loading is exponential in $d$.</span>
<span id="cb22-350"><a href="#cb22-350" aria-hidden="true" tabindex="-1"></a>More interesting to us is how the cost scales with $D$.</span>
<span id="cb22-351"><a href="#cb22-351" aria-hidden="true" tabindex="-1"></a>Especially considering that, if we allow cutting off values below some error threshold $\varepsilon$, we only need $D \in O(\log \varepsilon)$, we get costs in $O(\log \varepsilon \cdot \log \log \varepsilon)$.</span>
<span id="cb22-352"><a href="#cb22-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-353"><a href="#cb22-353" aria-hidden="true" tabindex="-1"></a><span class="fu"># Addition</span></span>
<span id="cb22-354"><a href="#cb22-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-355"><a href="#cb22-355" aria-hidden="true" tabindex="-1"></a>In this chapter we will implement the second building block we need:</span>
<span id="cb22-356"><a href="#cb22-356" aria-hidden="true" tabindex="-1"></a>An addition circuit that adds the value of a source register to a target register.</span>
<span id="cb22-357"><a href="#cb22-357" aria-hidden="true" tabindex="-1"></a>For this we will follow @Takahashi_2009, which introduces the following circuit:</span>
<span id="cb22-358"><a href="#cb22-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-359"><a href="#cb22-359" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/addition_paper.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-360"><a href="#cb22-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-361"><a href="#cb22-361" aria-hidden="true" tabindex="-1"></a>Here $s$ is the sum $a + b$ that we want to calculate.</span>
<span id="cb22-362"><a href="#cb22-362" aria-hidden="true" tabindex="-1"></a>Unfortunately we can't use the circuit directly, because it expects the source and target register to have the same size.</span>
<span id="cb22-363"><a href="#cb22-363" aria-hidden="true" tabindex="-1"></a>In our case however, the target register might be larger, so we need to adapt it for that.</span>
<span id="cb22-364"><a href="#cb22-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-365"><a href="#cb22-365" aria-hidden="true" tabindex="-1"></a><span class="fu">## Allowing different register sizes</span></span>
<span id="cb22-366"><a href="#cb22-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-367"><a href="#cb22-367" aria-hidden="true" tabindex="-1"></a>Instead of applying a NOT operation on a single overflow bit, we want to increment the high bits of the target register.</span>
<span id="cb22-368"><a href="#cb22-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-369"><a href="#cb22-369" aria-hidden="true" tabindex="-1"></a>We cannot simply replace the two controlled NOTs with increment operations, because if both NOTs are executed, they cancel out, but if both increment operations are executed, they increment the value twice.</span>
<span id="cb22-370"><a href="#cb22-370" aria-hidden="true" tabindex="-1"></a>To fix this, we will use a trick from @Gidney_2015: Similar to the rotations in the previous chapter, an increment operation inverts, i.e. becomes a decrement, when its target bits are flipped before and after the operation.</span>
<span id="cb22-371"><a href="#cb22-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-372"><a href="#cb22-372" aria-hidden="true" tabindex="-1"></a>This works because the bitwise complement of a two's complement number is almost the negative of the number, more precisely $\overline{a} = -a - 1$, so</span>
<span id="cb22-373"><a href="#cb22-373" aria-hidden="true" tabindex="-1"></a>$$ \overline{\overline{a} + 1}</span>
<span id="cb22-374"><a href="#cb22-374" aria-hidden="true" tabindex="-1"></a>= \overline{-a - 1 + 1}</span>
<span id="cb22-375"><a href="#cb22-375" aria-hidden="true" tabindex="-1"></a>= \overline{-a}</span>
<span id="cb22-376"><a href="#cb22-376" aria-hidden="true" tabindex="-1"></a>= a - 1 $$</span>
<span id="cb22-377"><a href="#cb22-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-378"><a href="#cb22-378" aria-hidden="true" tabindex="-1"></a>So if we add controlled NOTs to all target registers at the beginning and end of the circuit that run if the first increment will run, then the increments cancel out.</span>
<span id="cb22-379"><a href="#cb22-379" aria-hidden="true" tabindex="-1"></a>If only one of them is running, they will operate correctly.</span>
<span id="cb22-380"><a href="#cb22-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-381"><a href="#cb22-381" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/addition_increment.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-382"><a href="#cb22-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-383"><a href="#cb22-383" aria-hidden="true" tabindex="-1"></a>Next, we need a way to implement an increment operation.</span>
<span id="cb22-384"><a href="#cb22-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-385"><a href="#cb22-385" aria-hidden="true" tabindex="-1"></a><span class="fu">## Increment gate</span></span>
<span id="cb22-386"><a href="#cb22-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-387"><a href="#cb22-387" aria-hidden="true" tabindex="-1"></a>We will first implement an increment circuit that requires n borrowed ancilla qubits, and then improve this to only a single ancilla.</span>
<span id="cb22-388"><a href="#cb22-388" aria-hidden="true" tabindex="-1"></a>Both are taken from @Gidney_2015.</span>
<span id="cb22-389"><a href="#cb22-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-390"><a href="#cb22-390" aria-hidden="true" tabindex="-1"></a>We start with this subtraction widget, which is a modified version of a VanRentergem adder and subtracts the garbage in a register and a carry bit from the value in another register:</span>
<span id="cb22-391"><a href="#cb22-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-392"><a href="#cb22-392" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/subtraction_widget.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-393"><a href="#cb22-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-394"><a href="#cb22-394" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-395"><a href="#cb22-395" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-396"><a href="#cb22-396" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-397"><a href="#cb22-397" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _subtraction_widget(</span>
<span id="cb22-398"><a href="#cb22-398" aria-hidden="true" tabindex="-1"></a>    v: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-399"><a href="#cb22-399" aria-hidden="true" tabindex="-1"></a>    g: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-400"><a href="#cb22-400" aria-hidden="true" tabindex="-1"></a>    c: <span class="bu">int</span></span>
<span id="cb22-401"><a href="#cb22-401" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-402"><a href="#cb22-402" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> [c] <span class="op">+</span> <span class="bu">list</span>(g)</span>
<span id="cb22-403"><a href="#cb22-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-404"><a href="#cb22-404" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-405"><a href="#cb22-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-406"><a href="#cb22-406" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(v) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb22-407"><a href="#cb22-407" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i], target<span class="op">=</span>v[i])</span>
<span id="cb22-408"><a href="#cb22-408" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>], target<span class="op">=</span>g[i])</span>
<span id="cb22-409"><a href="#cb22-409" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>g[i], second<span class="op">=</span>v[i], target<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb22-410"><a href="#cb22-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-411"><a href="#cb22-411" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[<span class="op">-</span><span class="dv">1</span>], target<span class="op">=</span>v[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-412"><a href="#cb22-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-413"><a href="#cb22-413" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="bu">len</span>(v) <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb22-414"><a href="#cb22-414" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>g[i], second<span class="op">=</span>v[i], target<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb22-415"><a href="#cb22-415" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>], target<span class="op">=</span>g[i])</span>
<span id="cb22-416"><a href="#cb22-416" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[i <span class="op">+</span> <span class="dv">1</span>], target<span class="op">=</span>v[i])</span>
<span id="cb22-417"><a href="#cb22-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-418"><a href="#cb22-418" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-419"><a href="#cb22-419" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-420"><a href="#cb22-420" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-421"><a href="#cb22-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-422"><a href="#cb22-422" aria-hidden="true" tabindex="-1"></a>Then we apply this widget twice, but toggle the qubits of $g$ around the second time, so the result in the $v$ register will be</span>
<span id="cb22-423"><a href="#cb22-423" aria-hidden="true" tabindex="-1"></a>$$ v - g - c - (-g - 1) - c</span>
<span id="cb22-424"><a href="#cb22-424" aria-hidden="true" tabindex="-1"></a>= v - 2 c + 1 $$</span>
<span id="cb22-425"><a href="#cb22-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-426"><a href="#cb22-426" aria-hidden="true" tabindex="-1"></a>The result is that if $c = 0$, we perform an increment, and if $c = 1$, we perform a decrement.</span>
<span id="cb22-427"><a href="#cb22-427" aria-hidden="true" tabindex="-1"></a>We want to always perform an increment, and we know that we can turn a decrement into an increment by surrounding it with NOTs, so we do that, controlled by c.</span>
<span id="cb22-428"><a href="#cb22-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-429"><a href="#cb22-429" aria-hidden="true" tabindex="-1"></a>As a last detail, because $v$ has one more bit than $g$, when adding both $g$ and $\overline{g}$, one of those will be negative, but the sign will act as a normal binary digit, toggling the high bit of $v$.</span>
<span id="cb22-430"><a href="#cb22-430" aria-hidden="true" tabindex="-1"></a>We can fix this by adding an additional NOT gate on this bit, ending up with the following circuit:</span>
<span id="cb22-431"><a href="#cb22-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-432"><a href="#cb22-432" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/increment_n_ancillae.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-433"><a href="#cb22-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-434"><a href="#cb22-434" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-435"><a href="#cb22-435" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-436"><a href="#cb22-436" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-437"><a href="#cb22-437" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> increment_circuit_n_ancillae(</span>
<span id="cb22-438"><a href="#cb22-438" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-439"><a href="#cb22-439" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb22-440"><a href="#cb22-440" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-441"><a href="#cb22-441" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> target[::<span class="op">-</span><span class="dv">1</span>]  <span class="co"># LSB ordering</span></span>
<span id="cb22-442"><a href="#cb22-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-443"><a href="#cb22-443" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If there are more than n ancillas, ignore them</span></span>
<span id="cb22-444"><a href="#cb22-444" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> ancillae[:<span class="bu">len</span>(target)]</span>
<span id="cb22-445"><a href="#cb22-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-446"><a href="#cb22-446" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-447"><a href="#cb22-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-448"><a href="#cb22-448" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(v)):</span>
<span id="cb22-449"><a href="#cb22-449" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[<span class="dv">0</span>], target<span class="op">=</span>v[i])</span>
<span id="cb22-450"><a href="#cb22-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-451"><a href="#cb22-451" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(g)):</span>
<span id="cb22-452"><a href="#cb22-452" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>g[i])</span>
<span id="cb22-453"><a href="#cb22-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-454"><a href="#cb22-454" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>v[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-455"><a href="#cb22-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-456"><a href="#cb22-456" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _subtraction_widget(v, g[<span class="dv">1</span>:], g[<span class="dv">0</span>])</span>
<span id="cb22-457"><a href="#cb22-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-458"><a href="#cb22-458" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(g)):</span>
<span id="cb22-459"><a href="#cb22-459" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>g[i])</span>
<span id="cb22-460"><a href="#cb22-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-461"><a href="#cb22-461" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _subtraction_widget(v, g[<span class="dv">1</span>:], g[<span class="dv">0</span>])</span>
<span id="cb22-462"><a href="#cb22-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-463"><a href="#cb22-463" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(v)):</span>
<span id="cb22-464"><a href="#cb22-464" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>g[<span class="dv">0</span>], target<span class="op">=</span>v[i])</span>
<span id="cb22-465"><a href="#cb22-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-466"><a href="#cb22-466" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-467"><a href="#cb22-467" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-468"><a href="#cb22-468" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-469"><a href="#cb22-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-470"><a href="#cb22-470" aria-hidden="true" tabindex="-1"></a>Next, we want to improve this from requiring $n$ ancillae, to only one.</span>
<span id="cb22-471"><a href="#cb22-471" aria-hidden="true" tabindex="-1"></a>To do this, we split one large increment gates into two smaller ones, each acting on half of the register,</span>
<span id="cb22-472"><a href="#cb22-472" aria-hidden="true" tabindex="-1"></a>the second one indirectly controlled by the bits of the lower register using the borrowed ancilla.</span>
<span id="cb22-473"><a href="#cb22-473" aria-hidden="true" tabindex="-1"></a>Reducing the size of the increments like this gives us enough unused qubits to use our $n$ ancilla version.</span>
<span id="cb22-474"><a href="#cb22-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-475"><a href="#cb22-475" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/increment_1_ancilla.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-476"><a href="#cb22-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-477"><a href="#cb22-477" aria-hidden="true" tabindex="-1"></a>We already know from the previous chapter how to decompose the multi-controlled NOTs, and have enough unused qubits here.</span>
<span id="cb22-478"><a href="#cb22-478" aria-hidden="true" tabindex="-1"></a>Making a controlled increment is not a problem either, since this is equivalent to a larger increment and a NOT gate.</span>
<span id="cb22-479"><a href="#cb22-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-480"><a href="#cb22-480" aria-hidden="true" tabindex="-1"></a>To see this, note that an increment gate is equivalent to a triangle of multi-controlled NOTs:</span>
<span id="cb22-481"><a href="#cb22-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-482"><a href="#cb22-482" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/controlled_increment.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-483"><a href="#cb22-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-484"><a href="#cb22-484" aria-hidden="true" tabindex="-1"></a>There is one issue left:</span>
<span id="cb22-485"><a href="#cb22-485" aria-hidden="true" tabindex="-1"></a>Since this method increases the size of the increment on the higher bits, if the size of $v$ is even, we are short one ancilla (if it is odd, we split the register so that the more significant half is one qubit smaller).</span>
<span id="cb22-486"><a href="#cb22-486" aria-hidden="true" tabindex="-1"></a>This can be solved by pulling out the largest multi-controlled NOT, decreasing the size of the increment by one.</span>
<span id="cb22-487"><a href="#cb22-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-488"><a href="#cb22-488" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-489"><a href="#cb22-489" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-490"><a href="#cb22-490" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-491"><a href="#cb22-491" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> increment_circuit_single_ancilla(</span>
<span id="cb22-492"><a href="#cb22-492" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-493"><a href="#cb22-493" aria-hidden="true" tabindex="-1"></a>    ancilla: <span class="bu">int</span></span>
<span id="cb22-494"><a href="#cb22-494" aria-hidden="true" tabindex="-1"></a> ) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-495"><a href="#cb22-495" aria-hidden="true" tabindex="-1"></a>    split <span class="op">=</span> (<span class="bu">len</span>(target) <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb22-496"><a href="#cb22-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-497"><a href="#cb22-497" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-498"><a href="#cb22-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-499"><a href="#cb22-499" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla], ancillae<span class="op">=</span>target[split:])</span>
<span id="cb22-500"><a href="#cb22-500" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancilla)</span>
<span id="cb22-501"><a href="#cb22-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-502"><a href="#cb22-502" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb22-503"><a href="#cb22-503" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancilla, target<span class="op">=</span>target[i])</span>
<span id="cb22-504"><a href="#cb22-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-505"><a href="#cb22-505" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancilla, controls<span class="op">=</span>target[split:], ancillae<span class="op">=</span>target[:split])</span>
<span id="cb22-506"><a href="#cb22-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-507"><a href="#cb22-507" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla], ancillae<span class="op">=</span>target[split:])</span>
<span id="cb22-508"><a href="#cb22-508" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancilla)</span>
<span id="cb22-509"><a href="#cb22-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-510"><a href="#cb22-510" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>ancilla, controls<span class="op">=</span>target[split:], ancillae<span class="op">=</span>target[:split])</span>
<span id="cb22-511"><a href="#cb22-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-512"><a href="#cb22-512" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb22-513"><a href="#cb22-513" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancilla, target<span class="op">=</span>target[i])</span>
<span id="cb22-514"><a href="#cb22-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-515"><a href="#cb22-515" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb22-516"><a href="#cb22-516" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The increment is too large, so pull one qubit out of the operation</span></span>
<span id="cb22-517"><a href="#cb22-517" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> multi_controlled_not(target<span class="op">=</span>target[split], controls<span class="op">=</span>target[split <span class="op">+</span> <span class="dv">1</span>:], ancillae<span class="op">=</span>target[:split])</span>
<span id="cb22-518"><a href="#cb22-518" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span>target[split <span class="op">+</span> <span class="dv">1</span>:], ancillae<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla])</span>
<span id="cb22-519"><a href="#cb22-519" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb22-520"><a href="#cb22-520" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_n_ancillae(target[split:], <span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancilla])</span>
<span id="cb22-521"><a href="#cb22-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-522"><a href="#cb22-522" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-523"><a href="#cb22-523" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-524"><a href="#cb22-524" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-525"><a href="#cb22-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-526"><a href="#cb22-526" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implementation</span></span>
<span id="cb22-527"><a href="#cb22-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-528"><a href="#cb22-528" aria-hidden="true" tabindex="-1"></a>Now we have all of the tools we need to implement the addition circuit from the paper, with the changes mentioned above.</span>
<span id="cb22-529"><a href="#cb22-529" aria-hidden="true" tabindex="-1"></a>Finding even a single ancilla is not easy though, since this operation covers every single qubit in our entire circuit, leaving not even borrowable ancillas.</span>
<span id="cb22-530"><a href="#cb22-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-531"><a href="#cb22-531" aria-hidden="true" tabindex="-1"></a>We solve this problem by noting that we don't need the ancilla for the entire addition circuit, but only during the increment.</span>
<span id="cb22-532"><a href="#cb22-532" aria-hidden="true" tabindex="-1"></a>This increment only touches the last qubit of the s register, so we simply require that it has at least two qubits and use the first as the ancilla.</span>
<span id="cb22-533"><a href="#cb22-533" aria-hidden="true" tabindex="-1"></a>It seems unlikely that we will want to implement a convolution with only two diagonals, so this limitation shouldn't be an issue.</span>
<span id="cb22-534"><a href="#cb22-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-535"><a href="#cb22-535" aria-hidden="true" tabindex="-1"></a>With this we get the following implementation:</span>
<span id="cb22-536"><a href="#cb22-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-537"><a href="#cb22-537" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-538"><a href="#cb22-538" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-539"><a href="#cb22-539" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-540"><a href="#cb22-540" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> addition_circuit(</span>
<span id="cb22-541"><a href="#cb22-541" aria-hidden="true" tabindex="-1"></a>    source: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-542"><a href="#cb22-542" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>]</span>
<span id="cb22-543"><a href="#cb22-543" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-544"><a href="#cb22-544" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(source)</span>
<span id="cb22-545"><a href="#cb22-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-546"><a href="#cb22-546" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Change register to LSB ordering and name them like in the paper.</span></span>
<span id="cb22-547"><a href="#cb22-547" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Note that unlike in the paper, A_n does not exist, because of the special handling for larger target registers.</span></span>
<span id="cb22-548"><a href="#cb22-548" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> source[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb22-549"><a href="#cb22-549" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> target[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb22-550"><a href="#cb22-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-551"><a href="#cb22-551" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-552"><a href="#cb22-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-553"><a href="#cb22-553" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb22-554"><a href="#cb22-554" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>b[i])</span>
<span id="cb22-555"><a href="#cb22-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-556"><a href="#cb22-556" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">&gt;</span> n:</span>
<span id="cb22-557"><a href="#cb22-557" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_single_ancilla(target<span class="op">=</span><span class="bu">list</span>(b[n:][::<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> [a[n <span class="op">-</span> <span class="dv">1</span>]], ancilla<span class="op">=</span>b[<span class="dv">0</span>])</span>
<span id="cb22-558"><a href="#cb22-558" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-559"><a href="#cb22-559" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="bu">len</span>(b)):</span>
<span id="cb22-560"><a href="#cb22-560" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>b[i])</span>
<span id="cb22-561"><a href="#cb22-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-562"><a href="#cb22-562" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb22-563"><a href="#cb22-563" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>a[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb22-564"><a href="#cb22-564" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb22-565"><a href="#cb22-565" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>a[i], second<span class="op">=</span>b[i], target<span class="op">=</span>a[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb22-566"><a href="#cb22-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-567"><a href="#cb22-567" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">&gt;</span> n:</span>
<span id="cb22-568"><a href="#cb22-568" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> increment_circuit_single_ancilla(target<span class="op">=</span><span class="bu">list</span>(b[n:][::<span class="op">-</span><span class="dv">1</span>]) <span class="op">+</span> [a[n <span class="op">-</span> <span class="dv">1</span>], b[n <span class="op">-</span> <span class="dv">1</span>]], ancilla<span class="op">=</span>b[<span class="dv">0</span>])</span>
<span id="cb22-569"><a href="#cb22-569" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>b[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-570"><a href="#cb22-570" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>b[n <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-571"><a href="#cb22-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-572"><a href="#cb22-572" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="dv">1</span>, n)):</span>
<span id="cb22-573"><a href="#cb22-573" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>b[i])</span>
<span id="cb22-574"><a href="#cb22-574" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>a[i <span class="op">-</span> <span class="dv">1</span>], second<span class="op">=</span>b[i <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>a[i])</span>
<span id="cb22-575"><a href="#cb22-575" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb22-576"><a href="#cb22-576" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>a[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb22-577"><a href="#cb22-577" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb22-578"><a href="#cb22-578" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[i], target<span class="op">=</span>b[i])</span>
<span id="cb22-579"><a href="#cb22-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-580"><a href="#cb22-580" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(target) <span class="op">&gt;</span> n:</span>
<span id="cb22-581"><a href="#cb22-581" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, <span class="bu">len</span>(b)):</span>
<span id="cb22-582"><a href="#cb22-582" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>a[n <span class="op">-</span> <span class="dv">1</span>], target<span class="op">=</span>b[i])</span>
<span id="cb22-583"><a href="#cb22-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-584"><a href="#cb22-584" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-585"><a href="#cb22-585" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-586"><a href="#cb22-586" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-587"><a href="#cb22-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-588"><a href="#cb22-588" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gate count</span></span>
<span id="cb22-589"><a href="#cb22-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-590"><a href="#cb22-590" aria-hidden="true" tabindex="-1"></a>Like before, we will only count Toffoli gates (there are no rotations here).</span>
<span id="cb22-591"><a href="#cb22-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-592"><a href="#cb22-592" aria-hidden="true" tabindex="-1"></a>Our subtraction widget with $n$ qubit registers has $2 (n - 1)$ Toffoli gates.</span>
<span id="cb22-593"><a href="#cb22-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-594"><a href="#cb22-594" aria-hidden="true" tabindex="-1"></a>The n ancilla increment gate uses two such widgets and contains no other Toffoli gates, so $4 n - 4$ Toffoli gates.</span>
<span id="cb22-595"><a href="#cb22-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-596"><a href="#cb22-596" aria-hidden="true" tabindex="-1"></a>The calculation for the one ancilla increment gate depends on the parity of $n$.</span>
<span id="cb22-597"><a href="#cb22-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-598"><a href="#cb22-598" aria-hidden="true" tabindex="-1"></a>For even $n$, we need to keep the extra multi-controlled NOT in mind that was pulled out from the increment gate on the less significant bits. The more significant part has $n / 2 - 1$ qubits, and the less significant part has $n / 2 + 1$ qubits, so there are two increment gates on $(n / 2 - 1) + 1$ qubits, one on $(n / 2 + 1) - 1$ qubits, two NOTs with $n / 2 + 1$ controls and one with $(n / 2 + 1) - 1$ controls.</span>
<span id="cb22-599"><a href="#cb22-599" aria-hidden="true" tabindex="-1"></a>Unlike before, we need to uncompute the result of the multi-controlled not, requiring $4c - 8$ Toffoli gates for $c$ controls.</span>
<span id="cb22-600"><a href="#cb22-600" aria-hidden="true" tabindex="-1"></a>This brings the total for the incrementer to $12n - 28$ for $n \geq 6$ (for smaller $n$ the parts into which the register is split become too small for this calculation).</span>
<span id="cb22-601"><a href="#cb22-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-602"><a href="#cb22-602" aria-hidden="true" tabindex="-1"></a>For odd $n$, the more significant part has $(n - 1) / 2$ qubits, and the less significant part $(n + 1) / 2$.</span>
<span id="cb22-603"><a href="#cb22-603" aria-hidden="true" tabindex="-1"></a>So we get two multi-controlled NOTs with $(n - 1) / 2$ controls, two increment gates on $(n + 1) / 2 + 1$ qubits, and one on $(n - 1) / 2$ qubits, for a total of $10 n - 18$ Toffoli gates for $n \geq 5$.</span>
<span id="cb22-604"><a href="#cb22-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-605"><a href="#cb22-605" aria-hidden="true" tabindex="-1"></a>The adder from @Takahashi_2009 with registers of size $n$ uses $2 n - 1$ Toffoli gates.</span>
<span id="cb22-606"><a href="#cb22-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-607"><a href="#cb22-607" aria-hidden="true" tabindex="-1"></a>Let $n$ be the size of the source register and $n + k$ the size of the target register.</span>
<span id="cb22-608"><a href="#cb22-608" aria-hidden="true" tabindex="-1"></a>If $k = 0$, then we remove the Toffoli gate acting on the overflow qubit and get $2 n - 2$ Toffoli gates.</span>
<span id="cb22-609"><a href="#cb22-609" aria-hidden="true" tabindex="-1"></a>If $k &gt; 0$, we also remove this Toffoli gate, but add a $k + 1$ and a $k + 2$ qubit single-ancilla increment gate, one of which has is an even number of qubits and the other odd.</span>
<span id="cb22-610"><a href="#cb22-610" aria-hidden="true" tabindex="-1"></a>If $k \geq 5$, we get $2 n + 22 k - 14$ Toffoli gates for even $k$ and $2 n + 22 k - 16$ for odd $k$.</span>
<span id="cb22-611"><a href="#cb22-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-612"><a href="#cb22-612" aria-hidden="true" tabindex="-1"></a>Even though it is linear, the cost of the modification to allow differently sized registers is high.</span>
<span id="cb22-613"><a href="#cb22-613" aria-hidden="true" tabindex="-1"></a>A more efficient solution would be desirable, especially since our source register will generally be very small due to its exponential cost (as shown in the previous chapter), while the target register might be fairly large.</span>
<span id="cb22-614"><a href="#cb22-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-615"><a href="#cb22-615" aria-hidden="true" tabindex="-1"></a><span class="fu"># Constant Addition</span></span>
<span id="cb22-616"><a href="#cb22-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-617"><a href="#cb22-617" aria-hidden="true" tabindex="-1"></a>In this chapter we will build a circuit that, instead of adding a value from another register, simply adds a compile time constant.</span>
<span id="cb22-618"><a href="#cb22-618" aria-hidden="true" tabindex="-1"></a>For this, we will follow @Häner_2017.</span>
<span id="cb22-619"><a href="#cb22-619" aria-hidden="true" tabindex="-1"></a>You might expect that it is easier to only add a single constant, however the problem here is that unlike in the previous chapter, we don't have the second register to use as temporary working space.</span>
<span id="cb22-620"><a href="#cb22-620" aria-hidden="true" tabindex="-1"></a>This makes this arguable the more difficult operation, which also shows in the asymptotic gate count not being linear but $\Theta(n \log n)$.</span>
<span id="cb22-621"><a href="#cb22-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-622"><a href="#cb22-622" aria-hidden="true" tabindex="-1"></a><span class="fu">## Carry circuit</span></span>
<span id="cb22-623"><a href="#cb22-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-624"><a href="#cb22-624" aria-hidden="true" tabindex="-1"></a>The main idea of this algorithm is that if we split the register we are working on in two parts, the only interaction between those is when there is a carry from the less significant to the more significant part.</span>
<span id="cb22-625"><a href="#cb22-625" aria-hidden="true" tabindex="-1"></a>This means that, if we can detect this carry and increment the more significant part when it occurs, we can then work on the two parts separately, halving the size of the operation.</span>
<span id="cb22-626"><a href="#cb22-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-627"><a href="#cb22-627" aria-hidden="true" tabindex="-1"></a>For this, we need the following carry operation:</span>
<span id="cb22-628"><a href="#cb22-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-629"><a href="#cb22-629" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/carry_gate.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-630"><a href="#cb22-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-631"><a href="#cb22-631" aria-hidden="true" tabindex="-1"></a>Depending on the constant $c$ that is added, some of the gates are removed, see @Häner_2017 for details.</span>
<span id="cb22-632"><a href="#cb22-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-633"><a href="#cb22-633" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-634"><a href="#cb22-634" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-635"><a href="#cb22-635" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-636"><a href="#cb22-636" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _carry_circuit(</span>
<span id="cb22-637"><a href="#cb22-637" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-638"><a href="#cb22-638" aria-hidden="true" tabindex="-1"></a>    const: <span class="bu">int</span>,</span>
<span id="cb22-639"><a href="#cb22-639" aria-hidden="true" tabindex="-1"></a>    carry: <span class="bu">int</span>,</span>
<span id="cb22-640"><a href="#cb22-640" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb22-641"><a href="#cb22-641" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-642"><a href="#cb22-642" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(target)</span>
<span id="cb22-643"><a href="#cb22-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-644"><a href="#cb22-644" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-645"><a href="#cb22-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-646"><a href="#cb22-646" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb22-647"><a href="#cb22-647" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> const <span class="op">&amp;</span> <span class="dv">1</span>:</span>
<span id="cb22-648"><a href="#cb22-648" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>target[<span class="dv">0</span>], target<span class="op">=</span>carry)</span>
<span id="cb22-649"><a href="#cb22-649" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U</span>
<span id="cb22-650"><a href="#cb22-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-651"><a href="#cb22-651" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[n <span class="op">-</span> <span class="dv">2</span>], target<span class="op">=</span>carry)</span>
<span id="cb22-652"><a href="#cb22-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-653"><a href="#cb22-653" aria-hidden="true" tabindex="-1"></a>    half <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-654"><a href="#cb22-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-655"><a href="#cb22-655" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">reversed</span>(<span class="bu">range</span>(<span class="dv">1</span>, n)):</span>
<span id="cb22-656"><a href="#cb22-656" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> const <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i):</span>
<span id="cb22-657"><a href="#cb22-657" aria-hidden="true" tabindex="-1"></a>            half <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>target[i], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-658"><a href="#cb22-658" aria-hidden="true" tabindex="-1"></a>            half <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>target[i])</span>
<span id="cb22-659"><a href="#cb22-659" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb22-660"><a href="#cb22-660" aria-hidden="true" tabindex="-1"></a>            half <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">2</span>], second<span class="op">=</span>target[i], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-661"><a href="#cb22-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-662"><a href="#cb22-662" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> const <span class="op">&amp;</span> <span class="dv">1</span>:</span>
<span id="cb22-663"><a href="#cb22-663" aria-hidden="true" tabindex="-1"></a>        half <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>target[<span class="dv">0</span>], second<span class="op">=</span>target[<span class="dv">1</span>], target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb22-664"><a href="#cb22-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-665"><a href="#cb22-665" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb22-666"><a href="#cb22-666" aria-hidden="true" tabindex="-1"></a>        half <span class="op">+=</span> tq.gates.Toffoli(first<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">2</span>], second<span class="op">=</span>target[i], target<span class="op">=</span>ancillae[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-667"><a href="#cb22-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-668"><a href="#cb22-668" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> half</span>
<span id="cb22-669"><a href="#cb22-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-670"><a href="#cb22-670" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[n <span class="op">-</span> <span class="dv">2</span>], target<span class="op">=</span>carry)</span>
<span id="cb22-671"><a href="#cb22-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-672"><a href="#cb22-672" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> half.dagger()</span>
<span id="cb22-673"><a href="#cb22-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-674"><a href="#cb22-674" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-675"><a href="#cb22-675" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-676"><a href="#cb22-676" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-677"><a href="#cb22-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-678"><a href="#cb22-678" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implementation</span></span>
<span id="cb22-679"><a href="#cb22-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-680"><a href="#cb22-680" aria-hidden="true" tabindex="-1"></a>This carry operation allows us to split the operation in half like described earlier:</span>
<span id="cb22-681"><a href="#cb22-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-682"><a href="#cb22-682" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/const_addition.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-683"><a href="#cb22-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-684"><a href="#cb22-684" aria-hidden="true" tabindex="-1"></a>Here $x_H$ is the more significant half, and $x_L$ the less significant half of the register, and similarly $c_H$ and $c_L$ are the more and less significant halves of the constant.</span>
<span id="cb22-685"><a href="#cb22-685" aria-hidden="true" tabindex="-1"></a>Even though it looks like it, the carry operation doesn't act on $x_H$, only on $x_L$ and the $g$ ancilla.</span>
<span id="cb22-686"><a href="#cb22-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-687"><a href="#cb22-687" aria-hidden="true" tabindex="-1"></a>We can reuse the n-ancilla incrementer from the last chapter here, and like before we have to be careful about the number of ancillae.</span>
<span id="cb22-688"><a href="#cb22-688" aria-hidden="true" tabindex="-1"></a>If the register size is odd, we have exactly the right amount, but if it is even, we are missing one.</span>
<span id="cb22-689"><a href="#cb22-689" aria-hidden="true" tabindex="-1"></a>We could solve this by not splitting the register in half, and instead making the less significant part larger, at the cost of a higher recursion depth.</span>
<span id="cb22-690"><a href="#cb22-690" aria-hidden="true" tabindex="-1"></a>However we already required that the s register consists of at least two qubits in the last chapter, so we can use those as ancillae.</span>
<span id="cb22-691"><a href="#cb22-691" aria-hidden="true" tabindex="-1"></a>One of these qubits can then be used as the additional ancilla we are missing.</span>
<span id="cb22-692"><a href="#cb22-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-693"><a href="#cb22-693" aria-hidden="true" tabindex="-1"></a>Once the recursion reaches a single qubit, the addition operation is simply a NOT gate if $c = 1$.</span>
<span id="cb22-694"><a href="#cb22-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-695"><a href="#cb22-695" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-696"><a href="#cb22-696" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-697"><a href="#cb22-697" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-698"><a href="#cb22-698" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> const_addition_circuit(</span>
<span id="cb22-699"><a href="#cb22-699" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-700"><a href="#cb22-700" aria-hidden="true" tabindex="-1"></a>    const: <span class="bu">int</span>,</span>
<span id="cb22-701"><a href="#cb22-701" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb22-702"><a href="#cb22-702" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-703"><a href="#cb22-703" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(target)</span>
<span id="cb22-704"><a href="#cb22-704" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb22-705"><a href="#cb22-705" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-706"><a href="#cb22-706" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> const <span class="op">&amp;</span> <span class="dv">1</span>:</span>
<span id="cb22-707"><a href="#cb22-707" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>target[<span class="dv">0</span>])</span>
<span id="cb22-708"><a href="#cb22-708" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U</span>
<span id="cb22-709"><a href="#cb22-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-710"><a href="#cb22-710" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">abs</span>(const) <span class="op">&lt;</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-711"><a href="#cb22-711" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">len</span>(ancillae) <span class="op">&gt;=</span> <span class="dv">2</span></span>
<span id="cb22-712"><a href="#cb22-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-713"><a href="#cb22-713" aria-hidden="true" tabindex="-1"></a>    split <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb22-714"><a href="#cb22-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-715"><a href="#cb22-715" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-716"><a href="#cb22-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-717"><a href="#cb22-717" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancillae[<span class="dv">0</span>]],</span>
<span id="cb22-718"><a href="#cb22-718" aria-hidden="true" tabindex="-1"></a>                                      ancillae<span class="op">=</span><span class="bu">list</span>(target[split:]) <span class="op">+</span> [ancillae[<span class="dv">1</span>]])</span>
<span id="cb22-719"><a href="#cb22-719" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb22-720"><a href="#cb22-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-721"><a href="#cb22-721" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb22-722"><a href="#cb22-722" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[<span class="dv">0</span>], target<span class="op">=</span>target[i])</span>
<span id="cb22-723"><a href="#cb22-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-724"><a href="#cb22-724" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _carry_circuit(target<span class="op">=</span>target[split:][::<span class="op">-</span><span class="dv">1</span>], const<span class="op">=</span>const <span class="op">%</span> (<span class="dv">2</span> <span class="op">**</span> (n <span class="op">-</span> split)), carry<span class="op">=</span>ancillae[<span class="dv">0</span>],</span>
<span id="cb22-725"><a href="#cb22-725" aria-hidden="true" tabindex="-1"></a>                        ancillae<span class="op">=</span><span class="bu">list</span>(target[:split]))</span>
<span id="cb22-726"><a href="#cb22-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-727"><a href="#cb22-727" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> increment_circuit_n_ancillae(target<span class="op">=</span><span class="bu">list</span>(target[:split]) <span class="op">+</span> [ancillae[<span class="dv">0</span>]],</span>
<span id="cb22-728"><a href="#cb22-728" aria-hidden="true" tabindex="-1"></a>                                      ancillae<span class="op">=</span><span class="bu">list</span>(target[split:]) <span class="op">+</span> [ancillae[<span class="dv">1</span>]])</span>
<span id="cb22-729"><a href="#cb22-729" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>ancillae[<span class="dv">0</span>])</span>
<span id="cb22-730"><a href="#cb22-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-731"><a href="#cb22-731" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> _carry_circuit(target<span class="op">=</span>target[split:][::<span class="op">-</span><span class="dv">1</span>], const<span class="op">=</span>const <span class="op">%</span> (<span class="dv">2</span> <span class="op">**</span> (n <span class="op">-</span> split)), carry<span class="op">=</span>ancillae[<span class="dv">0</span>],</span>
<span id="cb22-732"><a href="#cb22-732" aria-hidden="true" tabindex="-1"></a>                        ancillae<span class="op">=</span><span class="bu">list</span>(target[:split]))</span>
<span id="cb22-733"><a href="#cb22-733" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-734"><a href="#cb22-734" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(split):</span>
<span id="cb22-735"><a href="#cb22-735" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> tq.gates.CNOT(control<span class="op">=</span>ancillae[<span class="dv">0</span>], target<span class="op">=</span>target[i])</span>
<span id="cb22-736"><a href="#cb22-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-737"><a href="#cb22-737" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> const_addition_circuit(target<span class="op">=</span>target[:split], const<span class="op">=</span>const <span class="op">&gt;&gt;</span> (n <span class="op">-</span> split), ancillae<span class="op">=</span>ancillae)</span>
<span id="cb22-738"><a href="#cb22-738" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> const_addition_circuit(target<span class="op">=</span>target[split:], const<span class="op">=</span>const <span class="op">%</span> (<span class="dv">2</span> <span class="op">**</span> (n <span class="op">-</span> split)), ancillae<span class="op">=</span>ancillae)</span>
<span id="cb22-739"><a href="#cb22-739" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-740"><a href="#cb22-740" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-741"><a href="#cb22-741" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-742"><a href="#cb22-742" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-743"><a href="#cb22-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-744"><a href="#cb22-744" aria-hidden="true" tabindex="-1"></a>With this, we have all the building blocks we need for the full circuit that implements a Toeplitz matrix and the convolution.</span>
<span id="cb22-745"><a href="#cb22-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-746"><a href="#cb22-746" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gate count</span></span>
<span id="cb22-747"><a href="#cb22-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-748"><a href="#cb22-748" aria-hidden="true" tabindex="-1"></a>Again, we are only counting the Toffoli gates.</span>
<span id="cb22-749"><a href="#cb22-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-750"><a href="#cb22-750" aria-hidden="true" tabindex="-1"></a>From the figure, we can see that the carry operation on an $n$ qubit target register requires $4 n - 6$ Toffoli gates if the lowest bit of the constant is set (otherwise two less) for $n \geq 2$ and none for $n = 1$ (there the circuit is a CNOT).</span>
<span id="cb22-751"><a href="#cb22-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-752"><a href="#cb22-752" aria-hidden="true" tabindex="-1"></a>The constant addition on $n$ qubits contains two $\lceil n / 2 \rceil$ qubit carry gates, two $\lfloor n / 2 \rfloor + 1$ qubit increment gates, and two smaller constant addition circuits with $\lceil n / 2 \rceil$ and $\lfloor n / 2 \rfloor$ qubits.</span>
<span id="cb22-753"><a href="#cb22-753" aria-hidden="true" tabindex="-1"></a>For simplicity, we only calculate the number of gates for powers of two, and assume all bits of the constant are set.</span>
<span id="cb22-754"><a href="#cb22-754" aria-hidden="true" tabindex="-1"></a>Denoting this number as $f(n)$ we get</span>
<span id="cb22-755"><a href="#cb22-755" aria-hidden="true" tabindex="-1"></a>$$f(n) = \begin{cases}</span>
<span id="cb22-756"><a href="#cb22-756" aria-hidden="true" tabindex="-1"></a>  0 &amp;\text{ for } n = 1 <span class="sc">\\</span></span>
<span id="cb22-757"><a href="#cb22-757" aria-hidden="true" tabindex="-1"></a>  8 &amp;\text{ for } n = 2 <span class="sc">\\</span></span>
<span id="cb22-758"><a href="#cb22-758" aria-hidden="true" tabindex="-1"></a>  8 n - 12 + 2 f(n / 2) <span class="sc">\\</span></span>
<span id="cb22-759"><a href="#cb22-759" aria-hidden="true" tabindex="-1"></a>  \quad = 8 n \log_2(n) - 10 n + 12 &amp;\text{ for } n &gt; 2</span>
<span id="cb22-760"><a href="#cb22-760" aria-hidden="true" tabindex="-1"></a>\end{cases} $$</span>
<span id="cb22-761"><a href="#cb22-761" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-762"><a href="#cb22-762" aria-hidden="true" tabindex="-1"></a><span class="fu"># Integration</span></span>
<span id="cb22-763"><a href="#cb22-763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-764"><a href="#cb22-764" aria-hidden="true" tabindex="-1"></a>Now that we have all the building blocks, we can combine them to implement Toeplitz matrices and Gaussian convolutions.</span>
<span id="cb22-765"><a href="#cb22-765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-766"><a href="#cb22-766" aria-hidden="true" tabindex="-1"></a><span class="fu">## Toeplitz matrix</span></span>
<span id="cb22-767"><a href="#cb22-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-768"><a href="#cb22-768" aria-hidden="true" tabindex="-1"></a>As a reminder, this is the circuit we want to implement:</span>
<span id="cb22-769"><a href="#cb22-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-770"><a href="#cb22-770" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/full.svg)</span>{width=100% fig-align="center"}</span>
<span id="cb22-771"><a href="#cb22-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-772"><a href="#cb22-772" aria-hidden="true" tabindex="-1"></a>We have built all the parts in the previous chapters, but one detail was only mentioned briefly.</span>
<span id="cb22-773"><a href="#cb22-773" aria-hidden="true" tabindex="-1"></a>Let $A_d$ be the diagonals of the Toeplitz matrix.</span>
<span id="cb22-774"><a href="#cb22-774" aria-hidden="true" tabindex="-1"></a>Instead of directly loading the values in PREP and using UNPREP only for combining the different values to a single state, we can follow chapter 2.3 from @Sünderhauf_2024 and choose $p = 1 / 2$ (which is shown there to be optimal), resulting in</span>
<span id="cb22-775"><a href="#cb22-775" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb22-776"><a href="#cb22-776" aria-hidden="true" tabindex="-1"></a>\text{PREP} \ket{0}</span>
<span id="cb22-777"><a href="#cb22-777" aria-hidden="true" tabindex="-1"></a>= \frac{\sum_d \text{sgn}(A_d) \sqrt{|A_d|} \ket{d}}{\sqrt{\sum_d |A_d|}}</span>
<span id="cb22-778"><a href="#cb22-778" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb22-779"><a href="#cb22-779" aria-hidden="true" tabindex="-1"></a>and</span>
<span id="cb22-780"><a href="#cb22-780" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb22-781"><a href="#cb22-781" aria-hidden="true" tabindex="-1"></a>\bra{0} \text{UNPREP}</span>
<span id="cb22-782"><a href="#cb22-782" aria-hidden="true" tabindex="-1"></a>= \frac{\sum_d \sqrt{|A_d|} \bra{d}}{\sqrt{\sum_d |A_d|}}</span>
<span id="cb22-783"><a href="#cb22-783" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb22-784"><a href="#cb22-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-785"><a href="#cb22-785" aria-hidden="true" tabindex="-1"></a>Implementing the Toeplitz matrix circuit is fairly simple now:</span>
<span id="cb22-786"><a href="#cb22-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-787"><a href="#cb22-787" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-788"><a href="#cb22-788" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-789"><a href="#cb22-789" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-790"><a href="#cb22-790" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> toeplitz_matrix(</span>
<span id="cb22-791"><a href="#cb22-791" aria-hidden="true" tabindex="-1"></a>    diags: npt.NDArray[<span class="bu">float</span>],</span>
<span id="cb22-792"><a href="#cb22-792" aria-hidden="true" tabindex="-1"></a>    target: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-793"><a href="#cb22-793" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-794"><a href="#cb22-794" aria-hidden="true" tabindex="-1"></a>    overflow: Optional[<span class="bu">int</span>],</span>
<span id="cb22-795"><a href="#cb22-795" aria-hidden="true" tabindex="-1"></a>    offset: <span class="bu">int</span></span>
<span id="cb22-796"><a href="#cb22-796" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-797"><a href="#cb22-797" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(target)</span>
<span id="cb22-798"><a href="#cb22-798" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-799"><a href="#cb22-799" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">len</span>(ancillae)</span>
<span id="cb22-800"><a href="#cb22-800" aria-hidden="true" tabindex="-1"></a>    D <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> d</span>
<span id="cb22-801"><a href="#cb22-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-802"><a href="#cb22-802" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> overflow <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb22-803"><a href="#cb22-803" aria-hidden="true" tabindex="-1"></a>        target <span class="op">=</span> np.append(overflow, target)</span>
<span id="cb22-804"><a href="#cb22-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-805"><a href="#cb22-805" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-806"><a href="#cb22-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-807"><a href="#cb22-807" aria-hidden="true" tabindex="-1"></a>    prep_values <span class="op">=</span> np.exp(np.angle(diags) <span class="op">*</span> <span class="ot">1j</span>) <span class="op">*</span> np.sqrt(np.<span class="bu">abs</span>(diags))</span>
<span id="cb22-808"><a href="#cb22-808" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(prep_values), target<span class="op">=</span>ancillae, ancillae<span class="op">=</span>target)</span>
<span id="cb22-809"><a href="#cb22-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-810"><a href="#cb22-810" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> addition_circuit(source<span class="op">=</span>ancillae, target<span class="op">=</span>target)</span>
<span id="cb22-811"><a href="#cb22-811" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-812"><a href="#cb22-812" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> const_addition_circuit(target<span class="op">=</span>target, const<span class="op">=-</span>offset, ancillae<span class="op">=</span>ancillae)</span>
<span id="cb22-813"><a href="#cb22-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-814"><a href="#cb22-814" aria-hidden="true" tabindex="-1"></a>    unprep_values <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(diags))</span>
<span id="cb22-815"><a href="#cb22-815" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(unprep_values), target<span class="op">=</span>ancillae, ancillae<span class="op">=</span>target).dagger()</span>
<span id="cb22-816"><a href="#cb22-816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-817"><a href="#cb22-817" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-818"><a href="#cb22-818" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-819"><a href="#cb22-819" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-820"><a href="#cb22-820" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-821"><a href="#cb22-821" aria-hidden="true" tabindex="-1"></a>With this, we are at the point where we can implement the example matrix from the first chapter:</span>
<span id="cb22-822"><a href="#cb22-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-823"><a href="#cb22-823" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-824"><a href="#cb22-824" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-825"><a href="#cb22-825" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-826"><a href="#cb22-826" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb22-827"><a href="#cb22-827" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-828"><a href="#cb22-828" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>)])</span>
<span id="cb22-829"><a href="#cb22-829" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb22-830"><a href="#cb22-830" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-831"><a href="#cb22-831" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb22-832"><a href="#cb22-832" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb22-833"><a href="#cb22-833" aria-hidden="true" tabindex="-1"></a>overflow <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb22-834"><a href="#cb22-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-835"><a href="#cb22-835" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j, ancillae<span class="op">=</span>s, overflow<span class="op">=</span>overflow, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-836"><a href="#cb22-836" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-837"><a href="#cb22-837" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb22-838"><a href="#cb22-838" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-839"><a href="#cb22-839" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-840"><a href="#cb22-840" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-841"><a href="#cb22-841" aria-hidden="true" tabindex="-1"></a>Even this small example results in a fairly large circuit, however that is expected, given the large constant factors in the gate counts:</span>
<span id="cb22-842"><a href="#cb22-842" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-843"><a href="#cb22-843" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/complete_circuit.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-844"><a href="#cb22-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-845"><a href="#cb22-845" aria-hidden="true" tabindex="-1"></a>At the start there are some redundant gates which could be simplified, this is due to the small circuit size and doesn't happen for larger circuits.</span>
<span id="cb22-846"><a href="#cb22-846" aria-hidden="true" tabindex="-1"></a>Some of the constructions from the previous chapters would need special handling for small registers to fix this.</span>
<span id="cb22-847"><a href="#cb22-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-848"><a href="#cb22-848" aria-hidden="true" tabindex="-1"></a>A way to verify that this circuit does what it is supposed to is to evaluate it on all the basis states and visualize the resulting matrix.</span>
<span id="cb22-849"><a href="#cb22-849" aria-hidden="true" tabindex="-1"></a>We can also use this opportunity to show the postselection success probability.</span>
<span id="cb22-850"><a href="#cb22-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-851"><a href="#cb22-851" aria-hidden="true" tabindex="-1"></a>For this, it is convenient to write a helper function to encode the input, perform the postselection, and return the result as a Numpy array/matrix instead of a Tequila wavefunction, particularly for when we later want to have multiple dimensions:</span>
<span id="cb22-852"><a href="#cb22-852" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-853"><a href="#cb22-853" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-854"><a href="#cb22-854" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-855"><a href="#cb22-855" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-856"><a href="#cb22-856" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eval_circuit(</span>
<span id="cb22-857"><a href="#cb22-857" aria-hidden="true" tabindex="-1"></a>    states: Union[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb22-858"><a href="#cb22-858" aria-hidden="true" tabindex="-1"></a>    U: tq.QCircuit,</span>
<span id="cb22-859"><a href="#cb22-859" aria-hidden="true" tabindex="-1"></a>    ranges: Union[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb22-860"><a href="#cb22-860" aria-hidden="true" tabindex="-1"></a>    offsets: Union[<span class="bu">int</span>, <span class="bu">list</span>[<span class="bu">int</span>]],</span>
<span id="cb22-861"><a href="#cb22-861" aria-hidden="true" tabindex="-1"></a>    postselection_mask: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-862"><a href="#cb22-862" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[np.ndarray, <span class="bu">float</span>]:</span>
<span id="cb22-863"><a href="#cb22-863" aria-hidden="true" tabindex="-1"></a>    state_combined <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-864"><a href="#cb22-864" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(states, <span class="bu">list</span>):</span>
<span id="cb22-865"><a href="#cb22-865" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> state, offset <span class="kw">in</span> <span class="bu">zip</span>(states, offsets):</span>
<span id="cb22-866"><a href="#cb22-866" aria-hidden="true" tabindex="-1"></a>            state_combined <span class="op">|=</span> state <span class="op">&lt;&lt;</span> offset</span>
<span id="cb22-867"><a href="#cb22-867" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb22-868"><a href="#cb22-868" aria-hidden="true" tabindex="-1"></a>        state_combined <span class="op">=</span> states <span class="op">&lt;&lt;</span> offsets</span>
<span id="cb22-869"><a href="#cb22-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-870"><a href="#cb22-870" aria-hidden="true" tabindex="-1"></a>    wvn <span class="op">=</span> tq.simulate(prepare_basis_state(state_combined, U.n_qubits) <span class="op">+</span> U, backend<span class="op">=</span><span class="st">"qulacs"</span>)</span>
<span id="cb22-871"><a href="#cb22-871" aria-hidden="true" tabindex="-1"></a>    postselected <span class="op">=</span> {k.integer: v <span class="cf">for</span> k, v <span class="kw">in</span> wvn.state.items() <span class="cf">if</span> k.integer <span class="op">&amp;</span> postselection_mask <span class="op">==</span> <span class="dv">0</span>}</span>
<span id="cb22-872"><a href="#cb22-872" aria-hidden="true" tabindex="-1"></a>    angle <span class="op">=</span> np.angle(postselected[<span class="bu">min</span>(postselected.keys())])</span>
<span id="cb22-873"><a href="#cb22-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-874"><a href="#cb22-874" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> np.zeros(ranges, dtype<span class="op">=</span>np.complex128)</span>
<span id="cb22-875"><a href="#cb22-875" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, val <span class="kw">in</span> postselected.items():</span>
<span id="cb22-876"><a href="#cb22-876" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(ranges, <span class="bu">list</span>):</span>
<span id="cb22-877"><a href="#cb22-877" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> <span class="bu">tuple</span>((i <span class="op">&gt;&gt;</span> offset) <span class="op">%</span> N <span class="cf">for</span> offset, N <span class="kw">in</span> <span class="bu">zip</span>(offsets, ranges))</span>
<span id="cb22-878"><a href="#cb22-878" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb22-879"><a href="#cb22-879" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> (i <span class="op">&gt;&gt;</span> offsets) <span class="op">%</span> ranges</span>
<span id="cb22-880"><a href="#cb22-880" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> result[index] <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb22-881"><a href="#cb22-881" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Multiple values in the same state with different ancilla states."</span>)</span>
<span id="cb22-882"><a href="#cb22-882" aria-hidden="true" tabindex="-1"></a>        result[index] <span class="op">=</span> val <span class="op">*</span> np.exp(<span class="op">-</span>angle <span class="op">*</span> <span class="ot">1j</span>)</span>
<span id="cb22-883"><a href="#cb22-883" aria-hidden="true" tabindex="-1"></a>    normalization <span class="op">=</span> np.linalg.norm(result)</span>
<span id="cb22-884"><a href="#cb22-884" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> normalization <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb22-885"><a href="#cb22-885" aria-hidden="true" tabindex="-1"></a>        result <span class="op">/=</span> normalization</span>
<span id="cb22-886"><a href="#cb22-886" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-887"><a href="#cb22-887" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result, normalization</span>
<span id="cb22-888"><a href="#cb22-888" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-889"><a href="#cb22-889" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-890"><a href="#cb22-890" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-891"><a href="#cb22-891" aria-hidden="true" tabindex="-1"></a>This makes visualizing the result with Pyplot simple:</span>
<span id="cb22-892"><a href="#cb22-892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-893"><a href="#cb22-893" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-894"><a href="#cb22-894" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-895"><a href="#cb22-895" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-896"><a href="#cb22-896" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb22-897"><a href="#cb22-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-898"><a href="#cb22-898" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> j: eval_circuit(states<span class="op">=</span>j, U<span class="op">=</span>U, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b11001</span>), <span class="bu">range</span>(N))</span>
<span id="cb22-899"><a href="#cb22-899" aria-hidden="true" tabindex="-1"></a>columns, normalizations <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>results)</span>
<span id="cb22-900"><a href="#cb22-900" aria-hidden="true" tabindex="-1"></a>matrix <span class="op">=</span> np.column_stack(columns)</span>
<span id="cb22-901"><a href="#cb22-901" aria-hidden="true" tabindex="-1"></a>normalization <span class="op">=</span> np.array(normalizations)</span>
<span id="cb22-902"><a href="#cb22-902" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-903"><a href="#cb22-903" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, height_ratios<span class="op">=</span>[N, <span class="dv">1</span>], figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb22-904"><a href="#cb22-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-905"><a href="#cb22-905" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Operation Matrix"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-906"><a href="#cb22-906" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb22-907"><a href="#cb22-907" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].yaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb22-908"><a href="#cb22-908" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> ax[<span class="dv">0</span>].imshow(np.real(matrix))</span>
<span id="cb22-909"><a href="#cb22-909" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im0, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb22-910"><a href="#cb22-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-911"><a href="#cb22-911" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Postselection Probability"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-912"><a href="#cb22-912" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].xaxis.set_major_locator(MaxNLocator(integer<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb22-913"><a href="#cb22-913" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].yaxis.set_visible(<span class="va">False</span>)</span>
<span id="cb22-914"><a href="#cb22-914" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> ax[<span class="dv">1</span>].imshow(np.square(normalization).reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>), vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-915"><a href="#cb22-915" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im1, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb22-916"><a href="#cb22-916" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-917"><a href="#cb22-917" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-918"><a href="#cb22-918" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb22-919"><a href="#cb22-919" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-920"><a href="#cb22-920" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-921"><a href="#cb22-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-922"><a href="#cb22-922" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/example_visualization.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-923"><a href="#cb22-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-924"><a href="#cb22-924" aria-hidden="true" tabindex="-1"></a>The top left corner might look wrong at first, but remember that each column has to be normalized, so we can't get the exact matrix we intended.</span>
<span id="cb22-925"><a href="#cb22-925" aria-hidden="true" tabindex="-1"></a>The third and fourth column are correct because none of the values are cut off, so the postselection has no effect.</span>
<span id="cb22-926"><a href="#cb22-926" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-927"><a href="#cb22-927" aria-hidden="true" tabindex="-1"></a>We can also remove the overflow flag from the postselection mask to see what happens without it:</span>
<span id="cb22-928"><a href="#cb22-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-929"><a href="#cb22-929" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/example_visualization_no_overflow.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-930"><a href="#cb22-930" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-931"><a href="#cb22-931" aria-hidden="true" tabindex="-1"></a>This might also look wrong at first, but this is because in a 4x4 matrix with 3 diagonals we only have one diagonal with value zero.</span>
<span id="cb22-932"><a href="#cb22-932" aria-hidden="true" tabindex="-1"></a>The three values in the bottom left are what was cut off before, and now that we are skipping this step, you can see that the diagonals actually all have the same value.</span>
<span id="cb22-933"><a href="#cb22-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-934"><a href="#cb22-934" aria-hidden="true" tabindex="-1"></a>To make the connection to the continuous convolution clearer, we can increase the number of qubits and plot the resulting wavefunction as a graph:</span>
<span id="cb22-935"><a href="#cb22-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-936"><a href="#cb22-936" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-937"><a href="#cb22-937" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-938"><a href="#cb22-938" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-939"><a href="#cb22-939" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb22-940"><a href="#cb22-940" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-941"><a href="#cb22-941" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">32</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">15</span>, <span class="dv">16</span>)])</span>
<span id="cb22-942"><a href="#cb22-942" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb22-943"><a href="#cb22-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-944"><a href="#cb22-944" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb22-945"><a href="#cb22-945" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb22-946"><a href="#cb22-946" aria-hidden="true" tabindex="-1"></a>overflow <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb22-947"><a href="#cb22-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-948"><a href="#cb22-948" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j, ancillae<span class="op">=</span>s, overflow<span class="op">=</span>overflow, offset<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb22-949"><a href="#cb22-949" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> eval_circuit(states<span class="op">=</span><span class="dv">32</span>, U<span class="op">=</span>U, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b111110000001</span>)[<span class="dv">0</span>]</span>
<span id="cb22-950"><a href="#cb22-950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-951"><a href="#cb22-951" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb22-952"><a href="#cb22-952" aria-hidden="true" tabindex="-1"></a>plt.plot(np.real(result))</span>
<span id="cb22-953"><a href="#cb22-953" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"State"</span>)</span>
<span id="cb22-954"><a href="#cb22-954" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb22-955"><a href="#cb22-955" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-956"><a href="#cb22-956" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb22-957"><a href="#cb22-957" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-958"><a href="#cb22-958" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-959"><a href="#cb22-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-960"><a href="#cb22-960" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/graph.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-961"><a href="#cb22-961" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-962"><a href="#cb22-962" aria-hidden="true" tabindex="-1"></a>For comparison, this is what the function $g(x) = \exp((x - 32)^2 / 32)$ looks like:</span>
<span id="cb22-963"><a href="#cb22-963" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-964"><a href="#cb22-964" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/graph_comparison.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-965"><a href="#cb22-965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-966"><a href="#cb22-966" aria-hidden="true" tabindex="-1"></a>The only major difference is the scale of the y-Axis, which is due to the normalization of quantum states.</span>
<span id="cb22-967"><a href="#cb22-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-968"><a href="#cb22-968" aria-hidden="true" tabindex="-1"></a>We can also try what happens when we input a state that isn't a basis state, but some superposition.</span>
<span id="cb22-969"><a href="#cb22-969" aria-hidden="true" tabindex="-1"></a>Usually this superposition would be the result of the previous part of a larger circuit, but in our case we can simply add some Hadamard and NOT gates to get a similar effect.</span>
<span id="cb22-970"><a href="#cb22-970" aria-hidden="true" tabindex="-1"></a>The circuit smooths the input state, as expected from a Gaussian convolution:</span>
<span id="cb22-971"><a href="#cb22-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-972"><a href="#cb22-972" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-973"><a href="#cb22-973" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-974"><a href="#cb22-974" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-975"><a href="#cb22-975" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb22-976"><a href="#cb22-976" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-977"><a href="#cb22-977" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">32</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">15</span>, <span class="dv">16</span>)])</span>
<span id="cb22-978"><a href="#cb22-978" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb22-979"><a href="#cb22-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-980"><a href="#cb22-980" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb22-981"><a href="#cb22-981" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb22-982"><a href="#cb22-982" aria-hidden="true" tabindex="-1"></a>overflow <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb22-983"><a href="#cb22-983" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-984"><a href="#cb22-984" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-985"><a href="#cb22-985" aria-hidden="true" tabindex="-1"></a><span class="co"># make sure qubits aren't optimized out</span></span>
<span id="cb22-986"><a href="#cb22-986" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb22-987"><a href="#cb22-987" aria-hidden="true" tabindex="-1"></a>    prepare <span class="op">+=</span> tq.gates.Rz(angle<span class="op">=</span><span class="dv">0</span>, target<span class="op">=</span>i)</span>
<span id="cb22-988"><a href="#cb22-988" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j[<span class="dv">0</span>])</span>
<span id="cb22-989"><a href="#cb22-989" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j[<span class="dv">0</span>])</span>
<span id="cb22-990"><a href="#cb22-990" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j[<span class="dv">1</span>])</span>
<span id="cb22-991"><a href="#cb22-991" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-992"><a href="#cb22-992" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb22-993"><a href="#cb22-993" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-994"><a href="#cb22-994" aria-hidden="true" tabindex="-1"></a>init, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span><span class="dv">0</span>, U<span class="op">=</span>prepare, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b0</span>)</span>
<span id="cb22-995"><a href="#cb22-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-996"><a href="#cb22-996" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j, ancillae<span class="op">=</span>s, overflow<span class="op">=</span>overflow, offset<span class="op">=</span><span class="dv">15</span>)</span>
<span id="cb22-997"><a href="#cb22-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-998"><a href="#cb22-998" aria-hidden="true" tabindex="-1"></a>result, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span><span class="dv">0</span>, U<span class="op">=</span>prepare <span class="op">+</span> U, ranges<span class="op">=</span>N, offsets<span class="op">=</span><span class="dv">1</span>, postselection_mask<span class="op">=</span><span class="bn">0b111110000001</span>)</span>
<span id="cb22-999"><a href="#cb22-999" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1000"><a href="#cb22-1000" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb22-1001"><a href="#cb22-1001" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1002"><a href="#cb22-1002" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Initialization"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-1003"><a href="#cb22-1003" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(np.real(init))</span>
<span id="cb22-1004"><a href="#cb22-1004" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">"State"</span>)</span>
<span id="cb22-1005"><a href="#cb22-1005" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb22-1006"><a href="#cb22-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1007"><a href="#cb22-1007" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Result"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-1008"><a href="#cb22-1008" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(np.real(result))</span>
<span id="cb22-1009"><a href="#cb22-1009" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">"State"</span>)</span>
<span id="cb22-1010"><a href="#cb22-1010" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb22-1011"><a href="#cb22-1011" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1012"><a href="#cb22-1012" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-1013"><a href="#cb22-1013" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb22-1014"><a href="#cb22-1014" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-1015"><a href="#cb22-1015" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-1016"><a href="#cb22-1016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1017"><a href="#cb22-1017" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/graph_init.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-1018"><a href="#cb22-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1019"><a href="#cb22-1019" aria-hidden="true" tabindex="-1"></a><span class="fu">## Gate count</span></span>
<span id="cb22-1020"><a href="#cb22-1020" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1021"><a href="#cb22-1021" aria-hidden="true" tabindex="-1"></a>Let $D$ be the number of diagonals and a power of 2, and $d = log_2(D)$ the size of the s register.</span>
<span id="cb22-1022"><a href="#cb22-1022" aria-hidden="true" tabindex="-1"></a>Let $n$ be the number of input and output qubits and assume $n + 1$ is a power of 2 and that $n + 1 - d \geq 5$.</span>
<span id="cb22-1023"><a href="#cb22-1023" aria-hidden="true" tabindex="-1"></a>The $+1$ is because we also need to consider the overflow gate in the addition operations.</span>
<span id="cb22-1024"><a href="#cb22-1024" aria-hidden="true" tabindex="-1"></a>Assuming the values of the diagonals are real and non-negative (otherwise the PREP and UNPREP operation would use more gates), we get the following gate counts:</span>
<span id="cb22-1025"><a href="#cb22-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1026"><a href="#cb22-1026" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$2 D - 5$ rotations and $D \cdot (4 \log_2(D) - 14) + 24$ Toffoli gates for the PREP and UNPREP block each</span>
<span id="cb22-1027"><a href="#cb22-1027" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$2 d + 22 (n + 1 - d) - 14$ Toffoli gates for the addition or two less if $n + 1 - d$ is odd</span>
<span id="cb22-1028"><a href="#cb22-1028" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>up to $8 (n + 1) \log_2(n + 1) - 10 (n + 1) + 12$ Toffoli gates for the constant addition, depending on the constant</span>
<span id="cb22-1029"><a href="#cb22-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1030"><a href="#cb22-1030" aria-hidden="true" tabindex="-1"></a>So the total number of rotations is up to $4 D - 10 \in O(D)$, and the total number of Toffoli gates is up to $2 D \cdot (4 d - 14) - 20 d + 8 (n + 1) \log_2(n + 1) + 12 n + 58$ $\in O(D \log(D) +n \log(n))$.</span>
<span id="cb22-1031"><a href="#cb22-1031" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1032"><a href="#cb22-1032" aria-hidden="true" tabindex="-1"></a><span class="fu">## Postselection success probability</span></span>
<span id="cb22-1033"><a href="#cb22-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1034"><a href="#cb22-1034" aria-hidden="true" tabindex="-1"></a>Another important factor when considering the cost of this algorithm is subnormalization, which influences the chance that the postselection succeeds, as this will determine how often the algorithm needs to be repeated.</span>
<span id="cb22-1035"><a href="#cb22-1035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1036"><a href="#cb22-1036" aria-hidden="true" tabindex="-1"></a>If we don't postselect the overflow qubit, the implementation here is optimal.</span>
<span id="cb22-1037"><a href="#cb22-1037" aria-hidden="true" tabindex="-1"></a>This is because the uniform wavefunction $\ket{\psi} = \frac{1}{\sqrt{N}} \sum_{k = 0}^{N - 1} \ket{k}$ is a fixpoint of our algorithm.</span>
<span id="cb22-1038"><a href="#cb22-1038" aria-hidden="true" tabindex="-1"></a>A Gaussian convolution has a smoothing effect, so if the wavefunction is already completely uniform, there is nothing left for it to do.</span>
<span id="cb22-1039"><a href="#cb22-1039" aria-hidden="true" tabindex="-1"></a>But here, we are less interested in the shape of the result, and more in the norm.</span>
<span id="cb22-1040"><a href="#cb22-1040" aria-hidden="true" tabindex="-1"></a>For this we need to multiply the scale of the PREP and UNPREP operations from earlier, which gives us the factor $1 / \sum_d |A_d|$.</span>
<span id="cb22-1041"><a href="#cb22-1041" aria-hidden="true" tabindex="-1"></a>However this is the exact value that the result gets from summing the different terms (except for a phase, which doesn't matter for our uniform wavefunction), so it cancels out, and we get scale $1$, i.e. a postselection success probability of 100%.</span>
<span id="cb22-1042"><a href="#cb22-1042" aria-hidden="true" tabindex="-1"></a>This shows that we can't possibly achieve a lower subnormalization, because then we could map $\ket{\psi}$ to a wavefunction with norm greater than $1$.</span>
<span id="cb22-1043"><a href="#cb22-1043" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1044"><a href="#cb22-1044" aria-hidden="true" tabindex="-1"></a>This doesn't apply with the postselection on the overflow bit, but if we assume that the kernel is much smaller than the wavefunction (which we have to anyways, because of the exponential costs), then only a small number of values is removed, so the norm is still close to $1$, and the circuit thus close to optimal.</span>
<span id="cb22-1045"><a href="#cb22-1045" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1046"><a href="#cb22-1046" aria-hidden="true" tabindex="-1"></a>Of course for other wavefunctions the success probability can be much lower or even $0$, e.g. a quickly oscillating function where the positive and negative parts cancel out when smoothed, but this is due to the operation, not the implementation.</span>
<span id="cb22-1047"><a href="#cb22-1047" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1048"><a href="#cb22-1048" aria-hidden="true" tabindex="-1"></a><span class="fu">## Multiple dimensions</span></span>
<span id="cb22-1049"><a href="#cb22-1049" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1050"><a href="#cb22-1050" aria-hidden="true" tabindex="-1"></a>Now that we have implemented the one dimensional case, we can easily extend this to multiple dimensions by simply running the same circuit on multiple registers in parallel:</span>
<span id="cb22-1051"><a href="#cb22-1051" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1052"><a href="#cb22-1052" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-1053"><a href="#cb22-1053" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-1054"><a href="#cb22-1054" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-1055"><a href="#cb22-1055" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb22-1056"><a href="#cb22-1056" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-1057"><a href="#cb22-1057" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">4</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">4</span>)])</span>
<span id="cb22-1058"><a href="#cb22-1058" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb22-1059"><a href="#cb22-1059" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1060"><a href="#cb22-1060" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb22-1061"><a href="#cb22-1061" aria-hidden="true" tabindex="-1"></a>j1 <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb22-1062"><a href="#cb22-1062" aria-hidden="true" tabindex="-1"></a>overflow1 <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb22-1063"><a href="#cb22-1063" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb22-1064"><a href="#cb22-1064" aria-hidden="true" tabindex="-1"></a>j2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb22-1065"><a href="#cb22-1065" aria-hidden="true" tabindex="-1"></a>overflow2 <span class="op">=</span> overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb22-1066"><a href="#cb22-1066" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1067"><a href="#cb22-1067" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-1068"><a href="#cb22-1068" aria-hidden="true" tabindex="-1"></a>U <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-1069"><a href="#cb22-1069" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1070"><a href="#cb22-1070" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb22-1071"><a href="#cb22-1071" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-1072"><a href="#cb22-1072" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-1073"><a href="#cb22-1073" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1074"><a href="#cb22-1074" aria-hidden="true" tabindex="-1"></a>This is also the point where wrapping the evaluation in <span class="in">`eval_circuit`</span> starts to really help, because otherwise dealing with multiple input and output registers quickly becomes hard to read.</span>
<span id="cb22-1075"><a href="#cb22-1075" aria-hidden="true" tabindex="-1"></a>It also allows to easily parallelize the evaluation of multiple states using the Python <span class="in">`multiprocessing`</span> module (at the time of writing this helped due to inefficiencies in the Tequila <span class="in">`simulate`</span> function, but since version 1.9.7 this should no longer be necessary).</span>
<span id="cb22-1076"><a href="#cb22-1076" aria-hidden="true" tabindex="-1"></a>We will not evaluate every basis state, instead, confirming that it behaves correctly in the center, at the edges and in corners should be sufficient:</span>
<span id="cb22-1077"><a href="#cb22-1077" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1078"><a href="#cb22-1078" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-1079"><a href="#cb22-1079" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-1080"><a href="#cb22-1080" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-1081"><a href="#cb22-1081" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb22-1082"><a href="#cb22-1082" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1083"><a href="#cb22-1083" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">20</span>))</span>
<span id="cb22-1084"><a href="#cb22-1084" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1085"><a href="#cb22-1085" aria-hidden="true" tabindex="-1"></a>offsets <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">15</span>]</span>
<span id="cb22-1086"><a href="#cb22-1086" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> Pool(<span class="dv">9</span>) <span class="im">as</span> p:</span>
<span id="cb22-1087"><a href="#cb22-1087" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> p.starmap(eval_circuit, <span class="bu">zip</span>(</span>
<span id="cb22-1088"><a href="#cb22-1088" aria-hidden="true" tabindex="-1"></a>        <span class="bu">map</span>(<span class="kw">lambda</span> x: <span class="bu">list</span>(x), product(offsets, offsets)),  <span class="co"># states</span></span>
<span id="cb22-1089"><a href="#cb22-1089" aria-hidden="true" tabindex="-1"></a>        repeat(U),  <span class="co"># U</span></span>
<span id="cb22-1090"><a href="#cb22-1090" aria-hidden="true" tabindex="-1"></a>        repeat([N, N]),  <span class="co"># ranges</span></span>
<span id="cb22-1091"><a href="#cb22-1091" aria-hidden="true" tabindex="-1"></a>        repeat([<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>]),  <span class="co"># offsets</span></span>
<span id="cb22-1092"><a href="#cb22-1092" aria-hidden="true" tabindex="-1"></a>        repeat(<span class="bn">0b1110000111100001</span>),  <span class="co"># postselection mask</span></span>
<span id="cb22-1093"><a href="#cb22-1093" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb22-1094"><a href="#cb22-1094" aria-hidden="true" tabindex="-1"></a>    matrices, normalizations <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>results)</span>
<span id="cb22-1095"><a href="#cb22-1095" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> plot_i, plot_j <span class="kw">in</span> product(<span class="bu">range</span>(<span class="dv">3</span>), <span class="bu">range</span>(<span class="dv">3</span>)):</span>
<span id="cb22-1096"><a href="#cb22-1096" aria-hidden="true" tabindex="-1"></a>        im <span class="op">=</span> ax[plot_i, plot_j].imshow(np.real(matrices[<span class="dv">3</span> <span class="op">*</span> plot_i <span class="op">+</span> plot_j]))</span>
<span id="cb22-1097"><a href="#cb22-1097" aria-hidden="true" tabindex="-1"></a>        fig.colorbar(im, ax<span class="op">=</span>ax[plot_i, plot_j])</span>
<span id="cb22-1098"><a href="#cb22-1098" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1099"><a href="#cb22-1099" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-1100"><a href="#cb22-1100" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb22-1101"><a href="#cb22-1101" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-1102"><a href="#cb22-1102" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-1103"><a href="#cb22-1103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1104"><a href="#cb22-1104" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/example_visualization_two_dim.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-1105"><a href="#cb22-1105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1106"><a href="#cb22-1106" aria-hidden="true" tabindex="-1"></a>We can again add some initialization code to see how the circuit operates on other input:</span>
<span id="cb22-1107"><a href="#cb22-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1108"><a href="#cb22-1108" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-1109"><a href="#cb22-1109" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-1110"><a href="#cb22-1110" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-1111"><a href="#cb22-1111" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb22-1112"><a href="#cb22-1112" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-1113"><a href="#cb22-1113" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">4</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">4</span>)])</span>
<span id="cb22-1114"><a href="#cb22-1114" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb22-1115"><a href="#cb22-1115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1116"><a href="#cb22-1116" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb22-1117"><a href="#cb22-1117" aria-hidden="true" tabindex="-1"></a>j1 <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb22-1118"><a href="#cb22-1118" aria-hidden="true" tabindex="-1"></a>overflow1 <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb22-1119"><a href="#cb22-1119" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb22-1120"><a href="#cb22-1120" aria-hidden="true" tabindex="-1"></a>j2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb22-1121"><a href="#cb22-1121" aria-hidden="true" tabindex="-1"></a>overflow2 <span class="op">=</span> overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb22-1122"><a href="#cb22-1122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1123"><a href="#cb22-1123" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-1124"><a href="#cb22-1124" aria-hidden="true" tabindex="-1"></a><span class="co"># make sure qubits aren't optimized out</span></span>
<span id="cb22-1125"><a href="#cb22-1125" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> (n <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb22-1126"><a href="#cb22-1126" aria-hidden="true" tabindex="-1"></a>    prepare <span class="op">+=</span> tq.gates.Rx(angle<span class="op">=</span><span class="dv">0</span>, target<span class="op">=</span>i)</span>
<span id="cb22-1127"><a href="#cb22-1127" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j1[<span class="dv">1</span>])</span>
<span id="cb22-1128"><a href="#cb22-1128" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb22-1129"><a href="#cb22-1129" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-1130"><a href="#cb22-1130" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j2[<span class="dv">0</span>])</span>
<span id="cb22-1131"><a href="#cb22-1131" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j2[<span class="dv">1</span>])</span>
<span id="cb22-1132"><a href="#cb22-1132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1133"><a href="#cb22-1133" aria-hidden="true" tabindex="-1"></a>init, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>prepare, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>], postselection_mask<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb22-1134"><a href="#cb22-1134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1135"><a href="#cb22-1135" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> prepare <span class="op">+</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-1136"><a href="#cb22-1136" aria-hidden="true" tabindex="-1"></a>U <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-1137"><a href="#cb22-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1138"><a href="#cb22-1138" aria-hidden="true" tabindex="-1"></a>result, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>U, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>],</span>
<span id="cb22-1139"><a href="#cb22-1139" aria-hidden="true" tabindex="-1"></a>                         postselection_mask<span class="op">=</span><span class="bn">0b1110000111100001</span>)</span>
<span id="cb22-1140"><a href="#cb22-1140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1141"><a href="#cb22-1141" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb22-1142"><a href="#cb22-1142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1143"><a href="#cb22-1143" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Initialization"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-1144"><a href="#cb22-1144" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> ax[<span class="dv">0</span>].imshow(np.real(init))</span>
<span id="cb22-1145"><a href="#cb22-1145" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im0, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb22-1146"><a href="#cb22-1146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1147"><a href="#cb22-1147" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Result"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-1148"><a href="#cb22-1148" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> ax[<span class="dv">1</span>].imshow(np.real(result))</span>
<span id="cb22-1149"><a href="#cb22-1149" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im1, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb22-1150"><a href="#cb22-1150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1151"><a href="#cb22-1151" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-1152"><a href="#cb22-1152" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb22-1153"><a href="#cb22-1153" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-1154"><a href="#cb22-1154" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-1155"><a href="#cb22-1155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1156"><a href="#cb22-1156" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/example_visualization_init.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-1157"><a href="#cb22-1157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1158"><a href="#cb22-1158" aria-hidden="true" tabindex="-1"></a>In this example, you could also ignore the postselection because no values wrap around, so it doesn't have any effect.</span>
<span id="cb22-1159"><a href="#cb22-1159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1160"><a href="#cb22-1160" aria-hidden="true" tabindex="-1"></a><span class="fu">## LCU</span></span>
<span id="cb22-1161"><a href="#cb22-1161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1162"><a href="#cb22-1162" aria-hidden="true" tabindex="-1"></a>Lastly, we will see how to use a linear combination of unitaries to implement a weighted sum of Gaussian convolutions.</span>
<span id="cb22-1163"><a href="#cb22-1163" aria-hidden="true" tabindex="-1"></a>This is not part of the algorithm, so we will only look at this briefly, but it seems likely that usecases of Gaussian convolutions will require it, and it is fairly simple with the tools developed already.</span>
<span id="cb22-1164"><a href="#cb22-1164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1165"><a href="#cb22-1165" aria-hidden="true" tabindex="-1"></a>We will use the method described in @Guala_2015.</span>
<span id="cb22-1166"><a href="#cb22-1166" aria-hidden="true" tabindex="-1"></a>The PREP block there is the same block we built in the second chapter, and the selection operator can be implemented in the same way as the multi controlled rotations in the PREP operator, so we get the following code:</span>
<span id="cb22-1167"><a href="#cb22-1167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1168"><a href="#cb22-1168" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-1169"><a href="#cb22-1169" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-1170"><a href="#cb22-1170" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-1171"><a href="#cb22-1171" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lcu(</span>
<span id="cb22-1172"><a href="#cb22-1172" aria-hidden="true" tabindex="-1"></a>    circuits: Sequence[tq.QCircuit],</span>
<span id="cb22-1173"><a href="#cb22-1173" aria-hidden="true" tabindex="-1"></a>    coefficients: npt.NDArray[<span class="bu">float</span>],</span>
<span id="cb22-1174"><a href="#cb22-1174" aria-hidden="true" tabindex="-1"></a>    flags: Sequence[<span class="bu">int</span>],</span>
<span id="cb22-1175"><a href="#cb22-1175" aria-hidden="true" tabindex="-1"></a>    ancillae: Sequence[<span class="bu">int</span>]</span>
<span id="cb22-1176"><a href="#cb22-1176" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> tq.QCircuit:</span>
<span id="cb22-1177"><a href="#cb22-1177" aria-hidden="true" tabindex="-1"></a>    flags <span class="op">=</span> flags[:ceil(log2(<span class="bu">len</span>(circuits)))]</span>
<span id="cb22-1178"><a href="#cb22-1178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1179"><a href="#cb22-1179" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-1180"><a href="#cb22-1180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1181"><a href="#cb22-1181" aria-hidden="true" tabindex="-1"></a>    prep_values <span class="op">=</span> np.exp(np.angle(coefficients) <span class="op">*</span> <span class="ot">1j</span>) <span class="op">*</span> np.sqrt(np.<span class="bu">abs</span>(coefficients))</span>
<span id="cb22-1182"><a href="#cb22-1182" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(prep_values), target<span class="op">=</span>flags, ancillae<span class="op">=</span>ancillae)</span>
<span id="cb22-1183"><a href="#cb22-1183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1184"><a href="#cb22-1184" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (circuit, coefficient) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(circuits, coefficients)):</span>
<span id="cb22-1185"><a href="#cb22-1185" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> i <span class="op">^</span> (i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb22-1186"><a href="#cb22-1186" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(flags)):</span>
<span id="cb22-1187"><a href="#cb22-1187" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> diff <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j):</span>
<span id="cb22-1188"><a href="#cb22-1188" aria-hidden="true" tabindex="-1"></a>                U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>flags[<span class="op">-</span>j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-1189"><a href="#cb22-1189" aria-hidden="true" tabindex="-1"></a>        U <span class="op">+=</span> circuit.add_controls(flags)</span>
<span id="cb22-1190"><a href="#cb22-1190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1191"><a href="#cb22-1191" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle the case that the number of circuits is not a power of 2</span></span>
<span id="cb22-1192"><a href="#cb22-1192" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(flags)):</span>
<span id="cb22-1193"><a href="#cb22-1193" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (<span class="bu">len</span>(circuits) <span class="op">-</span> <span class="dv">1</span>) <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j):</span>
<span id="cb22-1194"><a href="#cb22-1194" aria-hidden="true" tabindex="-1"></a>            U <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>flags[<span class="op">-</span>j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb22-1195"><a href="#cb22-1195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1196"><a href="#cb22-1196" aria-hidden="true" tabindex="-1"></a>    unprep_values <span class="op">=</span> np.sqrt(np.<span class="bu">abs</span>(coefficients))</span>
<span id="cb22-1197"><a href="#cb22-1197" aria-hidden="true" tabindex="-1"></a>    U <span class="op">+=</span> prepare_state(state<span class="op">=</span>array_to_state(unprep_values), target<span class="op">=</span>flags, ancillae<span class="op">=</span>ancillae).dagger()</span>
<span id="cb22-1198"><a href="#cb22-1198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1199"><a href="#cb22-1199" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> U</span>
<span id="cb22-1200"><a href="#cb22-1200" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-1201"><a href="#cb22-1201" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-1202"><a href="#cb22-1202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1203"><a href="#cb22-1203" aria-hidden="true" tabindex="-1"></a>As a simple example, we can reuse the previous two dimensional circuit, but add a second convolution with the same values but slightly shifted.</span>
<span id="cb22-1204"><a href="#cb22-1204" aria-hidden="true" tabindex="-1"></a>We give a negative coefficient to this new convolution, and double the weight of the original convolution:</span>
<span id="cb22-1205"><a href="#cb22-1205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1206"><a href="#cb22-1206" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;details&gt;</span></span>
<span id="cb22-1207"><a href="#cb22-1207" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;summary&gt;</span> Code <span class="kw">&lt;/summary&gt;</span></span>
<span id="cb22-1208"><a href="#cb22-1208" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb22-1209"><a href="#cb22-1209" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb22-1210"><a href="#cb22-1210" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> n</span>
<span id="cb22-1211"><a href="#cb22-1211" aria-hidden="true" tabindex="-1"></a>diags <span class="op">=</span> np.array([exp(<span class="op">-</span>i <span class="op">*</span> i <span class="op">/</span> <span class="dv">4</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dv">4</span>)])</span>
<span id="cb22-1212"><a href="#cb22-1212" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> ceil(log2(<span class="bu">len</span>(diags)))</span>
<span id="cb22-1213"><a href="#cb22-1213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1214"><a href="#cb22-1214" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="bu">range</span>(d)</span>
<span id="cb22-1215"><a href="#cb22-1215" aria-hidden="true" tabindex="-1"></a>j1 <span class="op">=</span> <span class="bu">range</span>(d, d <span class="op">+</span> n)</span>
<span id="cb22-1216"><a href="#cb22-1216" aria-hidden="true" tabindex="-1"></a>overflow1 <span class="op">=</span> d <span class="op">+</span> n</span>
<span id="cb22-1217"><a href="#cb22-1217" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb22-1218"><a href="#cb22-1218" aria-hidden="true" tabindex="-1"></a>j2 <span class="op">=</span> <span class="bu">range</span>(overflow1 <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>, overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb22-1219"><a href="#cb22-1219" aria-hidden="true" tabindex="-1"></a>overflow2 <span class="op">=</span> overflow1 <span class="op">+</span> d <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb22-1220"><a href="#cb22-1220" aria-hidden="true" tabindex="-1"></a>lcu_flag <span class="op">=</span> overflow2 <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb22-1221"><a href="#cb22-1221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1222"><a href="#cb22-1222" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">=</span> tq.QCircuit()</span>
<span id="cb22-1223"><a href="#cb22-1223" aria-hidden="true" tabindex="-1"></a><span class="co"># make sure qubits aren't optimized out</span></span>
<span id="cb22-1224"><a href="#cb22-1224" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> (n <span class="op">+</span> d <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb22-1225"><a href="#cb22-1225" aria-hidden="true" tabindex="-1"></a>    prepare <span class="op">+=</span> tq.gates.Rx(angle<span class="op">=</span><span class="dv">0</span>, target<span class="op">=</span>i)</span>
<span id="cb22-1226"><a href="#cb22-1226" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j1[<span class="dv">1</span>])</span>
<span id="cb22-1227"><a href="#cb22-1227" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb22-1228"><a href="#cb22-1228" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j1[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb22-1229"><a href="#cb22-1229" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.H(target<span class="op">=</span>j2[<span class="dv">0</span>])</span>
<span id="cb22-1230"><a href="#cb22-1230" aria-hidden="true" tabindex="-1"></a>prepare <span class="op">+=</span> tq.gates.X(target<span class="op">=</span>j2[<span class="dv">1</span>])</span>
<span id="cb22-1231"><a href="#cb22-1231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1232"><a href="#cb22-1232" aria-hidden="true" tabindex="-1"></a>init, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>prepare, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">1</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">2</span>], postselection_mask<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb22-1233"><a href="#cb22-1233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1234"><a href="#cb22-1234" aria-hidden="true" tabindex="-1"></a>U1 <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-1235"><a href="#cb22-1235" aria-hidden="true" tabindex="-1"></a>U1 <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb22-1236"><a href="#cb22-1236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1237"><a href="#cb22-1237" aria-hidden="true" tabindex="-1"></a>U2 <span class="op">=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j1, ancillae<span class="op">=</span>s1, overflow<span class="op">=</span>overflow1, offset<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb22-1238"><a href="#cb22-1238" aria-hidden="true" tabindex="-1"></a>U2 <span class="op">+=</span> toeplitz_matrix(diags<span class="op">=</span>diags, target<span class="op">=</span>j2, ancillae<span class="op">=</span>s2, overflow<span class="op">=</span>overflow2, offset<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-1239"><a href="#cb22-1239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1240"><a href="#cb22-1240" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> prepare <span class="op">+</span> lcu(circuits<span class="op">=</span>[U1, U2], coefficients<span class="op">=</span>np.array([<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>]), flags<span class="op">=</span>[lcu_flag], ancillae<span class="op">=</span><span class="bu">range</span>(lcu_flag))</span>
<span id="cb22-1241"><a href="#cb22-1241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1242"><a href="#cb22-1242" aria-hidden="true" tabindex="-1"></a>result, _ <span class="op">=</span> eval_circuit(states<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>], U<span class="op">=</span>U, ranges<span class="op">=</span>[N, N], offsets<span class="op">=</span>[<span class="dv">2</span>, n <span class="op">+</span> d <span class="op">+</span> <span class="dv">3</span>],</span>
<span id="cb22-1243"><a href="#cb22-1243" aria-hidden="true" tabindex="-1"></a>                         postselection_mask<span class="op">=</span><span class="bn">0b11100001111000011</span>)</span>
<span id="cb22-1244"><a href="#cb22-1244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1245"><a href="#cb22-1245" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb22-1246"><a href="#cb22-1246" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">"Initialization"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-1247"><a href="#cb22-1247" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> ax[<span class="dv">0</span>].imshow(np.real(init))</span>
<span id="cb22-1248"><a href="#cb22-1248" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im0, ax<span class="op">=</span>ax[<span class="dv">0</span>])</span>
<span id="cb22-1249"><a href="#cb22-1249" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">"Result"</span>, fontsize<span class="op">=</span><span class="dv">24</span>)</span>
<span id="cb22-1250"><a href="#cb22-1250" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> ax[<span class="dv">1</span>].imshow(np.real(result))</span>
<span id="cb22-1251"><a href="#cb22-1251" aria-hidden="true" tabindex="-1"></a>fig.colorbar(im1, ax<span class="op">=</span>ax[<span class="dv">1</span>])</span>
<span id="cb22-1252"><a href="#cb22-1252" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb22-1253"><a href="#cb22-1253" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb22-1254"><a href="#cb22-1254" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/details&gt;</span></span>
<span id="cb22-1255"><a href="#cb22-1255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1256"><a href="#cb22-1256" aria-hidden="true" tabindex="-1"></a><span class="al">![](img/lcu_example.png)</span>{width=100% fig-align="center"}</span>
<span id="cb22-1257"><a href="#cb22-1257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1258"><a href="#cb22-1258" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb22-1259"><a href="#cb22-1259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1260"><a href="#cb22-1260" aria-hidden="true" tabindex="-1"></a>In this post, we have seen how we can implement a Gaussian convolution on a quantum superposition.</span>
<span id="cb22-1261"><a href="#cb22-1261" aria-hidden="true" tabindex="-1"></a>For this we developed circuits which can prepare arbitrary states, add a value in a register to another register, and add a constant to a register.</span>
<span id="cb22-1262"><a href="#cb22-1262" aria-hidden="true" tabindex="-1"></a>Combining these three operations allowed us to implement any Toeplitz matrix, including one dimensional Gaussian convolutions.</span>
<span id="cb22-1263"><a href="#cb22-1263" aria-hidden="true" tabindex="-1"></a>Since Gaussian convolutions are separable, we were able to simply run this algorithm multiple times in parallel to extend it to multiple dimensions.</span>
<span id="cb22-1264"><a href="#cb22-1264" aria-hidden="true" tabindex="-1"></a>We have also briefly seen that it is possibly to combine multiple convolutions to weighted sums of convolutions.</span>
<span id="cb22-1265"><a href="#cb22-1265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1266"><a href="#cb22-1266" aria-hidden="true" tabindex="-1"></a>To be efficient, we need to approximate the convolution by cutting it off after a certain number of values, but this should rarely be an issue because of how quickly the coefficients of a Gaussian convolution drop towards $0$.</span>
<span id="cb22-1267"><a href="#cb22-1267" aria-hidden="true" tabindex="-1"></a>We achieved asymptotic rotation and Toffoli gate count of $O(D \log(D) + n \log(n))$ for the one dimensional convolution, where $D$ is the number of values that are considered, and $n$ is the number of input and output qubits.</span>
<span id="cb22-1268"><a href="#cb22-1268" aria-hidden="true" tabindex="-1"></a>By borrowing qubits which are already in use, the algorithm is able to avoid using dedicated ancilla qubits in most places.</span>
<span id="cb22-1269"><a href="#cb22-1269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1270"><a href="#cb22-1270" aria-hidden="true" tabindex="-1"></a>Despite these favourable characteristics, there is likely to be much room for optimization, particularly for the large constant factors.</span>
<span id="cb22-1271"><a href="#cb22-1271" aria-hidden="true" tabindex="-1"></a>Also the decompositions here focused on Toffoli gates, it would be interesting to see what costs can be achieved with different operations instead, like single qubit rotations and CNOTs.</span>
<span id="cb22-1272"><a href="#cb22-1272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1273"><a href="#cb22-1273" aria-hidden="true" tabindex="-1"></a><span class="fu">## References</span></span>
<span id="cb22-1274"><a href="#cb22-1274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1275"><a href="#cb22-1275" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb22-1276"><a href="#cb22-1276" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb22-1277"><a href="#cb22-1277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-1278"><a href="#cb22-1278" aria-hidden="true" tabindex="-1"></a>The bibliography uses a citation style file from the CSL project: <span class="co">[</span><span class="ot">https://citationstyles.org/</span><span class="co">](https://citationstyles.org/)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center"><div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>