<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jonas Motyl">
<meta name="dcterms.date" content="2025-04-01">

<title>Tequila Tutorials - Automatic Decompositions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V7DRP5E70N"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-V7DRP5E70N', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"express",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  });
});
</script> 
  

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Tequila Tutorials - Automatic Decompositions">
<meta property="og:description" content="">
<meta property="og:image" content="https://github.com/tequilahub/tequila-tutorials/tutorials/AutomaticDecompositions/Figures/previewimage.png">
<meta property="og:site-name" content="Tequila Tutorials">
<meta property="og:image:height" content="1792">
<meta property="og:image:width" content="2486">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../tequila_logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Tequila Tutorials</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html" rel="" target="">
 <span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials.html" rel="" target="">
 <span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../FAQ/FAQ.html" rel="" target="">
 <span class="menu-text">FAQ</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Contribution/Contribution.html" rel="" target="">
 <span class="menu-text">Contribution</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../docs/sphinx/index.html" rel="" target="">
 <span class="menu-text">Docs</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Automatic Decompositions</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">code</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jonas Motyl </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 1, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#fully-disconnected-circuit-decoupled" id="toc-fully-disconnected-circuit-decoupled" class="nav-link" data-scroll-target="#fully-disconnected-circuit-decoupled">Fully disconnected circuit (decoupled)</a></li>
  <li><a href="#weakly-coupled-circuit" id="toc-weakly-coupled-circuit" class="nav-link" data-scroll-target="#weakly-coupled-circuit">Weakly coupled circuit</a>
  <ul class="collapse">
  <li><a href="#simplification-of-the-cross-terms" id="toc-simplification-of-the-cross-terms" class="nav-link" data-scroll-target="#simplification-of-the-cross-terms">Simplification of the cross terms</a></li>
  <li><a href="#overlap-implementation" id="toc-overlap-implementation" class="nav-link" data-scroll-target="#overlap-implementation">Overlap implementation</a></li>
  <li><a href="#weakly-coupled-implementation-and-comparison" id="toc-weakly-coupled-implementation-and-comparison" class="nav-link" data-scroll-target="#weakly-coupled-implementation-and-comparison">Weakly coupled implementation and comparison</a></li>
  </ul></li>
  <li><a href="#complexity-analysis" id="toc-complexity-analysis" class="nav-link" data-scroll-target="#complexity-analysis">Complexity analysis</a>
  <ul class="collapse">
  <li><a href="#decoupled-method" id="toc-decoupled-method" class="nav-link" data-scroll-target="#decoupled-method">Decoupled method</a></li>
  <li><a href="#weakly-coupled-method" id="toc-weakly-coupled-method" class="nav-link" data-scroll-target="#weakly-coupled-method">Weakly coupled method</a></li>
  </ul></li>
  <li><a href="#outlook-for-recursive-structures" id="toc-outlook-for-recursive-structures" class="nav-link" data-scroll-target="#outlook-for-recursive-structures">Outlook for recursive structures</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#appendix-visualization-of-testing-circuit" id="toc-appendix-visualization-of-testing-circuit" class="nav-link" data-scroll-target="#appendix-visualization-of-testing-circuit">Appendix: Visualization of Testing Circuit</a></li>
  <li><a href="#appendix-circuit-splitting-logic" id="toc-appendix-circuit-splitting-logic" class="nav-link" data-scroll-target="#appendix-circuit-splitting-logic">Appendix: Circuit splitting logic</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/tequilahub/tequila-tutorials/blob/main/tutorials/AutomaticDecompositions/index.qmd" class="toc-action">View source</a></p><p><a href="https://github.com/tequilahub/tequila-tutorials/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>During the calculation of expectation values of quantum circuits, a significant amount of computational time can be saved by decomposing the underlying circuit in an efficient manner. One prominent algorithm for this purpose is quantum circuit cutting, which divides a large quantum circuit into smaller, executable sub-circuits, processes them separately on quantum hardware, and then combines the results classically to approximate the output of the original circuit.</p>
Alternatively, a computationally less expensive approach involves leveraging specific structural properties of the circuit for decomposition. However, this method is only applicable when such structural characteristics are present. In this work, we present algorithms tailored for specific circuit structures and explore two distinct cases of circuit decomposition, demonstrating their implementation and advantages. The primary advantage of splitting circuits lies in the following structural considerations.
<center>
<img src="Figures/overview.PNG" class="img-fluid" width="700">
</center>
<p><br> Circuits are either split horizontally if it is in a fully disconnected form, or vertially if it has a weak link holding different parts together. For each disconnected subcircuit we can simplify the complexity of the calculations. Both structures benefit from horizontally disconnected subcircuits, however vertical decomposition imposes specific constraints on the unsplittable part <span class="math inline">\(B\)</span>, which must be expressible as a Pauli gate.</p>
</section>
<section id="fully-disconnected-circuit-decoupled" class="level1">
<h1>Fully disconnected circuit (decoupled)</h1>
<p>At first we look at the case <span class="math inline">\(U = AB\)</span>, where <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are entirely separate. In this scenario we can decompose the calculation of the expectation value <span class="math inline">\(\braket{H}_U\)</span>, by splitting our circuit horizontally. <span class="math display">\[  \braket{H}_U = \bra{0}U^\dagger H U\ket{0} \]</span> <span class="math display">\[ = \braket{H}_{AB} = \bra{0}(AB)^\dagger H (AB)\ket{0} \]</span> <span class="math display">\[ = \bra{0}A^\dagger H_A A\ket{0} + \bra{0}B^\dagger H_B B\ket{0} + \bra{0}(AB)^\dagger H_{AB} (AB)\ket{0} + c_H \]</span></p>
<p>Here we decomposed the Hamiltonian <span class="math inline">\(H = \sum_{k} c_k P_k\)</span>. <br> This is done by verifying whether all qubits of the Paulistring <span class="math inline">\(P_k\)</span> are a subset of the qubits in the subcircuits <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, if this condition is satisfied, we identify the corresponding Hamiltonians <span class="math inline">\(H_A\)</span> and <span class="math inline">\(H_B\)</span>. <br> If the qubits of <span class="math inline">\(P_k\)</span> span both qubit sets of the subcircuits, we classify it as a cross-term <span class="math inline">\(H_{AB}\)</span> with Paulistring <span class="math inline">\(P_k^{AB}\)</span>. The remaining <span class="math inline">\(c_H\)</span> represents the real-valued constant of the Hamiltonian. <br> This decomposition on it’s own does not reduce the complexity of the calculation yet. If we want to do so, we have to further decompose the cross-term <span class="math inline">\(H_{AB}\)</span>: <br> <span class="math display">\[H_{AB} = \sum_k c_k P_k^{AB}\]</span> with <span class="math inline">\(P_k^{AB} = P_k^A \otimes P_k^B\)</span>, where <span class="math inline">\(P_k^A\)</span> and <span class="math inline">\(P_k^B\)</span> are Paulistrings acting on the qubit sets of subcircuits <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, respectively, the expectation value of the cross term can be expressed in a decomposed form:</p>
<p><span class="math display">\[ \bra{0}(AB)^\dagger H_{AB} (AB)\ket{0} = \sum_k c_k \cdot (\bra{0}A^\dagger P_k^A A\ket{0} \cdot \bra{0}B^\dagger P_k^B B\ket{0}) \]</span> where <span class="math inline">\(c_k\)</span> is the coefficient of the partial Paulistring of <span class="math inline">\(H_{AB}\)</span>. <br> In the following we look at the decoupled decomposition implemented in Tequila and compare the calculation time against the computation with a full (undecomposed) circuit.</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tequila <span class="im">as</span> tq</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_horizontal(U):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Deconstructs a splitable Unitary into list of independent sub circuits.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    If not splitable it will return [U]</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    connections <span class="op">=</span> U.to_networkx()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    qubits <span class="op">=</span> <span class="bu">list</span>(nx.connected_components(connections))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    circuits <span class="op">=</span> []</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> qubits:</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        sub_circuit_gates <span class="op">=</span> [gate <span class="cf">for</span> gate <span class="kw">in</span> U.gates <span class="cf">if</span> <span class="bu">all</span>(q <span class="kw">in</span> c <span class="cf">for</span> q <span class="kw">in</span> gate.qubits)]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        sub_circuit <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span>sub_circuit_gates)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        circuits.append(sub_circuit)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circuits</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_ab(H, circuits):</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">    Maps Hamiltonian parts to a (sub) cuircuit as a local term or stores the cross terms and</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">    calculates the Expectation Values with each local and cross term.</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    local_terms <span class="op">=</span> []</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    cross_terms <span class="op">=</span> []</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    constant <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ps <span class="kw">in</span> H.paulistrings:</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        qubits <span class="op">=</span> ps.qubits</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        isCross <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(qubits) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>            constant <span class="op">+=</span> ps.coeff </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> circuit <span class="kw">in</span> circuits:</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># check if local or cross term</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">set</span>(qubits).issubset(<span class="bu">set</span>(circuit.qubits)):       </span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>                local_terms.append((circuit, ps))</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>                isCross <span class="op">=</span> <span class="va">False</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span> </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> isCross: cross_terms.append(ps)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">=</span> <span class="bu">float</span>(constant.real)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">+=</span> calculate_local(local_terms)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">+=</span> calculate_cross(circuits, cross_terms)      </span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_local(local_terms):</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the local terms where the list local_terms containts tuples of </span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co">    a (sub) curcuit and the corresponding Pauli-Strings of the Hamiltonian.</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (circuit, ps) <span class="kw">in</span> local_terms:</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        H <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings(ps)</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(q <span class="kw">in</span> circuit.qubits <span class="cf">for</span> q <span class="kw">in</span> H.qubits):</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"!!!"</span>)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">+=</span>  tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>circuit)</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_cross(circuits, cross_terms):</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the cross terms.</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="co">    Stores calculation results in dict to avoid the calculation of duplicates.</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    all_expvals <span class="op">=</span> {}</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ps <span class="kw">in</span> cross_terms:</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        parts <span class="op">=</span> []</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        used <span class="op">=</span> {i:<span class="va">False</span> <span class="cf">for</span> i <span class="kw">in</span> ps.qubits}</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        tmp <span class="op">=</span> <span class="bu">float</span>(ps.coeff.real)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> circuit <span class="kw">in</span> circuits:</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>            lc <span class="op">=</span> {}</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> q <span class="kw">in</span> ps.qubits:</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> q <span class="kw">in</span> circuit.qubits:</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>                    lc[q] <span class="op">=</span> ps[q]</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>                    used[q] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>            parts.append(lc) </span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(used.values()):</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>                care <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> used <span class="cf">if</span> <span class="kw">not</span> used[i]]</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>([ps[q] <span class="op">==</span><span class="st">'Z'</span> <span class="cf">for</span> q <span class="kw">in</span> care]):</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(circuits)):</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>            ui <span class="op">=</span> circuits[i]</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>            hi <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings(tq.PauliString(parts[i]))</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(hi) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>            key <span class="op">=</span> (<span class="bu">str</span>(hi), i)</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> key <span class="kw">in</span> all_expvals:</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>                ei <span class="op">=</span> all_expvals[key]</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>                ei <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>hi, U<span class="op">=</span>ui)</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>                all_expvals[key] <span class="op">=</span> ei</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>            tmp <span class="op">*=</span> ei</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">+=</span> tmp</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<center>
<img src="Figures/Figure_1.png" class="img-fluid" width="600">
</center>
<p>The figure illustrates the performance difference between the classical expectation value calculation on the full circuit and the proposed method for exploiting decoupled circuit structures. From the results, we observe a significant computational advantage for circuits with more than <span class="math inline">\(16\)</span> qubits. <br> The circuits were split into two parts, reducing the computational complexity of each subcircuit to half of the original complexity. We can see that the computational expense for preparing and splitting the circuit, compared to the overall computational time, becomes negligible for higher qubit counts but remains significant for smaller circuits.</p>
</section>
<section id="weakly-coupled-circuit" class="level1">
<h1>Weakly coupled circuit</h1>
<p>Now we aim to decompose a circuit with the form <span class="math inline">\(\text{U = ABC}\)</span>, where <span class="math inline">\(B\)</span> is a small component that couples the entire circuit and has the form: <span class="math display">\[B = e^{-i\cdot\frac{\theta}{2}\cdot P}\]</span></p>
<p>Here, <span class="math inline">\(P\)</span> is a Paulistring with length <span class="math inline">\(n\)</span> and <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> are independent, but each connected to <span class="math inline">\(B\)</span>. Since <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> contain fully disconnected parts, we can apply our horizontal decomposition method to each, thereby achieving a computational advantage. To fully decouple the circuit, we deconstruct <span class="math inline">\(B\)</span> into <span class="math inline">\(n\)</span> individual Pauligates.</p>
<center>
<img src="Figures/pauli.png" class="img-fluid" width="480">
</center>
<p><br> The new Pauligates are all single-qubit gates, making them highly suitable for the horizontal decomposition. During the preperation of the subcircuits, they can be assigned to their respective groups with minimal effort.<br> Now lets look at the deconstruction for <span class="math inline">\(B = e^{-i\cdot\frac{\theta}{2}\cdot P} = cos(\frac{\theta}{2}) - i \cdot sin(\frac{\theta}{2})\cdot P\)</span>:</p>
<p><span class="math display">\[ ABC =  cos(\frac{\theta}{2}) \cdot AC - i \cdot sin(\frac{\theta}{2})\cdot APC\]</span></p>
<p>For simplicity lets call <span class="math inline">\(cos(\frac{\theta}{2}) = a\)</span> and <span class="math inline">\(sin(\frac{\theta}{2}) = b\)</span>. <br> We can then construct the expectation value <span class="math inline">\(\braket{H}_U = \bra{0}(ABC)^{\dagger} H \: ABC \ket{0}\)</span> out of this: <span class="math display">\[ = a^2 \cdot \bra{0}(AC)^\dagger H \: AC\ket{0} + b^2 \cdot \bra{0}(APC)^\dagger H \: APC \ket{0} \]</span> <span class="math display">\[ - abi \cdot \bra{0}(AC)^\dagger H \: APC \ket{0} + abi \cdot \bra{0}(APC)^\dagger H \: AC \ket{0} \]</span></p>
<p>We split the calculation into four parts. The first two expectation values can now be calculated using the previously mentioned decoupled method. The remaining terms are overlaps, which we refer to as cross terms.</p>
<section id="simplification-of-the-cross-terms" class="level2">
<h2 class="anchored" data-anchor-id="simplification-of-the-cross-terms">Simplification of the cross terms</h2>
<p>The cross terms form an imaginary scalar. Since these terms are Hermitian conjugates, they can be rewritten in a simpler form. For any complex number <span class="math inline">\(x + y \cdot i\)</span> and its complex conjugate, the following identity holds: <span class="math inline">\((x+y\cdot i) - (x-y\cdot i) = 2yi = 2i \cdot \textbf{Im}(x+y\cdot i)\)</span>, <br> where <span class="math inline">\(\textbf{Im}(\cdot)\)</span> denotes the imaginary component of a complex number. Applying this identity to our cross terms yields:</p>
<p><span class="math display">\[ - abi \cdot \bra{0}(A C)^\dagger H \: A P C \ket{0} + abi \cdot \bra{0}(A P C)^\dagger H \: A C \ket{0} \]</span> <span class="math display">\[ = - abi \cdot (\bra{0}(A C)^\dagger H \: A P C \ket{0} - abi \cdot \bra{0}(A P C)^\dagger H \: A C \ket{0}) \]</span> <span class="math display">\[ = - abi \cdot (\bra{0}(A C)^\dagger H \: A P C \ket{0} - h.c) \]</span> <span class="math display">\[ = - abi \cdot (2i \cdot\textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0})) \]</span> <span class="math display">\[ = 2ab\cdot \textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0}) \]</span></p>
<p>This transformation reduces the number of required steps and results in a real value. Therefore, the total expectation value <span class="math inline">\(\braket{H}_U\)</span> is given by: <span class="math display">\[  a^2 \cdot \bra{0}(AC)^\dagger H \: AC\ket{0} + b^2 \cdot \bra{0}(APC)^\dagger H \: APC \ket{0} + 2ab\cdot \textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0})  \]</span></p>
<p>For our decomposition approach, the implementation would follow this structure:</p>
<div class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_abc(H, A, B, C):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the given Hamiltonian H and the Unitary U = A*B*C</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    with the ABC-Formula.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    psi, P <span class="op">=</span> h.convert_to_pauli(B)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Our Calculation:</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.cos)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.sin)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    a_term <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>A<span class="op">+</span>C)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    b_term <span class="op">=</span>  tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>A<span class="op">+</span>P<span class="op">+</span>C)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    local_term <span class="op">=</span> (a<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> a_term <span class="op">+</span> (b<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> b_term </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    _, img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>A<span class="op">+</span>C, ket<span class="op">=</span>A<span class="op">+</span>P<span class="op">+</span>C, operator<span class="op">=</span>H)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    cross_term <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>a<span class="op">*</span>b<span class="op">*</span>(img)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> local_term <span class="op">+</span> cross_term</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="overlap-implementation" class="level2">
<h2 class="anchored" data-anchor-id="overlap-implementation">Overlap implementation</h2>
<p>So far, we have not exploited the circuit structure in our cross-term calculations. This is critical because it could become a bottleneck for the overall computational complexity.</p>
<p>We know that the overlap we created <span class="math inline">\(\bra{0}(A C)^\dagger H \: A P C \ket{0}\)</span>, is splitable. Lets split <span class="math inline">\(AC\)</span> into an <span class="math inline">\(\textbf{Upper}\)</span> and <span class="math inline">\(\textbf{Lower}\)</span> part of the full circuit. We call the parts of <span class="math inline">\(APC\)</span> the same, but mark them as <span class="math inline">\(\textbf{Upper'}\)</span> and <span class="math inline">\(\textbf{Lower'}\)</span> because they contain the extra Pauli gates from the decomposition of the circuit component <span class="math inline">\(B\)</span> that couples <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span>.</p>
Before simplification, we must examine the standard BraKet <span class="math inline">\(\braket{\psi | \phi}\)</span> implementation. <br> The BraKet overlap gets constructed in the following circuit, such that it is able to calculate the overlap between two states.
<center>
<img src="Figures/circuit.png" class="img-fluid" width="600">
</center>
<p><br></p>
<p>For simplicity we depict the <span class="math inline">\(\textbf{Upper}\)</span> part as Unitary <span class="math inline">\(U\)</span> and <span class="math inline">\(\textbf{Lower}\)</span> as <span class="math inline">\(L\)</span>. <br> The calculation requires an auxiliary qubit to control the execution of these subcircuits. While this adds some overhead, the computational advantage becomes significant when <span class="math inline">\(U\)</span> and <span class="math inline">\(L\)</span> are sufficiently large, as the complexity reduction from processing them separately outweighs the control cost. We achive this with following method. <br> We define the overlap <span class="math inline">\(\braket{\psi_0 | \psi_1}\)</span> between <span class="math inline">\(U \otimes L\)</span> and the slightly modified <span class="math inline">\(U' \otimes L'\)</span> (containing the extra Pauli gates). These form following states: <span class="math display">\[ (U \otimes L)\ket{0} = \ket{\psi_{0}}, \: \: \: (U' \otimes L') \ket{0} = \ket{\psi_1}\]</span> After the second Hadamard gate of the auxiliary, the circuit prepares the state: <span class="math display">\[ \frac{1}{\sqrt{2}} \cdot (\ket{+} \ket{\psi_0} + \ket{-} \ket{\psi_1})\]</span> This is because the <span class="math inline">\(X\)</span> gates of the auxiliary qubit control / anti control - <span class="math inline">\(\ket{\psi_{0}}\)</span> and <span class="math inline">\(\ket{\psi_{1}}\)</span>. <br> In the end measuring the ancilla with Pauli <span class="math inline">\(Z\)</span> (displayed as measurement symbol above) gives as output: <span class="math display">\[ \bra{0}(U \otimes L)^{\dagger} (U' \otimes L') \ket{0} = \braket{\psi_0 | \psi_1} \]</span></p>
<p>This however can further be simplified analytically to exploit the structure of <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span>:</p>
<p><span class="math display">\[ \frac{1}{\sqrt{2}} \cdot (\ket{+} \otimes (U \otimes L \: \ket{0})) + \frac{1}{\sqrt{2}} \cdot (\ket{-} \otimes (U' \otimes L' \: \ket{0})) \equiv \ket{\psi}\]</span></p>
<p><span class="math display">\[ \bra{\psi} Z \otimes 1 \otimes 1 \ket{\psi} = \]</span></p>
<p><span class="math display">\[\frac{1}{2} \cdot \bra{+}Z\ket{+} \cdot \: ... + \frac{1}{2} \cdot \bra{-}Z\ket{-} \cdot \: ... + \frac{1}{2}\cdot \bra{+}Z\ket{-}\cdot \bra{0}(U \otimes L) \: (U' \otimes L')\ket{0}  + \frac{1}{2}\cdot \bra{-}Z\ket{+}\cdot \bra{0}(U' \otimes L') \: (U \otimes L)\ket{0}\]</span> <span class="math display">\[ = 0 + 0 + \frac{1}{2}\cdot 1 \cdot \bra{0}(U \: U') \ket{0} \cdot \bra{0}(L \: L') \ket{0} + \frac{1}{2}\cdot 1 \cdot \bra{0}(U' \: U) \ket{0} \cdot \bra{0}(L' \: L) \ket{0} \]</span></p>
</section>
<section id="weakly-coupled-implementation-and-comparison" class="level2">
<h2 class="anchored" data-anchor-id="weakly-coupled-implementation-and-comparison">Weakly coupled implementation and comparison</h2>
<p>With every previously described step we can now implement the weakly coupled decomposition to exploit a circuit’s structure for a computational advantage. The core functionality resides in the function <strong>calculate_abc</strong>, which handles the primary decomposition calculation. Because <span class="math inline">\(\textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0})\)</span> forms an overlap, <strong>small_braket</strong> gets called to further reduce the complexity.</p>
<div class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_pauli(U: tq.gates.ExpPauli):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Converts an Exponential Pauli U of form e^(-i*angle/2 *P) to: angle and PauliGate P.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Restrictions:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - only one or no angle allowed</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">map</span> <span class="op">=</span> U.make_parameter_map()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    angle_parameters <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>.keys())</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(angle_parameters) <span class="op">&gt;</span> <span class="dv">1</span> <span class="kw">or</span> <span class="bu">len</span>(U.gates) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(angle_parameters) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        angle <span class="op">=</span> <span class="va">None</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        angle <span class="op">=</span> tq.Variable(angle_parameters[<span class="dv">0</span>])</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> angle, tq.gates.PauliGate(U.gates[<span class="dv">0</span>].paulistring)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_abc(H, A, B, C):</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the given Hamiltonian H and the Unitary U = A*B*C</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co">    with the ABC-Formula.</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Do the decomposition</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    psi, P <span class="op">=</span> convert_to_pauli(B)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    ac_up, ac_down <span class="op">=</span> split_2(A<span class="op">+</span>C)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    apc_up, apc_down <span class="op">=</span> split_2(A<span class="op">+</span>P<span class="op">+</span>C)</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculation of every part:</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.cos)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.sin)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    a_term <span class="op">=</span> ab.calculate_ab(circuits<span class="op">=</span>[ac_up, ac_down], H<span class="op">=</span>H)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    b_term <span class="op">=</span> ab.calculate_ab(circuits<span class="op">=</span>[apc_up, apc_down], H<span class="op">=</span>H)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    local_term <span class="op">=</span> (a<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> a_term <span class="op">+</span> (b<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> b_term </span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    _, img <span class="op">=</span> small_braket(ac_up, ac_down, apc_up, apc_down, H)</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    cross_term <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>a<span class="op">*</span>b<span class="op">*</span>(img)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> local_term <span class="op">+</span> cross_term</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> small_braket(bra_up, bra_down, ket_up, ket_down, H):</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates Overlap of the form &lt;|(AC)^{\dagger} H APC|&gt; or &lt;|(ACP)^{\dagger} H AC|&gt;.</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes A and C to be horizontally splitable.</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    result_r <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    result_i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ps <span class="kw">in</span> H.paulistrings:</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>        up_ps <span class="op">=</span> {}</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>        down_ps <span class="op">=</span> {}</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> p <span class="kw">in</span> ps.qubits:</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p <span class="kw">in</span> ket_up.qubits <span class="kw">or</span> p <span class="kw">in</span> bra_up.qubits:</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>                up_ps[p] <span class="op">=</span> ps[p]</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p <span class="kw">in</span> ket_down.qubits <span class="kw">or</span> p <span class="kw">in</span> bra_down.qubits:</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>                down_ps[p] <span class="op">=</span> ps[p]</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>        coeff <span class="op">=</span> <span class="bu">float</span>(ps.coeff.real)</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>        h_up <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings([tq.PauliString(up_ps)])</span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>        h_down <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings([tq.PauliString(down_ps)])</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>        a_real, a_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>bra_up, ket<span class="op">=</span>ket_up, operator<span class="op">=</span>h_up)</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>        b_real, b_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>bra_down, ket<span class="op">=</span>ket_down, operator<span class="op">=</span>h_down)</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>        c_real, c_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>ket_up, ket<span class="op">=</span>bra_up, operator<span class="op">=</span>h_up)</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>        d_real, d_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>ket_down, ket<span class="op">=</span>bra_down, operator<span class="op">=</span>h_down)</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>        result_r <span class="op">+=</span> <span class="fl">0.5</span><span class="op">*</span>(a_real<span class="op">*</span>b_real <span class="op">-</span> a_img<span class="op">*</span>b_img) <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>(c_real<span class="op">*</span>d_real <span class="op">-</span> c_img<span class="op">*</span>d_img)</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(down_ps) <span class="op">==</span> <span class="dv">0</span>: <span class="co"># Hamiltonian only acts on the upper parts</span></span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>            result_i <span class="op">+=</span> <span class="fl">0.5</span><span class="op">*</span>a_img <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>c_img</span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(up_ps) <span class="op">==</span> <span class="dv">0</span>: <span class="co"># " - lower parts</span></span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>            result_i <span class="op">+=</span> <span class="fl">0.5</span><span class="op">*</span>b_img <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>d_img</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>        result_ac <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> a_img <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> c_img</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>        result_bd <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> b_img <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> d_img</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>        result_i <span class="op">+=</span> coeff <span class="op">*</span> (result_ac <span class="op">*</span> result_bd)</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result_r, result_i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<center>
<img src="Figures/Figure_2.png" class="img-fluid" width="600">
</center>
<p>The figure illustrates the performance difference between the classical expectation value calculation and the proposed method for exploiting weakly coupled circuit structures. From the results, we observe that the computational advantage becomes significant only for circuits with more than <span class="math inline">\(&gt;20\)</span> qubits. <br> The complexity of the calculation was reduced to multiple factors of half the original complexity.</p>
</section>
</section>
<section id="complexity-analysis" class="level1">
<h1>Complexity analysis</h1>
<p>To evaluate the potential of our decomposition methods, we examine their computational complexity.</p>
<section id="decoupled-method" class="level2">
<h2 class="anchored" data-anchor-id="decoupled-method">Decoupled method</h2>
<p>The computational complexity follows directly from the state space reduction. For an <span class="math inline">\(n\)</span>-qubit circuit with <span class="math inline">\(2^n\)</span> basis states, decomposition in two equal subcircuits of size <span class="math inline">\(\frac{n}{2}\)</span> yeilds:</p>
<p><span class="math display">\[ 2^n \rightarrow 2\cdot 2^{\frac{n}{2}} \rightarrow \mathcal{O}(2^{\frac{n}{2}})\]</span></p>
<p>This represents the optimal case. For asymmetric splits where one (bigger) subcircuit contains <span class="math inline">\(m &lt; n\)</span> -qubits, the complexity becomes dominated by the larger partition: <span class="math inline">\(\mathcal{O}(2^{m}).\)</span></p>
</section>
<section id="weakly-coupled-method" class="level2">
<h2 class="anchored" data-anchor-id="weakly-coupled-method">Weakly coupled method</h2>
<p>In this case, the overall theoretical complexity is similar to that of the decoupled method, although with a greater number of subcircuits. To analyze this, we examine our decomposition:</p>
<p><span class="math display">\[  \braket{H}_U = a^2 \cdot \bra{0}(AC)^\dagger H \: AC\ket{0} + b^2 \cdot \bra{0}(APC)^\dagger H \: APC \ket{0} + 2ab\cdot \textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0}) \]</span></p>
<p>This involves the evaluation of two expectation values and an overlap, each requiring operations on the full circuit size. If <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> are splitable in two equal subcircuits, the overlap calculation involves four partial evaluations acting on half the qubits, but each requiring an auxiliary qubit: <span class="math display">\[  \frac{1}{2} \cdot \bra{0}(U \: U') \ket{0} \cdot \bra{0}(L \: L') \ket{0} + \frac{1}{2} \cdot \bra{0}(U' \: U) \ket{0} \cdot \bra{0}(L' \: L) \ket{0} \]</span></p>
<p>The total the complexity is <span class="math inline">\(2 \cdot ( 2 \cdot 2^{\frac{n}{2}} ) + 4 \cdot 2^{\frac{n}{2} + 1}\)</span>, where the first term accounts for splitting the two expectation values, each into two equally sized subcircuits, while the second term represents the evaluation of the deconstructed overlap acting on <span class="math inline">\(\frac{n}{2}+ 1\)</span> qubits, making the complexity <span class="math inline">\(\mathcal{O}(2^{\frac{n}{2} + 1})\)</span>. <br> For unequal splits, the complexity is determined by the larger partition (denoted by size <span class="math inline">\(m\)</span>), yielding a complexity of <span class="math inline">\(\mathcal{O}(2^{m + 1})\)</span>.</p>
<p>However in practice, the computation time is significantly influenced by the number of subcircuits required to construct the expectation values. This dependence arises primarily from the overhead associated with initializing computational objects for each subcircuit, which adds complexity to the overall calculation process. The above performance plots illustrate the circuit sizes for which this decomposition approach becomes computationally advantageous.</p>
</section>
</section>
<section id="outlook-for-recursive-structures" class="level1">
<h1>Outlook for recursive structures</h1>
A promising use case for our weakly coupled method involves circuits with multiple weak connections distributed throughout their structure. In such scenarios, we can adapt the core methodology by decomposing the circuit recursivly. Consider an example circuit with the following structure: <br>
<center>
<img src="Figures/outlook.png" class="img-fluid" width="480">
</center>
<p>We can see that <span class="math inline">\(ABC\)</span> follows the structure we have seen before, but <span class="math inline">\(C = A'B'C'\)</span> has the same structure in itself. Lets write out our decomposition with <span class="math inline">\(B = e^{-i\cdot\frac{\theta}{2}\cdot P}\)</span>:</p>
<p><span class="math display">\[  a^2 \cdot \bra{0}(AA'B'C')^\dagger H \: AA'B'C'\ket{0} + b^2 \cdot \bra{0}(APA'B'C')^\dagger H \: APA'B'C' \ket{0} \]</span> <span class="math display">\[ + 2ab \cdot \textbf{Im}(\bra{0}(A A'B'C')^\dagger H \: A P A'B'C' \ket{0}) \]</span></p>
<p>Here each element has the right structure for the weakly coupled decomposition with a single occuring weak link <span class="math inline">\(B'\)</span>, which can be decomposed in 8 smaller components like discussed in the previous chapter. For this we just summarize <span class="math inline">\(AA'\)</span> and <span class="math inline">\(APA'\)</span> to <span class="math inline">\(A_{\text{new}}\)</span> which both fullfill the requirements for our proposed weakly coupled decomposition.</p>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>Our proposed methods achieve substantial reductions in computation time through strategic circuit decomposition. By partitioning the original circuit into smaller subcircuits, we exponentially decrease the operational dimensionality, leading to significant complexity reduction. While this tutorial specifically examines the case of dividing <span class="math inline">\(n\)</span> qubits into two (for decoupled) / multiple (for weakly coupled) - subcircuits of <span class="math inline">\(\frac{n}{2}\)</span> qubits, the methods remain valid for any partition size that satisfies the structural requirements.</p>
<p>We focus on 2-way decomposition for two key reasons: <br></p>
<ul>
<li>The two-subcircuit case provides clearer demonstration while maintaining all essential features of the general approach</li>
<li>If the structural properties are given, we can recursively split the resulting circuits from the first decomposition as often as we want.</li>
</ul>
<p>From the performance comparison plots, we observe that a computational advantage is achieved for larger circuits, where the threshold in computational costs for creating multiple smaller circuits is exceeded. These methods show great promise for various computational tasks; however, they are highly dependent on the underlying circuit structure and do not provide a universal solution for arbitrary circuits.</p>
</section>
<section id="appendix-visualization-of-testing-circuit" class="level1">
<h1>Appendix: Visualization of Testing Circuit</h1>
<p>To test both calculation methods, suitable circuits were required. <br> For constructing fully disconnected test circuits, we begin by randomly assigning gates to an empty circuit acting on half the number of qubits in the target circuit. This circuit is then duplicated to create a second group acting on the remaining qubits. This will result in a circuit with two groups each only interacting with qubits in the same group, which makes it splitable with the fully disconnected method.</p>
<p>In the case of weakly coupled circuits, we follow the same initial construction process but introduce a coupling between the groups, at an arbitary point (in our example we choose the middle of the circuit). The coupling is implemented through a unitary operation of the form <span class="math inline">\(B = e^{-i\cdot\frac{\theta}{2}\cdot P}\)</span>, where the Paulistring <span class="math inline">\(P\)</span> is allowed to act on qubits of both groups. <br> The following figure shows an example circuit for testing the weakly coupled circuit calculation method, consisting of two groups with a total of 10 qubits. The groups are weakly linked by a Pauli gate (marked in pink).</p>
<center>
<img src="Figures/example10q.png" class="img-fluid" width="600">
</center>
<p>We also need a Hamiltonian to form our expectation value <span class="math inline">\(\braket{H}_U\)</span>. <br> For this we consider the two groups, <span class="math inline">\(X\)</span> acting on <span class="math inline">\(1,2, ... \frac{n}{2}\)</span> and <span class="math inline">\(Y\)</span> acting on <span class="math inline">\(\frac{n}{2} + 1, ... n-1, n\)</span>. <br> Our test Hamiltonian is then simply constructed with one Paulistring acting on each group and one Paulistring covering both groups: <span class="math display">\[H =  \bigotimes_{i \in X} Z(i) + \bigotimes_{j \in Y} Z(j) + \bigotimes_{k \in X \cup Y} Z(k) \]</span> So for the <span class="math inline">\(10\)</span> qubit case: <span class="math inline">\(H = Z(1)Z(2)Z(3)Z(4)Z(5) + Z(6)Z(7)Z(8)Z(9)Z(10) + Z(1)Z(2)Z(3)Z(4)Z(5)Z(6)Z(7)Z(8)Z(9)Z(10)\)</span></p>
</section>
<section id="appendix-circuit-splitting-logic" class="level1">
<h1>Appendix: Circuit splitting logic</h1>
<p>The logic for preparing the underlying circuit for the proposed calculation method can be done like this:</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_2(U):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Deconstructs a splitable Unitary into list of independent sub circuits.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    If not splitable it will return [U]</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    connections <span class="op">=</span> U.to_networkx()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    qubits <span class="op">=</span> <span class="bu">list</span>(nx.connected_components(connections))</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    circuits <span class="op">=</span> []</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> qubits:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        sub_circuit_gates <span class="op">=</span> [gate <span class="cf">for</span> gate <span class="kw">in</span> U.gates <span class="cf">if</span> <span class="bu">all</span>(q <span class="kw">in</span> c <span class="cf">for</span> q <span class="kw">in</span> gate.qubits)]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        sub_circuit <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span>sub_circuit_gates)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        circuits.append(sub_circuit)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circuits</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_n(U):</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Tries to Split a Unitary in either 1 (unsplitable), 2 (AB-structure), </span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co">    or 3 parts with ABC structure, where A and C are splitable but B is not.</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    A, rest <span class="op">=</span> check_right(tq.QCircuit(gates<span class="op">=</span>U.gates))</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> A <span class="kw">is</span> <span class="va">None</span>: <span class="co"># Unitary is not splitable</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [rest]</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    C, rest <span class="op">=</span> check_right(tq.QCircuit(gates<span class="op">=</span><span class="bu">list</span>(<span class="bu">reversed</span>(rest.gates))))</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span><span class="bu">list</span>(<span class="bu">reversed</span>(rest.gates)))</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> C <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [A, B] </span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span><span class="bu">list</span>(<span class="bu">reversed</span>(C.gates)))</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [A, B, C]</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check_right(U):</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="co">    Iterates through a QCircuit unitil it is splitable in reverse order.</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns either an Splitable and unsplitable part or None and unsplitable QCircuit.</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    test <span class="op">=</span> tq.QCircuit(U.gates)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    seperable <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="bu">len</span>(U.gates)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(test.gates) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        test.gates.pop()</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        count <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>        connections <span class="op">=</span> test.to_networkx()</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>        qubits <span class="op">=</span> <span class="bu">list</span>(nx.connected_components(connections))</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(<span class="bu">len</span>(qubits) <span class="op">&gt;</span> <span class="dv">1</span>):</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>            seperable <span class="op">=</span> test</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    rest <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span>U.gates[count:])</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> seperable, rest</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> decompose(H, U):</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a><span class="co">    Decomposes a Unitary U in (sub) circuits and calculates the Expectation Value in smaller steps.</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>    unitary_circuits <span class="op">=</span> cg.split_2(U)</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The Unitary was split into smaller parts for easy calc</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(unitary_circuits) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">=</span> ab.calculate_ab(H, unitary_circuits)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> exp</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: </span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The Unitary was not splitable</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>        circuits <span class="op">=</span> cg.split_n(U)</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(circuits) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Could not split the Unitary"</span>)</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U)</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(circuits) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>            A, B <span class="op">=</span> circuits</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>            C <span class="op">=</span> tq.QCircuit() <span class="co"># test with Identity</span></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>            abc.calculate_abc(H, A, B, C)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(circuits) <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>            A, B, C <span class="op">=</span> circuits</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>            abc.calculate_abc(H, A, B, C)</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Error: Could not calculate the Expectation Value"</span>)</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="tequilahub/tequila-tutorials" issue-term="pathname" theme="preferred-color-scheme" crossorigin="anonymous" async="">
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb5" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Automatic Decompositions"</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    - name: Jonas Motyl</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "April 2025"</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> "./Figures/previewimage.png"</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> [code]</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    html:</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">        code-fold: true</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">        eval: true</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">        hard_line_breaks: true</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">  warning: false</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>During the calculation of expectation values of quantum circuits, a significant amount of computational time can be saved by decomposing the underlying circuit in an efficient manner.</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>One prominent algorithm for this purpose is quantum circuit cutting, which divides a large quantum circuit into smaller, executable sub-circuits, processes them separately on quantum hardware, and then combines the results classically to approximate the output of the original circuit.</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>Alternatively, a computationally less expensive approach involves leveraging specific structural properties of the circuit for decomposition. However, this method is only applicable when such structural characteristics are present.</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>In this work, we present algorithms tailored for specific circuit structures and explore two distinct cases of circuit decomposition, demonstrating their implementation and advantages.</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>The primary advantage of splitting circuits lies in the following structural considerations.</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;center&gt;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="al">![](Figures/overview.PNG)</span>{width=700}</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/center&gt;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;br&gt;</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>Circuits are either split horizontally if it is in a fully disconnected form, or vertially if it has a weak link holding different parts together. </span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>For each disconnected subcircuit we can simplify the complexity of the calculations.</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>Both structures benefit from horizontally disconnected subcircuits, however vertical decomposition imposes specific constraints on the unsplittable part $B$, which must be expressible as a Pauli gate.</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="fu"># Fully disconnected circuit (decoupled)</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>At first we look at the case $U = AB$, where $A$ and $B$ are entirely separate. In this scenario we can decompose the calculation of the expectation value $\braket{H}_U$, by splitting our circuit horizontally.</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>$$  \braket{H}_U = \bra{0}U^\dagger H U\ket{0} $$</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>$$ = \braket{H}_{AB} = \bra{0}(AB)^\dagger H (AB)\ket{0} $$</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>$$ = \bra{0}A^\dagger H_A A\ket{0} + \bra{0}B^\dagger H_B B\ket{0} + \bra{0}(AB)^\dagger H_{AB} (AB)\ket{0} + c_H $$</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>Here we decomposed the Hamiltonian $H = \sum_{k}  c_k P_k$. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>This is done by verifying whether all qubits of the Paulistring $P_k$ are a subset of the qubits in the subcircuits $A$ and $B$,</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>if this condition is satisfied, we identify the corresponding Hamiltonians $H_A$ and $H_B$. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>If the qubits of $P_k$ span both qubit sets of the subcircuits, we classify it as a cross-term $H_{AB}$ with Paulistring $P_k^{AB}$.</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>The remaining $c_H$ represents the real-valued constant of the Hamiltonian. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>This decomposition on it's own does not reduce the complexity of the calculation yet. If we want to do so, we have to further decompose the cross-term $H_{AB}$: <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>$$H_{AB} = \sum_k c_k P_k^{AB}$$</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>with $P_k^{AB} = P_k^A \otimes P_k^B$, where $P_k^A$ and $P_k^B$ are Paulistrings acting on the qubit sets of subcircuits $A$ and $B$, respectively, the expectation value of the cross term can be expressed in a decomposed form:</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>$$ \bra{0}(AB)^\dagger H_{AB} (AB)\ket{0} = \sum_k c_k \cdot (\bra{0}A^\dagger P_k^A A\ket{0} \cdot \bra{0}B^\dagger P_k^B B\ket{0}) $$ </span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>where $c_k$ is the coefficient of the partial Paulistring of $H_{AB}$.  <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>In the following we look at the decoupled decomposition implemented in Tequila and compare the calculation time against the computation with a full (undecomposed) circuit.</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tequila <span class="im">as</span> tq</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_horizontal(U):</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a><span class="co">    Deconstructs a splitable Unitary into list of independent sub circuits.</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a><span class="co">    If not splitable it will return [U]</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>    connections <span class="op">=</span> U.to_networkx()</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    qubits <span class="op">=</span> <span class="bu">list</span>(nx.connected_components(connections))</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>    circuits <span class="op">=</span> []</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> qubits:</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>        sub_circuit_gates <span class="op">=</span> [gate <span class="cf">for</span> gate <span class="kw">in</span> U.gates <span class="cf">if</span> <span class="bu">all</span>(q <span class="kw">in</span> c <span class="cf">for</span> q <span class="kw">in</span> gate.qubits)]</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>        sub_circuit <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span>sub_circuit_gates)</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>        circuits.append(sub_circuit)</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circuits</span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_ab(H, circuits):</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a><span class="co">    Maps Hamiltonian parts to a (sub) cuircuit as a local term or stores the cross terms and</span></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a><span class="co">    calculates the Expectation Values with each local and cross term.</span></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>    local_terms <span class="op">=</span> []</span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>    cross_terms <span class="op">=</span> []</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>    constant <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ps <span class="kw">in</span> H.paulistrings:</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>        qubits <span class="op">=</span> ps.qubits</span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>        isCross <span class="op">=</span> <span class="va">True</span></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(qubits) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>            constant <span class="op">+=</span> ps.coeff </span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> circuit <span class="kw">in</span> circuits:</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>            <span class="co"># check if local or cross term</span></span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">set</span>(qubits).issubset(<span class="bu">set</span>(circuit.qubits)):       </span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>                local_terms.append((circuit, ps))</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>                isCross <span class="op">=</span> <span class="va">False</span></span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span> </span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> isCross: cross_terms.append(ps)</span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">=</span> <span class="bu">float</span>(constant.real)</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">+=</span> calculate_local(local_terms)</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">+=</span> calculate_cross(circuits, cross_terms)      </span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_local(local_terms):</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the local terms where the list local_terms containts tuples of </span></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a><span class="co">    a (sub) curcuit and the corresponding Pauli-Strings of the Hamiltonian.</span></span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (circuit, ps) <span class="kw">in</span> local_terms:</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>        H <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings(ps)</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(q <span class="kw">in</span> circuit.qubits <span class="cf">for</span> q <span class="kw">in</span> H.qubits):</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"!!!"</span>)</span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">+=</span>  tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>circuit)</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_cross(circuits, cross_terms):</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the cross terms.</span></span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a><span class="co">    Stores calculation results in dict to avoid the calculation of duplicates.</span></span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>    all_expvals <span class="op">=</span> {}</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ps <span class="kw">in</span> cross_terms:</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>        parts <span class="op">=</span> []</span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>        used <span class="op">=</span> {i:<span class="va">False</span> <span class="cf">for</span> i <span class="kw">in</span> ps.qubits}</span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>        tmp <span class="op">=</span> <span class="bu">float</span>(ps.coeff.real)</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> circuit <span class="kw">in</span> circuits:</span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>            lc <span class="op">=</span> {}</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> q <span class="kw">in</span> ps.qubits:</span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> q <span class="kw">in</span> circuit.qubits:</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>                    lc[q] <span class="op">=</span> ps[q]</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>                    used[q] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>            parts.append(lc) </span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(used.values()):</span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a>                care <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> used <span class="cf">if</span> <span class="kw">not</span> used[i]]</span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>([ps[q] <span class="op">==</span><span class="st">'Z'</span> <span class="cf">for</span> q <span class="kw">in</span> care]):</span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(circuits)):</span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>            ui <span class="op">=</span> circuits[i]</span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a>            hi <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings(tq.PauliString(parts[i]))</span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(hi) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a>            key <span class="op">=</span> (<span class="bu">str</span>(hi), i)</span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> key <span class="kw">in</span> all_expvals:</span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a>                ei <span class="op">=</span> all_expvals[key]</span>
<span id="cb5-153"><a href="#cb5-153" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-154"><a href="#cb5-154" aria-hidden="true" tabindex="-1"></a>                ei <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>hi, U<span class="op">=</span>ui)</span>
<span id="cb5-155"><a href="#cb5-155" aria-hidden="true" tabindex="-1"></a>                all_expvals[key] <span class="op">=</span> ei</span>
<span id="cb5-156"><a href="#cb5-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-157"><a href="#cb5-157" aria-hidden="true" tabindex="-1"></a>            tmp <span class="op">*=</span> ei</span>
<span id="cb5-158"><a href="#cb5-158" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">+=</span> tmp</span>
<span id="cb5-159"><a href="#cb5-159" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp</span>
<span id="cb5-160"><a href="#cb5-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-161"><a href="#cb5-161" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-162"><a href="#cb5-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-163"><a href="#cb5-163" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;center&gt;</span></span>
<span id="cb5-164"><a href="#cb5-164" aria-hidden="true" tabindex="-1"></a><span class="al">![](Figures/Figure_1.png)</span>{width=600}</span>
<span id="cb5-165"><a href="#cb5-165" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/center&gt;</span></span>
<span id="cb5-166"><a href="#cb5-166" aria-hidden="true" tabindex="-1"></a>The figure illustrates the performance difference between the classical expectation value calculation on the full circuit and the proposed method for exploiting decoupled circuit structures.</span>
<span id="cb5-167"><a href="#cb5-167" aria-hidden="true" tabindex="-1"></a>From the results, we observe a significant computational advantage for circuits with more than $16$ qubits. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-168"><a href="#cb5-168" aria-hidden="true" tabindex="-1"></a>The circuits were split into two parts, reducing the computational complexity of each subcircuit to half of the original complexity.</span>
<span id="cb5-169"><a href="#cb5-169" aria-hidden="true" tabindex="-1"></a>We can see that the computational expense for preparing and splitting the circuit, compared to the overall computational time, becomes negligible for higher qubit counts but remains significant for smaller circuits.</span>
<span id="cb5-170"><a href="#cb5-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-171"><a href="#cb5-171" aria-hidden="true" tabindex="-1"></a><span class="fu"># Weakly coupled circuit</span></span>
<span id="cb5-172"><a href="#cb5-172" aria-hidden="true" tabindex="-1"></a>Now we aim to decompose a circuit with the form $\text{U = ABC}$, where $B$ is a small component that couples the entire circuit and has the form: $$B = e^{-i\cdot\frac{\theta}{2}\cdot P}$$</span>
<span id="cb5-173"><a href="#cb5-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-174"><a href="#cb5-174" aria-hidden="true" tabindex="-1"></a>Here, $P$ is a Paulistring with length $n$ and $A$ and $C$ are independent, but each connected to $B$. Since $A$ and $C$ contain fully disconnected parts, we can apply our horizontal decomposition method to each, thereby achieving a computational advantage.</span>
<span id="cb5-175"><a href="#cb5-175" aria-hidden="true" tabindex="-1"></a>To fully decouple the circuit, we deconstruct $B$ into $n$ individual Pauligates.</span>
<span id="cb5-176"><a href="#cb5-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-177"><a href="#cb5-177" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;center&gt;</span></span>
<span id="cb5-178"><a href="#cb5-178" aria-hidden="true" tabindex="-1"></a><span class="al">![](Figures/pauli.png)</span>{width=480}</span>
<span id="cb5-179"><a href="#cb5-179" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/center&gt;</span></span>
<span id="cb5-180"><a href="#cb5-180" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;br&gt;</span></span>
<span id="cb5-181"><a href="#cb5-181" aria-hidden="true" tabindex="-1"></a>The new Pauligates are all single-qubit gates, making them highly suitable for the horizontal decomposition. During the preperation of the subcircuits, they can be assigned to their respective groups with minimal effort.<span class="kw">&lt;br&gt;</span></span>
<span id="cb5-182"><a href="#cb5-182" aria-hidden="true" tabindex="-1"></a>Now lets look at the deconstruction for $B = e^{-i\cdot\frac{\theta}{2}\cdot P} = cos(\frac{\theta}{2}) - i \cdot sin(\frac{\theta}{2})\cdot P$:</span>
<span id="cb5-183"><a href="#cb5-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-184"><a href="#cb5-184" aria-hidden="true" tabindex="-1"></a>$$ ABC =  cos(\frac{\theta}{2}) \cdot AC - i \cdot sin(\frac{\theta}{2})\cdot APC$$</span>
<span id="cb5-185"><a href="#cb5-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-186"><a href="#cb5-186" aria-hidden="true" tabindex="-1"></a>For simplicity lets call $cos(\frac{\theta}{2}) = a$ and $sin(\frac{\theta}{2}) = b$. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-187"><a href="#cb5-187" aria-hidden="true" tabindex="-1"></a>We can then construct the expectation value $\braket{H}_U = \bra{0}(ABC)^{\dagger} H \: ABC \ket{0}$ out of this:</span>
<span id="cb5-188"><a href="#cb5-188" aria-hidden="true" tabindex="-1"></a>$$ = a^2 \cdot \bra{0}(AC)^\dagger H \: AC\ket{0} + b^2 \cdot \bra{0}(APC)^\dagger H \: APC \ket{0} $$</span>
<span id="cb5-189"><a href="#cb5-189" aria-hidden="true" tabindex="-1"></a>$$ - abi \cdot \bra{0}(AC)^\dagger H \: APC \ket{0} + abi \cdot \bra{0}(APC)^\dagger H \: AC \ket{0} $$</span>
<span id="cb5-190"><a href="#cb5-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-191"><a href="#cb5-191" aria-hidden="true" tabindex="-1"></a>We split the calculation into four parts. The first two expectation values can now be calculated using the previously mentioned decoupled method.</span>
<span id="cb5-192"><a href="#cb5-192" aria-hidden="true" tabindex="-1"></a>The remaining terms are overlaps, which we refer to as cross terms.</span>
<span id="cb5-193"><a href="#cb5-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-194"><a href="#cb5-194" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simplification of the cross terms</span></span>
<span id="cb5-195"><a href="#cb5-195" aria-hidden="true" tabindex="-1"></a>The cross terms form an imaginary scalar. Since these terms are Hermitian conjugates, they can be rewritten in a simpler form. For any complex number $x + y \cdot i$ and its complex conjugate, the following identity holds: $(x+y\cdot i) - (x-y\cdot i) = 2yi = 2i \cdot \textbf{Im}(x+y\cdot i)$, <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-196"><a href="#cb5-196" aria-hidden="true" tabindex="-1"></a>where $\textbf{Im}(\cdot)$ denotes the imaginary component of a complex number. Applying this identity to our cross terms yields:</span>
<span id="cb5-197"><a href="#cb5-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-198"><a href="#cb5-198" aria-hidden="true" tabindex="-1"></a>$$ - abi \cdot \bra{0}(A C)^\dagger H \: A P C \ket{0} + abi \cdot \bra{0}(A P C)^\dagger H \: A C \ket{0} $$</span>
<span id="cb5-199"><a href="#cb5-199" aria-hidden="true" tabindex="-1"></a>$$ = - abi \cdot (\bra{0}(A C)^\dagger H \: A P C \ket{0} - abi \cdot \bra{0}(A P C)^\dagger H \: A C \ket{0}) $$</span>
<span id="cb5-200"><a href="#cb5-200" aria-hidden="true" tabindex="-1"></a>$$ = - abi \cdot (\bra{0}(A C)^\dagger H \: A P C \ket{0} - h.c) $$</span>
<span id="cb5-201"><a href="#cb5-201" aria-hidden="true" tabindex="-1"></a>$$ = - abi \cdot (2i \cdot\textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0})) $$</span>
<span id="cb5-202"><a href="#cb5-202" aria-hidden="true" tabindex="-1"></a>$$ = 2ab\cdot \textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0}) $$</span>
<span id="cb5-203"><a href="#cb5-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-204"><a href="#cb5-204" aria-hidden="true" tabindex="-1"></a>This transformation reduces the number of required steps and results in a real value.  Therefore, the total expectation value $\braket{H}_U$ is given by:</span>
<span id="cb5-205"><a href="#cb5-205" aria-hidden="true" tabindex="-1"></a>$$  a^2 \cdot \bra{0}(AC)^\dagger H \: AC\ket{0} + b^2 \cdot \bra{0}(APC)^\dagger H \: APC \ket{0} + 2ab\cdot \textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0})  $$ </span>
<span id="cb5-206"><a href="#cb5-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-207"><a href="#cb5-207" aria-hidden="true" tabindex="-1"></a>For our decomposition approach, the implementation would follow this structure:</span>
<span id="cb5-210"><a href="#cb5-210" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-211"><a href="#cb5-211" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_abc(H, A, B, C):</span>
<span id="cb5-212"><a href="#cb5-212" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-213"><a href="#cb5-213" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the given Hamiltonian H and the Unitary U = A*B*C</span></span>
<span id="cb5-214"><a href="#cb5-214" aria-hidden="true" tabindex="-1"></a><span class="co">    with the ABC-Formula.</span></span>
<span id="cb5-215"><a href="#cb5-215" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-216"><a href="#cb5-216" aria-hidden="true" tabindex="-1"></a>    psi, P <span class="op">=</span> h.convert_to_pauli(B)</span>
<span id="cb5-217"><a href="#cb5-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-218"><a href="#cb5-218" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Our Calculation:</span></span>
<span id="cb5-219"><a href="#cb5-219" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.cos)</span>
<span id="cb5-220"><a href="#cb5-220" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.sin)</span>
<span id="cb5-221"><a href="#cb5-221" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-222"><a href="#cb5-222" aria-hidden="true" tabindex="-1"></a>    a_term <span class="op">=</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>A<span class="op">+</span>C)</span>
<span id="cb5-223"><a href="#cb5-223" aria-hidden="true" tabindex="-1"></a>    b_term <span class="op">=</span>  tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>A<span class="op">+</span>P<span class="op">+</span>C)</span>
<span id="cb5-224"><a href="#cb5-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-225"><a href="#cb5-225" aria-hidden="true" tabindex="-1"></a>    local_term <span class="op">=</span> (a<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> a_term <span class="op">+</span> (b<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> b_term </span>
<span id="cb5-226"><a href="#cb5-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-227"><a href="#cb5-227" aria-hidden="true" tabindex="-1"></a>    _, img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>A<span class="op">+</span>C, ket<span class="op">=</span>A<span class="op">+</span>P<span class="op">+</span>C, operator<span class="op">=</span>H)</span>
<span id="cb5-228"><a href="#cb5-228" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb5-229"><a href="#cb5-229" aria-hidden="true" tabindex="-1"></a>    cross_term <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>a<span class="op">*</span>b<span class="op">*</span>(img)</span>
<span id="cb5-230"><a href="#cb5-230" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> local_term <span class="op">+</span> cross_term</span>
<span id="cb5-231"><a href="#cb5-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-232"><a href="#cb5-232" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-233"><a href="#cb5-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-234"><a href="#cb5-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-235"><a href="#cb5-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-236"><a href="#cb5-236" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overlap implementation</span></span>
<span id="cb5-237"><a href="#cb5-237" aria-hidden="true" tabindex="-1"></a>So far, we have not exploited the circuit structure in our cross-term calculations. This is critical because it could become a bottleneck for the overall computational complexity.</span>
<span id="cb5-238"><a href="#cb5-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-239"><a href="#cb5-239" aria-hidden="true" tabindex="-1"></a>We know that the overlap we created $\bra{0}(A C)^\dagger H \: A P C \ket{0}$, is splitable.</span>
<span id="cb5-240"><a href="#cb5-240" aria-hidden="true" tabindex="-1"></a>Lets split $AC$ into an $\textbf{Upper}$ and $\textbf{Lower}$ part of the full circuit. We call the parts of $APC$ the same, but mark them as $\textbf{Upper'}$ and $\textbf{Lower'}$ because they contain the extra Pauli gates from the decomposition of the circuit component $B$ that couples $A$ and $C$.</span>
<span id="cb5-241"><a href="#cb5-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-242"><a href="#cb5-242" aria-hidden="true" tabindex="-1"></a>Before simplification, we must examine the standard BraKet $\braket{\psi | \phi}$ implementation. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-243"><a href="#cb5-243" aria-hidden="true" tabindex="-1"></a>The BraKet overlap gets constructed in the following circuit, such that it is able to calculate the overlap between two states.</span>
<span id="cb5-244"><a href="#cb5-244" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;center&gt;</span></span>
<span id="cb5-245"><a href="#cb5-245" aria-hidden="true" tabindex="-1"></a><span class="al">![](Figures/circuit.png)</span>{width=600}</span>
<span id="cb5-246"><a href="#cb5-246" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/center&gt;</span></span>
<span id="cb5-247"><a href="#cb5-247" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;br&gt;</span></span>
<span id="cb5-248"><a href="#cb5-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-249"><a href="#cb5-249" aria-hidden="true" tabindex="-1"></a>For simplicity we depict the $\textbf{Upper}$ part as Unitary $U$ and $\textbf{Lower}$ as $L$. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-250"><a href="#cb5-250" aria-hidden="true" tabindex="-1"></a>The calculation requires an auxiliary qubit to control the execution of these subcircuits. While this adds some overhead, the computational advantage becomes significant when $U$ and $L$ are sufficiently large, as the complexity reduction from processing them separately outweighs the control cost.</span>
<span id="cb5-251"><a href="#cb5-251" aria-hidden="true" tabindex="-1"></a>We achive this with following method.</span>
<span id="cb5-252"><a href="#cb5-252" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;br&gt;</span></span>
<span id="cb5-253"><a href="#cb5-253" aria-hidden="true" tabindex="-1"></a>We define the overlap $\braket{\psi_0 | \psi_1}$ between $U \otimes L$ and the slightly modified $U' \otimes L'$ (containing the extra Pauli gates). These form following states:</span>
<span id="cb5-254"><a href="#cb5-254" aria-hidden="true" tabindex="-1"></a>$$ (U \otimes L)\ket{0} = \ket{\psi_{0}}, \: \: \: (U' \otimes L') \ket{0} = \ket{\psi_1}$$</span>
<span id="cb5-255"><a href="#cb5-255" aria-hidden="true" tabindex="-1"></a>After the second Hadamard gate of the auxiliary, the circuit prepares the state:</span>
<span id="cb5-256"><a href="#cb5-256" aria-hidden="true" tabindex="-1"></a>$$ \frac{1}{\sqrt{2}} \cdot (\ket{+} \ket{\psi_0} + \ket{-} \ket{\psi_1})$$</span>
<span id="cb5-257"><a href="#cb5-257" aria-hidden="true" tabindex="-1"></a>This is because the $X$ gates of the auxiliary qubit control / anti control - $\ket{\psi_{0}}$ and $\ket{\psi_{1}}$. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-258"><a href="#cb5-258" aria-hidden="true" tabindex="-1"></a>In the end measuring the ancilla with Pauli $Z$ (displayed as measurement symbol above) gives as output:</span>
<span id="cb5-259"><a href="#cb5-259" aria-hidden="true" tabindex="-1"></a>$$ \bra{0}(U \otimes L)^{\dagger} (U' \otimes L') \ket{0} = \braket{\psi_0 | \psi_1} $$</span>
<span id="cb5-260"><a href="#cb5-260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-261"><a href="#cb5-261" aria-hidden="true" tabindex="-1"></a>This however can further be simplified analytically to exploit the structure of $A$ and $C$:</span>
<span id="cb5-262"><a href="#cb5-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-263"><a href="#cb5-263" aria-hidden="true" tabindex="-1"></a>$$ \frac{1}{\sqrt{2}} \cdot (\ket{+} \otimes (U \otimes L \: \ket{0})) + \frac{1}{\sqrt{2}} \cdot (\ket{-} \otimes (U' \otimes L' \: \ket{0})) \equiv \ket{\psi}$$</span>
<span id="cb5-264"><a href="#cb5-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-265"><a href="#cb5-265" aria-hidden="true" tabindex="-1"></a>$$ \bra{\psi} Z \otimes 1 \otimes 1 \ket{\psi} = $$</span>
<span id="cb5-266"><a href="#cb5-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-267"><a href="#cb5-267" aria-hidden="true" tabindex="-1"></a> $$\frac{1}{2} \cdot \bra{+}Z\ket{+} \cdot \: ... + \frac{1}{2} \cdot \bra{-}Z\ket{-} \cdot \: ... + \frac{1}{2}\cdot \bra{+}Z\ket{-}\cdot \bra{0}(U \otimes L) \: (U' \otimes L')\ket{0}  + \frac{1}{2}\cdot \bra{-}Z\ket{+}\cdot \bra{0}(U' \otimes L') \: (U \otimes L)\ket{0}$$</span>
<span id="cb5-268"><a href="#cb5-268" aria-hidden="true" tabindex="-1"></a>$$ = 0 + 0 + \frac{1}{2}\cdot 1 \cdot \bra{0}(U \: U') \ket{0} \cdot \bra{0}(L \: L') \ket{0} + \frac{1}{2}\cdot 1 \cdot \bra{0}(U' \: U) \ket{0} \cdot \bra{0}(L' \: L) \ket{0} $$</span>
<span id="cb5-269"><a href="#cb5-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-270"><a href="#cb5-270" aria-hidden="true" tabindex="-1"></a><span class="fu">## Weakly coupled implementation and comparison</span></span>
<span id="cb5-271"><a href="#cb5-271" aria-hidden="true" tabindex="-1"></a>With every previously described step we can now implement the weakly coupled decomposition to exploit a circuit's structure for a computational advantage.</span>
<span id="cb5-272"><a href="#cb5-272" aria-hidden="true" tabindex="-1"></a>The core functionality resides in the function **calculate_abc**, which handles the primary decomposition calculation.</span>
<span id="cb5-273"><a href="#cb5-273" aria-hidden="true" tabindex="-1"></a>Because $\textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0})$ forms an overlap, **small_braket** gets called to further reduce the complexity.</span>
<span id="cb5-274"><a href="#cb5-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-277"><a href="#cb5-277" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-278"><a href="#cb5-278" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_to_pauli(U: tq.gates.ExpPauli):</span>
<span id="cb5-279"><a href="#cb5-279" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-280"><a href="#cb5-280" aria-hidden="true" tabindex="-1"></a><span class="co">    Converts an Exponential Pauli U of form e^(-i*angle/2 *P) to: angle and PauliGate P.</span></span>
<span id="cb5-281"><a href="#cb5-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-282"><a href="#cb5-282" aria-hidden="true" tabindex="-1"></a><span class="co">    Restrictions:</span></span>
<span id="cb5-283"><a href="#cb5-283" aria-hidden="true" tabindex="-1"></a><span class="co">    - only one or no angle allowed</span></span>
<span id="cb5-284"><a href="#cb5-284" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-285"><a href="#cb5-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-286"><a href="#cb5-286" aria-hidden="true" tabindex="-1"></a>    <span class="bu">map</span> <span class="op">=</span> U.make_parameter_map()</span>
<span id="cb5-287"><a href="#cb5-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-288"><a href="#cb5-288" aria-hidden="true" tabindex="-1"></a>    angle_parameters <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>.keys())</span>
<span id="cb5-289"><a href="#cb5-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-290"><a href="#cb5-290" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(angle_parameters) <span class="op">&gt;</span> <span class="dv">1</span> <span class="kw">or</span> <span class="bu">len</span>(U.gates) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-291"><a href="#cb5-291" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb5-292"><a href="#cb5-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-293"><a href="#cb5-293" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(angle_parameters) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-294"><a href="#cb5-294" aria-hidden="true" tabindex="-1"></a>        angle <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-295"><a href="#cb5-295" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-296"><a href="#cb5-296" aria-hidden="true" tabindex="-1"></a>        angle <span class="op">=</span> tq.Variable(angle_parameters[<span class="dv">0</span>])</span>
<span id="cb5-297"><a href="#cb5-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-298"><a href="#cb5-298" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> angle, tq.gates.PauliGate(U.gates[<span class="dv">0</span>].paulistring)</span>
<span id="cb5-299"><a href="#cb5-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-300"><a href="#cb5-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-301"><a href="#cb5-301" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_abc(H, A, B, C):</span>
<span id="cb5-302"><a href="#cb5-302" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-303"><a href="#cb5-303" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates the Expectation Value for the given Hamiltonian H and the Unitary U = A*B*C</span></span>
<span id="cb5-304"><a href="#cb5-304" aria-hidden="true" tabindex="-1"></a><span class="co">    with the ABC-Formula.</span></span>
<span id="cb5-305"><a href="#cb5-305" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-306"><a href="#cb5-306" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Do the decomposition</span></span>
<span id="cb5-307"><a href="#cb5-307" aria-hidden="true" tabindex="-1"></a>    psi, P <span class="op">=</span> convert_to_pauli(B)</span>
<span id="cb5-308"><a href="#cb5-308" aria-hidden="true" tabindex="-1"></a>    ac_up, ac_down <span class="op">=</span> split_2(A<span class="op">+</span>C)</span>
<span id="cb5-309"><a href="#cb5-309" aria-hidden="true" tabindex="-1"></a>    apc_up, apc_down <span class="op">=</span> split_2(A<span class="op">+</span>P<span class="op">+</span>C)</span>
<span id="cb5-310"><a href="#cb5-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-311"><a href="#cb5-311" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculation of every part:</span></span>
<span id="cb5-312"><a href="#cb5-312" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.cos)</span>
<span id="cb5-313"><a href="#cb5-313" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> (<span class="fl">0.5</span><span class="op">*</span>psi).<span class="bu">apply</span>(tq.numpy.sin)</span>
<span id="cb5-314"><a href="#cb5-314" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-315"><a href="#cb5-315" aria-hidden="true" tabindex="-1"></a>    a_term <span class="op">=</span> ab.calculate_ab(circuits<span class="op">=</span>[ac_up, ac_down], H<span class="op">=</span>H)</span>
<span id="cb5-316"><a href="#cb5-316" aria-hidden="true" tabindex="-1"></a>    b_term <span class="op">=</span> ab.calculate_ab(circuits<span class="op">=</span>[apc_up, apc_down], H<span class="op">=</span>H)</span>
<span id="cb5-317"><a href="#cb5-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-318"><a href="#cb5-318" aria-hidden="true" tabindex="-1"></a>    local_term <span class="op">=</span> (a<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> a_term <span class="op">+</span> (b<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> b_term </span>
<span id="cb5-319"><a href="#cb5-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-320"><a href="#cb5-320" aria-hidden="true" tabindex="-1"></a>    _, img <span class="op">=</span> small_braket(ac_up, ac_down, apc_up, apc_down, H)</span>
<span id="cb5-321"><a href="#cb5-321" aria-hidden="true" tabindex="-1"></a>    cross_term <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>a<span class="op">*</span>b<span class="op">*</span>(img)</span>
<span id="cb5-322"><a href="#cb5-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-323"><a href="#cb5-323" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> local_term <span class="op">+</span> cross_term</span>
<span id="cb5-324"><a href="#cb5-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-325"><a href="#cb5-325" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> small_braket(bra_up, bra_down, ket_up, ket_down, H):</span>
<span id="cb5-326"><a href="#cb5-326" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-327"><a href="#cb5-327" aria-hidden="true" tabindex="-1"></a><span class="co">    Calculates Overlap of the form &lt;|(AC)^{\dagger} H APC|&gt; or &lt;|(ACP)^{\dagger} H AC|&gt;.</span></span>
<span id="cb5-328"><a href="#cb5-328" aria-hidden="true" tabindex="-1"></a><span class="co">    Assumes A and C to be horizontally splitable.</span></span>
<span id="cb5-329"><a href="#cb5-329" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-330"><a href="#cb5-330" aria-hidden="true" tabindex="-1"></a>    result_r <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-331"><a href="#cb5-331" aria-hidden="true" tabindex="-1"></a>    result_i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-332"><a href="#cb5-332" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ps <span class="kw">in</span> H.paulistrings:</span>
<span id="cb5-333"><a href="#cb5-333" aria-hidden="true" tabindex="-1"></a>        up_ps <span class="op">=</span> {}</span>
<span id="cb5-334"><a href="#cb5-334" aria-hidden="true" tabindex="-1"></a>        down_ps <span class="op">=</span> {}</span>
<span id="cb5-335"><a href="#cb5-335" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> p <span class="kw">in</span> ps.qubits:</span>
<span id="cb5-336"><a href="#cb5-336" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p <span class="kw">in</span> ket_up.qubits <span class="kw">or</span> p <span class="kw">in</span> bra_up.qubits:</span>
<span id="cb5-337"><a href="#cb5-337" aria-hidden="true" tabindex="-1"></a>                up_ps[p] <span class="op">=</span> ps[p]</span>
<span id="cb5-338"><a href="#cb5-338" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p <span class="kw">in</span> ket_down.qubits <span class="kw">or</span> p <span class="kw">in</span> bra_down.qubits:</span>
<span id="cb5-339"><a href="#cb5-339" aria-hidden="true" tabindex="-1"></a>                down_ps[p] <span class="op">=</span> ps[p]</span>
<span id="cb5-340"><a href="#cb5-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-341"><a href="#cb5-341" aria-hidden="true" tabindex="-1"></a>        coeff <span class="op">=</span> <span class="bu">float</span>(ps.coeff.real)</span>
<span id="cb5-342"><a href="#cb5-342" aria-hidden="true" tabindex="-1"></a>        h_up <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings([tq.PauliString(up_ps)])</span>
<span id="cb5-343"><a href="#cb5-343" aria-hidden="true" tabindex="-1"></a>        h_down <span class="op">=</span> tq.QubitHamiltonian.from_paulistrings([tq.PauliString(down_ps)])</span>
<span id="cb5-344"><a href="#cb5-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-345"><a href="#cb5-345" aria-hidden="true" tabindex="-1"></a>        a_real, a_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>bra_up, ket<span class="op">=</span>ket_up, operator<span class="op">=</span>h_up)</span>
<span id="cb5-346"><a href="#cb5-346" aria-hidden="true" tabindex="-1"></a>        b_real, b_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>bra_down, ket<span class="op">=</span>ket_down, operator<span class="op">=</span>h_down)</span>
<span id="cb5-347"><a href="#cb5-347" aria-hidden="true" tabindex="-1"></a>        c_real, c_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>ket_up, ket<span class="op">=</span>bra_up, operator<span class="op">=</span>h_up)</span>
<span id="cb5-348"><a href="#cb5-348" aria-hidden="true" tabindex="-1"></a>        d_real, d_img <span class="op">=</span> tq.BraKet(bra<span class="op">=</span>ket_down, ket<span class="op">=</span>bra_down, operator<span class="op">=</span>h_down)</span>
<span id="cb5-349"><a href="#cb5-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-350"><a href="#cb5-350" aria-hidden="true" tabindex="-1"></a>        result_r <span class="op">+=</span> <span class="fl">0.5</span><span class="op">*</span>(a_real<span class="op">*</span>b_real <span class="op">-</span> a_img<span class="op">*</span>b_img) <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>(c_real<span class="op">*</span>d_real <span class="op">-</span> c_img<span class="op">*</span>d_img)</span>
<span id="cb5-351"><a href="#cb5-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-352"><a href="#cb5-352" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(down_ps) <span class="op">==</span> <span class="dv">0</span>: <span class="co"># Hamiltonian only acts on the upper parts</span></span>
<span id="cb5-353"><a href="#cb5-353" aria-hidden="true" tabindex="-1"></a>            result_i <span class="op">+=</span> <span class="fl">0.5</span><span class="op">*</span>a_img <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>c_img</span>
<span id="cb5-354"><a href="#cb5-354" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb5-355"><a href="#cb5-355" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(up_ps) <span class="op">==</span> <span class="dv">0</span>: <span class="co"># " - lower parts</span></span>
<span id="cb5-356"><a href="#cb5-356" aria-hidden="true" tabindex="-1"></a>            result_i <span class="op">+=</span> <span class="fl">0.5</span><span class="op">*</span>b_img <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>d_img</span>
<span id="cb5-357"><a href="#cb5-357" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb5-358"><a href="#cb5-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-359"><a href="#cb5-359" aria-hidden="true" tabindex="-1"></a>        result_ac <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> a_img <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> c_img</span>
<span id="cb5-360"><a href="#cb5-360" aria-hidden="true" tabindex="-1"></a>        result_bd <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> b_img <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> d_img</span>
<span id="cb5-361"><a href="#cb5-361" aria-hidden="true" tabindex="-1"></a>        result_i <span class="op">+=</span> coeff <span class="op">*</span> (result_ac <span class="op">*</span> result_bd)</span>
<span id="cb5-362"><a href="#cb5-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-363"><a href="#cb5-363" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result_r, result_i</span>
<span id="cb5-364"><a href="#cb5-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-365"><a href="#cb5-365" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb5-366"><a href="#cb5-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-367"><a href="#cb5-367" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;center&gt;</span></span>
<span id="cb5-368"><a href="#cb5-368" aria-hidden="true" tabindex="-1"></a><span class="al">![](Figures/Figure_2.png)</span>{width=600}</span>
<span id="cb5-369"><a href="#cb5-369" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/center&gt;</span></span>
<span id="cb5-370"><a href="#cb5-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-371"><a href="#cb5-371" aria-hidden="true" tabindex="-1"></a>The figure illustrates the performance difference between the classical expectation value calculation and the proposed method for exploiting weakly coupled circuit structures.</span>
<span id="cb5-372"><a href="#cb5-372" aria-hidden="true" tabindex="-1"></a>From the results, we observe that the computational advantage becomes significant only for circuits with more than $&gt;20$ qubits.</span>
<span id="cb5-373"><a href="#cb5-373" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;br&gt;</span></span>
<span id="cb5-374"><a href="#cb5-374" aria-hidden="true" tabindex="-1"></a>The complexity of the calculation was reduced to multiple factors of half the original complexity.</span>
<span id="cb5-375"><a href="#cb5-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-376"><a href="#cb5-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-377"><a href="#cb5-377" aria-hidden="true" tabindex="-1"></a><span class="fu"># Complexity analysis</span></span>
<span id="cb5-378"><a href="#cb5-378" aria-hidden="true" tabindex="-1"></a>To evaluate the potential of our decomposition methods, we examine their computational complexity.</span>
<span id="cb5-379"><a href="#cb5-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-380"><a href="#cb5-380" aria-hidden="true" tabindex="-1"></a><span class="fu">## Decoupled method</span></span>
<span id="cb5-381"><a href="#cb5-381" aria-hidden="true" tabindex="-1"></a>The computational complexity follows directly from the state space reduction. For an $n$-qubit circuit with $2^n$ basis states, decomposition in two equal subcircuits of size $\frac{n}{2}$ yeilds:</span>
<span id="cb5-382"><a href="#cb5-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-383"><a href="#cb5-383" aria-hidden="true" tabindex="-1"></a>$$ 2^n \rightarrow 2\cdot 2^{\frac{n}{2}} \rightarrow \mathcal{O}(2^{\frac{n}{2}})$$</span>
<span id="cb5-384"><a href="#cb5-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-385"><a href="#cb5-385" aria-hidden="true" tabindex="-1"></a>This represents the optimal case. For asymmetric splits where one (bigger) subcircuit contains $m &lt; n$ -qubits, the complexity becomes dominated by the larger partition: $\mathcal{O}(2^{m}).$</span>
<span id="cb5-386"><a href="#cb5-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-387"><a href="#cb5-387" aria-hidden="true" tabindex="-1"></a><span class="fu">## Weakly coupled method</span></span>
<span id="cb5-388"><a href="#cb5-388" aria-hidden="true" tabindex="-1"></a>In this case, the overall theoretical complexity is similar to that of the decoupled method, although with a greater number of subcircuits. To analyze this, we examine our decomposition:</span>
<span id="cb5-389"><a href="#cb5-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-390"><a href="#cb5-390" aria-hidden="true" tabindex="-1"></a>$$  \braket{H}_U = a^2 \cdot \bra{0}(AC)^\dagger H \: AC\ket{0} + b^2 \cdot \bra{0}(APC)^\dagger H \: APC \ket{0} + 2ab\cdot \textbf{Im}(\bra{0}(A C)^\dagger H \: A P C \ket{0}) $$</span>
<span id="cb5-391"><a href="#cb5-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-392"><a href="#cb5-392" aria-hidden="true" tabindex="-1"></a>This involves the evaluation of two expectation values and an overlap, each requiring operations on the full circuit size. If $A$ and $C$ are splitable in two equal subcircuits, the overlap calculation involves four partial evaluations acting on half the qubits, but each requiring an auxiliary qubit:</span>
<span id="cb5-393"><a href="#cb5-393" aria-hidden="true" tabindex="-1"></a>$$  \frac{1}{2} \cdot \bra{0}(U \: U') \ket{0} \cdot \bra{0}(L \: L') \ket{0} + \frac{1}{2} \cdot \bra{0}(U' \: U) \ket{0} \cdot \bra{0}(L' \: L) \ket{0} $$</span>
<span id="cb5-394"><a href="#cb5-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-395"><a href="#cb5-395" aria-hidden="true" tabindex="-1"></a>The total the complexity is $2 \cdot ( 2 \cdot 2^{\frac{n}{2}} ) + 4 \cdot 2^{\frac{n}{2} + 1}$, where the first term accounts for splitting the two expectation values, each into two equally sized subcircuits, while the second term represents the evaluation of the deconstructed overlap acting on $\frac{n}{2}+ 1$ qubits, making the complexity  $\mathcal{O}(2^{\frac{n}{2} + 1})$. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-396"><a href="#cb5-396" aria-hidden="true" tabindex="-1"></a>For unequal splits, the complexity is determined by the larger partition (denoted by size $m$), yielding a complexity of $\mathcal{O}(2^{m + 1})$.</span>
<span id="cb5-397"><a href="#cb5-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-398"><a href="#cb5-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-399"><a href="#cb5-399" aria-hidden="true" tabindex="-1"></a>However in practice, the computation time is significantly influenced by the number of subcircuits required to construct the expectation values. This dependence arises primarily from the overhead associated with initializing computational objects for each subcircuit, which adds complexity to the overall calculation process. The above performance plots illustrate the circuit sizes for which this decomposition approach becomes computationally advantageous.</span>
<span id="cb5-400"><a href="#cb5-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-401"><a href="#cb5-401" aria-hidden="true" tabindex="-1"></a><span class="fu"># Outlook for recursive structures</span></span>
<span id="cb5-402"><a href="#cb5-402" aria-hidden="true" tabindex="-1"></a>A promising use case for our weakly coupled method involves circuits with multiple weak connections distributed throughout their structure. In such scenarios, we can adapt the core methodology by decomposing the circuit recursivly. Consider an example circuit with the following structure: </span>
<span id="cb5-403"><a href="#cb5-403" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;br&gt;</span></span>
<span id="cb5-404"><a href="#cb5-404" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;center&gt;</span></span>
<span id="cb5-405"><a href="#cb5-405" aria-hidden="true" tabindex="-1"></a><span class="al">![](Figures/outlook.png)</span>{width=480}</span>
<span id="cb5-406"><a href="#cb5-406" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/center&gt;</span></span>
<span id="cb5-407"><a href="#cb5-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-408"><a href="#cb5-408" aria-hidden="true" tabindex="-1"></a>We can see that $ABC$ follows the structure we have seen before, but $C = A'B'C'$ has the same structure in itself.</span>
<span id="cb5-409"><a href="#cb5-409" aria-hidden="true" tabindex="-1"></a>Lets write out our decomposition with $B = e^{-i\cdot\frac{\theta}{2}\cdot P}$:</span>
<span id="cb5-410"><a href="#cb5-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-411"><a href="#cb5-411" aria-hidden="true" tabindex="-1"></a>$$  a^2 \cdot \bra{0}(AA'B'C')^\dagger H \: AA'B'C'\ket{0} + b^2 \cdot \bra{0}(APA'B'C')^\dagger H \: APA'B'C' \ket{0} $$ $$ + 2ab \cdot \textbf{Im}(\bra{0}(A A'B'C')^\dagger H \: A P A'B'C' \ket{0}) $$</span>
<span id="cb5-412"><a href="#cb5-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-413"><a href="#cb5-413" aria-hidden="true" tabindex="-1"></a>Here each element has the right structure for the weakly coupled decomposition with a single occuring weak link $B'$, which can be decomposed in 8 smaller components like discussed in the previous chapter.</span>
<span id="cb5-414"><a href="#cb5-414" aria-hidden="true" tabindex="-1"></a>For this we just summarize $AA'$ and $APA'$ to $A_{\text{new}}$ which both fullfill the requirements for our proposed weakly coupled decomposition.</span>
<span id="cb5-415"><a href="#cb5-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-416"><a href="#cb5-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-417"><a href="#cb5-417" aria-hidden="true" tabindex="-1"></a><span class="fu"># Summary</span></span>
<span id="cb5-418"><a href="#cb5-418" aria-hidden="true" tabindex="-1"></a>Our proposed methods achieve substantial reductions in computation time through strategic circuit decomposition. By partitioning the original circuit into smaller subcircuits, we exponentially decrease the operational dimensionality, leading to significant complexity reduction. While this tutorial specifically examines the case of dividing $n$ qubits into two (for decoupled) / multiple (for weakly coupled) - subcircuits of $\frac{n}{2}$ qubits, the methods remain valid for any partition size that satisfies the structural requirements.</span>
<span id="cb5-419"><a href="#cb5-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-420"><a href="#cb5-420" aria-hidden="true" tabindex="-1"></a>We focus on 2-way decomposition for two key reasons: <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-421"><a href="#cb5-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-422"><a href="#cb5-422" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>The two-subcircuit case provides clearer demonstration while maintaining all essential features of the general approach</span>
<span id="cb5-423"><a href="#cb5-423" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>If the structural properties are given, we can recursively split the resulting circuits from the first decomposition as often as we want.</span>
<span id="cb5-424"><a href="#cb5-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-425"><a href="#cb5-425" aria-hidden="true" tabindex="-1"></a>From the performance comparison plots, we observe that a computational advantage is achieved for larger circuits, where the threshold in computational costs for creating multiple smaller circuits is exceeded.</span>
<span id="cb5-426"><a href="#cb5-426" aria-hidden="true" tabindex="-1"></a>These methods show great promise for various computational tasks; however, they are highly dependent on the underlying circuit structure and do not provide a universal solution for arbitrary circuits.</span>
<span id="cb5-427"><a href="#cb5-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-428"><a href="#cb5-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-429"><a href="#cb5-429" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix: Visualization of Testing Circuit</span></span>
<span id="cb5-430"><a href="#cb5-430" aria-hidden="true" tabindex="-1"></a>To test both calculation methods, suitable circuits were required. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-431"><a href="#cb5-431" aria-hidden="true" tabindex="-1"></a>For constructing fully disconnected test circuits, we begin by randomly assigning gates to an empty circuit acting on half the number of qubits in the target circuit. This circuit is then duplicated to create a second group acting on the remaining qubits. This will result in a circuit with two groups each only interacting with qubits in the same group, which makes it splitable with the fully disconnected method.</span>
<span id="cb5-432"><a href="#cb5-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-433"><a href="#cb5-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-434"><a href="#cb5-434" aria-hidden="true" tabindex="-1"></a>In the case of weakly coupled circuits, we follow the same initial construction process but introduce a coupling between the groups, at an arbitary point (in our example we choose the middle of the circuit). The coupling is implemented through a unitary operation of the form $B = e^{-i\cdot\frac{\theta}{2}\cdot P}$, where the Paulistring $P$ is allowed to act on qubits of both groups. </span>
<span id="cb5-435"><a href="#cb5-435" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;br&gt;</span></span>
<span id="cb5-436"><a href="#cb5-436" aria-hidden="true" tabindex="-1"></a>The following figure shows an example circuit for testing the weakly coupled circuit calculation method, consisting of two groups with a total of 10 qubits. The groups are weakly linked by a Pauli gate (marked in pink).</span>
<span id="cb5-437"><a href="#cb5-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-438"><a href="#cb5-438" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;center&gt;</span></span>
<span id="cb5-439"><a href="#cb5-439" aria-hidden="true" tabindex="-1"></a><span class="al">![](Figures/example10q.png)</span>{width=600}</span>
<span id="cb5-440"><a href="#cb5-440" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/center&gt;</span></span>
<span id="cb5-441"><a href="#cb5-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-442"><a href="#cb5-442" aria-hidden="true" tabindex="-1"></a>We also need a Hamiltonian to form our expectation value $\braket{H}_U$. <span class="kw">&lt;br&gt;</span> For this we consider the two groups, $X$ acting on $1,2, ... \frac{n}{2}$ and $Y$ acting on $\frac{n}{2} + 1, ... n-1, n$. <span class="kw">&lt;br&gt;</span></span>
<span id="cb5-443"><a href="#cb5-443" aria-hidden="true" tabindex="-1"></a>Our test Hamiltonian is then simply constructed with one Paulistring acting on each group and one Paulistring covering both groups:</span>
<span id="cb5-444"><a href="#cb5-444" aria-hidden="true" tabindex="-1"></a>$$H =  \bigotimes_{i \in X} Z(i) + \bigotimes_{j \in Y} Z(j) + \bigotimes_{k \in X \cup Y} Z(k) $$</span>
<span id="cb5-445"><a href="#cb5-445" aria-hidden="true" tabindex="-1"></a>So for the $10$ qubit case: $H = Z(1)Z(2)Z(3)Z(4)Z(5) + Z(6)Z(7)Z(8)Z(9)Z(10) + Z(1)Z(2)Z(3)Z(4)Z(5)Z(6)Z(7)Z(8)Z(9)Z(10)$</span>
<span id="cb5-446"><a href="#cb5-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-447"><a href="#cb5-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-448"><a href="#cb5-448" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix: Circuit splitting logic</span></span>
<span id="cb5-449"><a href="#cb5-449" aria-hidden="true" tabindex="-1"></a>The logic for preparing the underlying circuit for the proposed calculation method can be done like this: </span>
<span id="cb5-452"><a href="#cb5-452" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb5-453"><a href="#cb5-453" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_2(U):</span>
<span id="cb5-454"><a href="#cb5-454" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-455"><a href="#cb5-455" aria-hidden="true" tabindex="-1"></a><span class="co">    Deconstructs a splitable Unitary into list of independent sub circuits.</span></span>
<span id="cb5-456"><a href="#cb5-456" aria-hidden="true" tabindex="-1"></a><span class="co">    If not splitable it will return [U]</span></span>
<span id="cb5-457"><a href="#cb5-457" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-458"><a href="#cb5-458" aria-hidden="true" tabindex="-1"></a>    connections <span class="op">=</span> U.to_networkx()</span>
<span id="cb5-459"><a href="#cb5-459" aria-hidden="true" tabindex="-1"></a>    qubits <span class="op">=</span> <span class="bu">list</span>(nx.connected_components(connections))</span>
<span id="cb5-460"><a href="#cb5-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-461"><a href="#cb5-461" aria-hidden="true" tabindex="-1"></a>    circuits <span class="op">=</span> []</span>
<span id="cb5-462"><a href="#cb5-462" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> qubits:</span>
<span id="cb5-463"><a href="#cb5-463" aria-hidden="true" tabindex="-1"></a>        sub_circuit_gates <span class="op">=</span> [gate <span class="cf">for</span> gate <span class="kw">in</span> U.gates <span class="cf">if</span> <span class="bu">all</span>(q <span class="kw">in</span> c <span class="cf">for</span> q <span class="kw">in</span> gate.qubits)]</span>
<span id="cb5-464"><a href="#cb5-464" aria-hidden="true" tabindex="-1"></a>        sub_circuit <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span>sub_circuit_gates)</span>
<span id="cb5-465"><a href="#cb5-465" aria-hidden="true" tabindex="-1"></a>        circuits.append(sub_circuit)</span>
<span id="cb5-466"><a href="#cb5-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-467"><a href="#cb5-467" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circuits</span>
<span id="cb5-468"><a href="#cb5-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-469"><a href="#cb5-469" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_n(U):</span>
<span id="cb5-470"><a href="#cb5-470" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-471"><a href="#cb5-471" aria-hidden="true" tabindex="-1"></a><span class="co">    Tries to Split a Unitary in either 1 (unsplitable), 2 (AB-structure), </span></span>
<span id="cb5-472"><a href="#cb5-472" aria-hidden="true" tabindex="-1"></a><span class="co">    or 3 parts with ABC structure, where A and C are splitable but B is not.</span></span>
<span id="cb5-473"><a href="#cb5-473" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-474"><a href="#cb5-474" aria-hidden="true" tabindex="-1"></a>    A, rest <span class="op">=</span> check_right(tq.QCircuit(gates<span class="op">=</span>U.gates))</span>
<span id="cb5-475"><a href="#cb5-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-476"><a href="#cb5-476" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> A <span class="kw">is</span> <span class="va">None</span>: <span class="co"># Unitary is not splitable</span></span>
<span id="cb5-477"><a href="#cb5-477" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [rest]</span>
<span id="cb5-478"><a href="#cb5-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-479"><a href="#cb5-479" aria-hidden="true" tabindex="-1"></a>    C, rest <span class="op">=</span> check_right(tq.QCircuit(gates<span class="op">=</span><span class="bu">list</span>(<span class="bu">reversed</span>(rest.gates))))</span>
<span id="cb5-480"><a href="#cb5-480" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span><span class="bu">list</span>(<span class="bu">reversed</span>(rest.gates)))</span>
<span id="cb5-481"><a href="#cb5-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-482"><a href="#cb5-482" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> C <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb5-483"><a href="#cb5-483" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [A, B] </span>
<span id="cb5-484"><a href="#cb5-484" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span><span class="bu">list</span>(<span class="bu">reversed</span>(C.gates)))</span>
<span id="cb5-485"><a href="#cb5-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-486"><a href="#cb5-486" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [A, B, C]</span>
<span id="cb5-487"><a href="#cb5-487" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb5-488"><a href="#cb5-488" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check_right(U):</span>
<span id="cb5-489"><a href="#cb5-489" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-490"><a href="#cb5-490" aria-hidden="true" tabindex="-1"></a><span class="co">    Iterates through a QCircuit unitil it is splitable in reverse order.</span></span>
<span id="cb5-491"><a href="#cb5-491" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns either an Splitable and unsplitable part or None and unsplitable QCircuit.</span></span>
<span id="cb5-492"><a href="#cb5-492" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-493"><a href="#cb5-493" aria-hidden="true" tabindex="-1"></a>    test <span class="op">=</span> tq.QCircuit(U.gates)</span>
<span id="cb5-494"><a href="#cb5-494" aria-hidden="true" tabindex="-1"></a>    seperable <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-495"><a href="#cb5-495" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="bu">len</span>(U.gates)</span>
<span id="cb5-496"><a href="#cb5-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-497"><a href="#cb5-497" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(test.gates) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb5-498"><a href="#cb5-498" aria-hidden="true" tabindex="-1"></a>        test.gates.pop()</span>
<span id="cb5-499"><a href="#cb5-499" aria-hidden="true" tabindex="-1"></a>        count <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb5-500"><a href="#cb5-500" aria-hidden="true" tabindex="-1"></a>        connections <span class="op">=</span> test.to_networkx()</span>
<span id="cb5-501"><a href="#cb5-501" aria-hidden="true" tabindex="-1"></a>        qubits <span class="op">=</span> <span class="bu">list</span>(nx.connected_components(connections))</span>
<span id="cb5-502"><a href="#cb5-502" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-503"><a href="#cb5-503" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(<span class="bu">len</span>(qubits) <span class="op">&gt;</span> <span class="dv">1</span>):</span>
<span id="cb5-504"><a href="#cb5-504" aria-hidden="true" tabindex="-1"></a>            seperable <span class="op">=</span> test</span>
<span id="cb5-505"><a href="#cb5-505" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb5-506"><a href="#cb5-506" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-507"><a href="#cb5-507" aria-hidden="true" tabindex="-1"></a>    rest <span class="op">=</span> tq.QCircuit(gates<span class="op">=</span>U.gates[count:])</span>
<span id="cb5-508"><a href="#cb5-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-509"><a href="#cb5-509" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> seperable, rest</span>
<span id="cb5-510"><a href="#cb5-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-511"><a href="#cb5-511" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> decompose(H, U):</span>
<span id="cb5-512"><a href="#cb5-512" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-513"><a href="#cb5-513" aria-hidden="true" tabindex="-1"></a><span class="co">    Decomposes a Unitary U in (sub) circuits and calculates the Expectation Value in smaller steps.</span></span>
<span id="cb5-514"><a href="#cb5-514" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-515"><a href="#cb5-515" aria-hidden="true" tabindex="-1"></a>    unitary_circuits <span class="op">=</span> cg.split_2(U)</span>
<span id="cb5-516"><a href="#cb5-516" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The Unitary was split into smaller parts for easy calc</span></span>
<span id="cb5-517"><a href="#cb5-517" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(unitary_circuits) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-518"><a href="#cb5-518" aria-hidden="true" tabindex="-1"></a>        exp <span class="op">=</span> ab.calculate_ab(H, unitary_circuits)</span>
<span id="cb5-519"><a href="#cb5-519" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> exp</span>
<span id="cb5-520"><a href="#cb5-520" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-521"><a href="#cb5-521" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: </span>
<span id="cb5-522"><a href="#cb5-522" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The Unitary was not splitable</span></span>
<span id="cb5-523"><a href="#cb5-523" aria-hidden="true" tabindex="-1"></a>        circuits <span class="op">=</span> cg.split_n(U)</span>
<span id="cb5-524"><a href="#cb5-524" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(circuits) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-525"><a href="#cb5-525" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Could not split the Unitary"</span>)</span>
<span id="cb5-526"><a href="#cb5-526" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> tq.ExpectationValue(H<span class="op">=</span>H, U<span class="op">=</span>U)</span>
<span id="cb5-527"><a href="#cb5-527" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-528"><a href="#cb5-528" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(circuits) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb5-529"><a href="#cb5-529" aria-hidden="true" tabindex="-1"></a>            A, B <span class="op">=</span> circuits</span>
<span id="cb5-530"><a href="#cb5-530" aria-hidden="true" tabindex="-1"></a>            C <span class="op">=</span> tq.QCircuit() <span class="co"># test with Identity</span></span>
<span id="cb5-531"><a href="#cb5-531" aria-hidden="true" tabindex="-1"></a>            abc.calculate_abc(H, A, B, C)</span>
<span id="cb5-532"><a href="#cb5-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-533"><a href="#cb5-533" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(circuits) <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb5-534"><a href="#cb5-534" aria-hidden="true" tabindex="-1"></a>            A, B, C <span class="op">=</span> circuits</span>
<span id="cb5-535"><a href="#cb5-535" aria-hidden="true" tabindex="-1"></a>            abc.calculate_abc(H, A, B, C)</span>
<span id="cb5-536"><a href="#cb5-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-537"><a href="#cb5-537" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Error: Could not calculate the Expectation Value"</span>)</span>
<span id="cb5-538"><a href="#cb5-538" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb5-539"><a href="#cb5-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-540"><a href="#cb5-540" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center"><div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>